"use strict";(self.webpackChunke_5_pe_0_n_github_io=self.webpackChunke_5_pe_0_n_github_io||[]).push([[999],{3534:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"algorithms/flow-algorithms","title":"Flow Networks","description":"Ford-Fulkerson","source":"@site/docs/algorithms/flow-algorithms.md","sourceDirName":"algorithms","slug":"/algorithms/flow-algorithms","permalink":"/docs/algorithms/flow-algorithms","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"techNoteSidebar","previous":{"title":"Bit Manipulation","permalink":"/docs/algorithms/bit-manipulation"},"next":{"title":"Graph Algorithms","permalink":"/docs/algorithms/graph-algorithms"}}');var i=t(6070),a=t(5248);const r={},d="Flow Networks",l={},c=[{value:"Ford-Fulkerson",id:"ford-fulkerson",level:2},{value:"Bipartite Matching",id:"bipartite-matching",level:2}];function o(n){const e={annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"flow-networks",children:"Flow Networks"})}),"\n",(0,i.jsx)(e.h2,{id:"ford-fulkerson",children:"Ford-Fulkerson"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"determine maximum flow"}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsxs)(e.span,{className:"katex",children:[(0,i.jsx)(e.span,{className:"katex-mathml",children:(0,i.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(e.semantics,{children:[(0,i.jsxs)(e.mrow,{children:[(0,i.jsx)(e.mi,{children:"O"}),(0,i.jsx)(e.mo,{stretchy:"false",children:"("}),(0,i.jsx)(e.mi,{children:"F"}),(0,i.jsx)(e.mo,{stretchy:"false",children:"\u2223"}),(0,i.jsx)(e.mi,{children:"E"}),(0,i.jsx)(e.mo,{stretchy:"false",children:"\u2223"}),(0,i.jsx)(e.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(e.annotation,{encoding:"application/x-tex",children:"O(F \\lvert E \\rvert)"})]})})}),(0,i.jsx)(e.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(e.span,{className:"mopen",children:"("}),(0,i.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"F"}),(0,i.jsx)(e.span,{className:"mopen",children:"\u2223"}),(0,i.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),(0,i.jsx)(e.span,{className:"mclose",children:"\u2223)"})]})})]})}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.img,{alt:"flow_network",src:t(6420).A+"",width:"376",height:"263"}),"\n",(0,i.jsx)(e.img,{alt:"residual_network",src:t(6977).A+"",width:"851",height:"315"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-txt",metastring:'title="test1.txt"',children:"5 7 0 4\n0 1 10\n0 2 2\n1 2 6\n1 3 6\n2 4 5\n3 2 3\n3 4 8\n11\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",metastring:'title="O(F|E|) / C++"',children:'#include <fstream>\n#include <memory.h>\n#include <stdio.h>\n#include <vector>\n\n#define MAX_N 100\n#define INF 1\'000\'000\'000\n\nusing namespace std;\n\nstruct Edge {\n  int v, cap, rev;\n};\n\nint n, m, s, t;\nvector<Edge> G[MAX_N];\nbool used[MAX_N];\n\nvoid add_edge(int u, int v, int cap) {\n  G[u].push_back(Edge{v, cap, G[v].size()});\n  G[v].push_back(Edge{u, 0, G[u].size() - 1});\n}\n\nint dfs(int u, int t, int f) {\n  if (u == t) {\n    return f;\n  }\n  used[u] = true;\n  for (int i = 0; i < G[u].size(); ++i) {\n    Edge &e = G[u][i];\n    if (!used[e.v] && e.cap > 0) {\n      int d = dfs(e.v, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.v][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int res = 0;\n  for (;;) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if (f == 0) {\n      return res;\n    }\n    res += f;\n  }\n}\n\nvoid solve() {\n  int res = max_flow(s, t);\n  printf("%d\\n", res);\n}\n\nint main() {\n  ifstream ifs("../testset/maximum_traffic/test1.txt");\n  ifs >> n >> m >> s >> t;\n  for (int i = 0; i < m; ++i) {\n    int u, v, cap;\n    ifs >> u >> v >> cap;\n    add_edge(u, v, cap);\n  }\n  solve();\n}\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",metastring:'title="O(F|E|) / Python"',children:"INF = int(1e9)\n\n\ndef ns(f):\n    return next(f).strip()\n\n\nclass Edge:\n    def __init__(self, v, cap, rev):\n        self.v = v\n        self.cap = cap\n        self.rev = rev\n\n\nwith open(\"../testset/maximum_traffic/test1.txt\", 'r') as f:\n    n, m, s, t = map(int, ns(f).split())\n    G = [[] for _ in range(n)]\n\n    def add_edge(u, v, cap):\n        global G\n        G[u].append(Edge(v, cap, len(G[v])))\n        G[v].append(Edge(u, 0, len(G[u]) - 1))\n\n    for _ in range(m):\n        add_edge(*map(int, ns(f).split()))\n\n\ndef dfs(u, t, f, used):\n    if u == t:\n        return f\n    used[u] = True\n    for e in G[u]:\n        if not used[e.v] and e.cap > 0:\n            d = dfs(e.v, t, min(f, e.cap), used)\n            if d > 0:\n                e.cap -= d\n                G[e.v][e.rev].cap += d\n                return d\n    return 0\n\n\ndef max_flow(s, t):\n    res = 0\n    while True:\n        used = [False] * n\n        f = dfs(s, t, INF, used)\n        if f == 0:\n            return res\n        res += f\n\n\nprint(max_flow(s, t))\n"})}),"\n",(0,i.jsx)(e.h2,{id:"bipartite-matching",children:"Bipartite Matching"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{alt:"bipartite_matching",src:t(1769).A+"",width:"320",height:"204"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-txt",metastring:'title="text2.txt"',children:"3 3 4\n1 1\n1 3\n2 2\n3 2\n2\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",metastring:'title="C++"',children:'#include <fstream>\n#include <stdio.h>\n#include <vector>\n\n#define MAX_N 1000\n#define MAX_M 1000\n#define MAX_V MAX_N + MAX_M\n\nusing namespace std;\n\nint N, M, K;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int u) {\n  used[u] = true;\n  for (auto v : G[u]) {\n    int _u = match[v];\n    if (_u < 0 || (!used[_u] && dfs(_u))) {\n      // u is computers, _u is computer which is already assigned to work v, v is work\n      // increase num of matching only when w < 0 i.e. _u find a new work.\n      match[u] = v;\n      match[v] = u;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching() {\n  int res = 0;\n  fill(match, match + N + M, -1);\n  for (int u = 0; u < N; ++u) { // only left side vertexes\n    if (match[u] < 0) {\n      fill(used, used + N + M, 0);\n      if (dfs(u)) {\n        ++res;\n      }\n    }\n  }\n  return res;\n}\n\nvoid solve() { printf("%d\\n", bipartite_matching()); }\n\nint main() {\n  ifstream ifs("../testset/work_assignment/test2.txt");\n  ifs >> N >> M >> K;\n  for (int i = 0; i < K; ++i) {\n    int u, v;\n    ifs >> u >> v;\n    --u;\n    --v;\n    add_edge(u, N + v);\n    add_edge(N + v, u);\n  }\n  solve();\n}\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",metastring:'title="Python"',children:"def ns(f):\n    return next(f).strip()\n\n\nwith open(\"../testset/work_assignment/test1.txt\", 'r') as f:\n    N, M, K = map(int, ns(f).split())\n    V = N + M\n    G = [[] for _ in range(V)]\n    for _ in range(K):\n        u, v = map(int, ns(f).split())\n        u -= 1\n        v -= 1\n        G[u].append(N + v)\n        G[N + v].append(u)\n\n\ndef dfs(u, used, match):\n    used[u] = True\n    for v in G[u]:\n        _u = match[v]\n        if _u < 0 or (not used[_u] and dfs(_u, used, match)):\n            match[u] = v\n            match[v] = u\n            return True\n    return False\n\n\ndef bipartite_matching():\n    res = 0\n    match = [-1] * V\n    for u in range(N):\n        if match[u] < 0:\n            used = [False] * V\n            if dfs(u, used, match):\n                res += 1\n    return res\n\n\nprint(bipartite_matching())\n"})})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(o,{...n})}):o(n)}},1769:(n,e,t)=>{t.d(e,{A:()=>s});const s=t.p+"assets/images/bipartite_matching-13a19e868c3d0357d0ea4c6205feaa92.png"},6420:(n,e,t)=>{t.d(e,{A:()=>s});const s=t.p+"assets/images/flow_network-afb51734c6fcadb337a66c8553db9a24.png"},6977:(n,e,t)=>{t.d(e,{A:()=>s});const s=t.p+"assets/images/residual_network-a0e4c50e12d7288e6411e3d298c69f31.png"},5248:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>d});var s=t(758);const i={},a=s.createContext(i);function r(n){const e=s.useContext(a);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),s.createElement(a.Provider,{value:e},n.children)}}}]);