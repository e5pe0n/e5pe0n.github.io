"use strict";(self.webpackChunke_5_pe_0_n_github_io=self.webpackChunke_5_pe_0_n_github_io||[]).push([[110],{9613:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>k});var i=a(9496);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,i,l=function(e,t){if(null==e)return{};var a,i,l={},n=Object.keys(e);for(i=0;i<n.length;i++)a=n[i],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(i=0;i<n.length;i++)a=n[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var o=i.createContext({}),u=function(e){var t=i.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=u(e.components);return i.createElement(o.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var a=e.components,l=e.mdxType,n=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(a),d=l,k=c["".concat(o,".").concat(d)]||c[d]||m[d]||n;return a?i.createElement(k,r(r({ref:t},p),{},{components:a})):i.createElement(k,r({ref:t},p))}));function k(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var n=a.length,r=new Array(n);r[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[c]="string"==typeof e?e:l,r[1]=s;for(var u=2;u<n;u++)r[u]=a[u];return i.createElement.apply(null,r)}return i.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5573:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>m,frontMatter:()=>n,metadata:()=>s,toc:()=>u});var i=a(8957),l=(a(9496),a(9613));const n={},r="Software Design",s={unversionedId:"software/software-design",id:"software/software-design",title:"Software Design",description:"Axioms",source:"@site/docs/software/software-design.md",sourceDirName:"software",slug:"/software/software-design",permalink:"/docs/software/software-design",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"techNoteSidebar",previous:{title:"Software",permalink:"/docs/category/software"},next:{title:"System",permalink:"/docs/category/system"}},o={},u=[{value:"Axioms",id:"axioms",level:2},{value:"Software Architecture",id:"software-architecture",level:2},{value:"Domain",id:"domain",level:2},{value:"Model",id:"model",level:2},{value:"SOLID Principles",id:"solid-principles",level:2},{value:"SRP; Single Responsibility Principle",id:"srp-single-responsibility-principle",level:3},{value:"OCP; Open-Closed Principle",id:"ocp-open-closed-principle",level:3},{value:"LSP; Liskov Substitution Principle",id:"lsp-liskov-substitution-principle",level:3},{value:"ISP; Interface Segregation Principle",id:"isp-interface-segregation-principle",level:3},{value:"DIP; Dependency Inversion Principle",id:"dip-dependency-inversion-principle",level:3},{value:"Components",id:"components",level:2},{value:"Component-level Principles",id:"component-level-principles",level:3},{value:"REP; Reuse/Release Equivalence Principle",id:"rep-reuserelease-equivalence-principle",level:4},{value:"CCP; Common Closure Principle",id:"ccp-common-closure-principle",level:4},{value:"CRP; Common Reuse Principle",id:"crp-common-reuse-principle",level:4},{value:"Component Dependencies",id:"component-dependencies",level:3},{value:"ADP; Asynclic Dependencies Principle",id:"adp-asynclic-dependencies-principle",level:4},{value:"SDP; Stable Dependencies Principle",id:"sdp-stable-dependencies-principle",level:4},{value:"SAP; Stable Abstraction Principle",id:"sap-stable-abstraction-principle",level:4},{value:"Business Rules",id:"business-rules",level:2},{value:"Humble Objects",id:"humble-objects",level:2},{value:"Layered Architecture",id:"layered-architecture",level:2},{value:"Model-Driven Design",id:"model-driven-design",level:2},{value:"Entities",id:"entities",level:3},{value:"Value Objects",id:"value-objects",level:3},{value:"Services",id:"services",level:3},{value:"Aggregates",id:"aggregates",level:3},{value:"Factories",id:"factories",level:3},{value:"Referencies",id:"referencies",level:2}],p={toc:u},c="wrapper";function m(e){let{components:t,...a}=e;return(0,l.kt)(c,(0,i.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"software-design"},"Software Design"),(0,l.kt)("h2",{id:"axioms"},"Axioms"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"software design is not a solid stuff",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"designing software architecture never ends"),(0,l.kt)("li",{parentName:"ul"},"it is changing over development"))),(0,l.kt)("li",{parentName:"ul"},"the primary purpose of architecture is to support the life cycle of the system",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"good architecture makes the system easy to understand, easy to develop, easy to maintain, and easy to deploy"),(0,l.kt)("li",{parentName:"ul"},"the ultimate goal is to minimize the lifetime cost of the system and to maxmize programmer productivity"))),(0,l.kt)("li",{parentName:"ul"},"the architecture of the system should elevate the use cases, the features, and the required behaviours of the system to first-class entities that are visible landmarks for the developers"),(0,l.kt)("li",{parentName:"ul"},"good architecture centered on use cases so that architects can safely describe the structures that support those use cases without commiting to frameworks, tools, and environments")),(0,l.kt)("h2",{id:"software-architecture"},"Software Architecture"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Structure",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"type of architecture style",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"microservice"),(0,l.kt)("li",{parentName:"ul"},"layered"),(0,l.kt)("li",{parentName:"ul"},"microkernel"))))),(0,l.kt)("li",{parentName:"ul"},"Architecture Charactaristics",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"success criteria of a system",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"availability"),(0,l.kt)("li",{parentName:"ul"},"reliability"),(0,l.kt)("li",{parentName:"ul"},"testability"),(0,l.kt)("li",{parentName:"ul"},"scalability"),(0,l.kt)("li",{parentName:"ul"},"security"),(0,l.kt)("li",{parentName:"ul"},"agility"),(0,l.kt)("li",{parentName:"ul"},"fault tolerance"),(0,l.kt)("li",{parentName:"ul"},"elasticity"),(0,l.kt)("li",{parentName:"ul"},"receverability"),(0,l.kt)("li",{parentName:"ul"},"performance"),(0,l.kt)("li",{parentName:"ul"},"deployablility"),(0,l.kt)("li",{parentName:"ul"},"learnability"))))),(0,l.kt)("li",{parentName:"ul"},"Architecture Decision",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"rules for how a system should be constructed"))),(0,l.kt)("li",{parentName:"ul"},"Design Principles",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"a guideline")))),(0,l.kt)("h2",{id:"domain"},"Domain"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"subject area to which users applies the program"),(0,l.kt)("li",{parentName:"ul"},"subject area of the problem we solve using software")),(0,l.kt)("h2",{id:"model"},"Model"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"simplification"),(0,l.kt)("li",{parentName:"ul"},"abstraction",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"filter out extraneous details"))),(0,l.kt)("li",{parentName:"ul"},"effective modeling",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"knowledge crunching"),(0,l.kt)("li",{parentName:"ul"},"cultivating a language based on the model",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Ubiquitous Language",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"changes in the Ubiquitous Language are changes to the model"))))),(0,l.kt)("li",{parentName:"ul"},"iteration",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"software development is all design"))))),(0,l.kt)("li",{parentName:"ul"},"don't just model reality (e.g. actual manual operations that will be automated by software/system) as is",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"model them from the perspective of software/system too")))),(0,l.kt)("h2",{id:"solid-principles"},"SOLID Principles"),(0,l.kt)("p",null,"suggest how to arrange functions and data structures into classes, and how those classes should be interconnected to design the mid-level (module level) software architectures that"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"tolerate change"),(0,l.kt)("li",{parentName:"ul"},"are easy to undarstand"),(0,l.kt)("li",{parentName:"ul"},"are reusable in many software systems")),(0,l.kt)("h3",{id:"srp-single-responsibility-principle"},"SRP; Single Responsibility Principle"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a module should be responsible to one, and only one, actor",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"actor: group of user or stakeholder who wants the system changed in the same way"))),(0,l.kt)("li",{parentName:"ul"},"a moule should NOT have multiple reasons to change")),(0,l.kt)("h3",{id:"ocp-open-closed-principle"},"OCP; Open-Closed Principle"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a software architect should be open for extension but closed for modification"),(0,l.kt)("li",{parentName:"ul"},"if SRP is obeyed, a feature extension won't affect to modules for other features"),(0,l.kt)("li",{parentName:"ul"},"associated with CCP")),(0,l.kt)("h3",{id:"lsp-liskov-substitution-principle"},"LSP; Liskov Substitution Principle"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"polymorphism")),(0,l.kt)("h3",{id:"isp-interface-segregation-principle"},"ISP; Interface Segregation Principle"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"avoid depending on things that they don't use"),(0,l.kt)("li",{parentName:"ul"},"have clear abstraction/concept of the module")),(0,l.kt)("h3",{id:"dip-dependency-inversion-principle"},"DIP; Dependency Inversion Principle"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"implement interfaces for the high-level module which uses lower-level modules"),(0,l.kt)("li",{parentName:"ul"},"lower-level modules should NOT know the implementation details of higher-level modules"),(0,l.kt)("li",{parentName:"ul"},"have lower-level modules obey the interfaces",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"now we can have inverted dependency from lower-level to higher-level without knowledge about implemetation details of higher-level module")))),(0,l.kt)("h2",{id:"components"},"Components"),(0,l.kt)("h3",{id:"component-level-principles"},"Component-level Principles"),(0,l.kt)("h4",{id:"rep-reuserelease-equivalence-principle"},"REP; Reuse/Release Equivalence Principle"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the granule of reuse is the granule of release")),(0,l.kt)("h4",{id:"ccp-common-closure-principle"},"CCP; Common Closure Principle"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"component-level ",(0,l.kt)("a",{parentName:"li",href:"#srp-single-responsibility-principle"},"SRP"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"a component should NOT have multiple reasons to change")))),(0,l.kt)("h4",{id:"crp-common-reuse-principle"},"CRP; Common Reuse Principle"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"component-level ",(0,l.kt)("a",{parentName:"li",href:"#isp-interface-segregation-principle"},"ISP"))),(0,l.kt)("h3",{id:"component-dependencies"},"Component Dependencies"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"component structure cannot be designed from the top down",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"component dependencies graph is created for the first time if it reached the time dependency management was necessary"),(0,l.kt)("li",{parentName:"ul"},"component dependencies graphs is for mapping to buildability and maintainability of the application; not for describing the function of the application")))),(0,l.kt)("h4",{id:"adp-asynclic-dependencies-principle"},"ADP; Asynclic Dependencies Principle"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"allow no cycles in the component dependency graph")),(0,l.kt)("h4",{id:"sdp-stable-dependencies-principle"},"SDP; Stable Dependencies Principle"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"depend in the direction of stability"),(0,l.kt)("li",{parentName:"ul"},"ensure that modules that are intended to be easy to change are not depended on by modules that are harder to change")),(0,l.kt)("h4",{id:"sap-stable-abstraction-principle"},"SAP; Stable Abstraction Principle"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a component should be as abstract as it is stable"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#sdp-stable-dependencies-principle"},"SDP")," + ",(0,l.kt)("a",{parentName:"li",href:"#sap-stable-abstraction-principle"},"SAP")," -> dependencies run in the direction of abstraction")),(0,l.kt)("h2",{id:"business-rules"},"Business Rules"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Critical Business Rules",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"make or save the business money"),(0,l.kt)("li",{parentName:"ul"},"some of them are purelly irrespective of whether they were implemented on a computer"))),(0,l.kt)("li",{parentName:"ul"},"Entity",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Critical Business Data",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"data required by critical business rules"))),(0,l.kt)("li",{parentName:"ul"},"generalized concept; not ",(0,l.kt)("em",{parentName:"li"},"application-specific")))),(0,l.kt)("li",{parentName:"ul"},"Use Cases",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"define ",(0,l.kt)("em",{parentName:"li"},"application-specific")," business rules",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"automated operation to make or save the business money"),(0,l.kt)("li",{parentName:"ul"},"at lower-level than Entities since Use Cases depend on the application/system; not generalized as much as Entities"))),(0,l.kt)("li",{parentName:"ul"},"e.g. apply an estimation (validation) to user info for loan then create Customer entity if acceptable"),(0,l.kt)("li",{parentName:"ul"},"have input and ouput",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"but should not depend on how input and output are delivered",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g. HTTP request and response, HTML, SQL")))))))),(0,l.kt)("mermaid",{value:"classDiagram\n    class Loan{\n        - principle\n        - rate\n        - period\n        + makePayment() // Business Rule\n        + applyInterest() // Business Rule\n        + chargeLateFee() // Business Rule\n    }"}),(0,l.kt)("h2",{id:"humble-objects"},"Humble Objects"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"separate behaviours into tastables and non-testables"),(0,l.kt)("li",{parentName:"ul"},"from the uesr's point of view, an object is simply a set of operations; an object represent behaviours",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"becaues users cannot see private fields")))),(0,l.kt)("h2",{id:"layered-architecture"},"Layered Architecture"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"User Interface (or Presentation Layer)"),(0,l.kt)("li",{parentName:"ul"},"Application Layer",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"services"),(0,l.kt)("li",{parentName:"ul"},"not contain business rules or knowledge"),(0,l.kt)("li",{parentName:"ul"},"not have state reflecting business situation"),(0,l.kt)("li",{parentName:"ul"},"only coordinates tasks and delegates work to collaborations of domain objects in the next layer down"))),(0,l.kt)("li",{parentName:"ul"},"Domain Layer (or Model Layer)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"business situation"),(0,l.kt)("li",{parentName:"ul"},"business rules"),(0,l.kt)("li",{parentName:"ul"},"control and use state reflecting the business situation"))),(0,l.kt)("li",{parentName:"ul"},"Infrastructure Layer",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"ORM")))),(0,l.kt)("h2",{id:"model-driven-design"},"Model-Driven Design"),(0,l.kt)("mermaid",{value:"flowchart LR\n  mdd(Model-Driven Design) --\x3e|express model with|s(services)\n  mdd(Model-Driven Design) --\x3e|express model with|e(Entities)\n  mdd(Model-Driven Design) --\x3e|express model with|vo(Value Object)\n  mdd(Model-Driven Design) --\x3e|isolate domain with|la(Layered Architecture)\n\n  e --\x3e|access with|r(Repositories)\n  e --\x3e|maintain integrity with|a(Aggregates)\n  e --\x3e|act as root of|a\n  e --\x3e|encapsulate with|f(Factories)\n\n  vo --\x3e|encapsulate with|a\n  vo --\x3e|encapsulate with|f\n\n  a --\x3e|encapsulate with|f\n  a --\x3e|access with|r"}),(0,l.kt)("h3",{id:"entities"},"Entities"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"distinguished by its identity",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"guaranteed the uniqueness"))),(0,l.kt)("li",{parentName:"ul"},"need to maintain the life cycle"),(0,l.kt)("li",{parentName:"ul"},"e.g. user")),(0,l.kt)("h3",{id:"value-objects"},"Value Objects"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"representing a descriptive aspect of the domain with no conceptual identity",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"representing elements of the design that we care about only for ",(0,l.kt)("em",{parentName:"li"},"what")," they are, not ",(0,l.kt)("em",{parentName:"li"},"who")," or ",(0,l.kt)("em",{parentName:"li"},"which")," they are"))),(0,l.kt)("li",{parentName:"ul"},"immutable"),(0,l.kt)("li",{parentName:"ul"},"disposable"),(0,l.kt)("li",{parentName:"ul"},"e.g.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"attributes of an Entity"),(0,l.kt)("li",{parentName:"ul"},"used as parameters in messages between objects")))),(0,l.kt)("mermaid",{value:'classDiagram\n  note for Customer "Entity"\n  note for Address "Value Object"\n  Customer *-- Address\n  class Customer{\n    customerID\n    name\n    address\n  }\n  class Address{\n    street\n    city\n    state\n  }'}),(0,l.kt)("h3",{id:"services"},"Services"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"overview",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"an operation offered as an interface that stands alone in the model, without encapsulating state, as Entities and Value Objects do",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"operation names should come from the Ubiquitous Language or be introduced into it"),(0,l.kt)("li",{parentName:"ul"},"parameters and results should be domain objects"))))),(0,l.kt)("li",{parentName:"ul"},"characteristics",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the operation relates to a domain concept that is not a natural part of an Entity or Value Object"),(0,l.kt)("li",{parentName:"ul"},"the interface is defined in terms of other elements of the domain model"),(0,l.kt)("li",{parentName:"ul"},"the operation is stateless")))),(0,l.kt)("h3",{id:"aggregates"},"Aggregates"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a cluster of associated objects that we treat as a unit for the purpose of data changes"),(0,l.kt)("li",{parentName:"ul"},"responsibilities",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"invariant enforcement"),(0,l.kt)("li",{parentName:"ul"},"change management"))),(0,l.kt)("li",{parentName:"ul"},"consists of a root and a boundary",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"root",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"a single, specific Entity"),(0,l.kt)("li",{parentName:"ul"},"objects outside the Aggregate can reference to only the root"),(0,l.kt)("li",{parentName:"ul"},"can be obtained directly from resource (e.g. database)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"other objects must be found by traversal of associations"))))),(0,l.kt)("li",{parentName:"ul"},"boundary",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"a delete operation must remove everything within the boundary at once"),(0,l.kt)("li",{parentName:"ul"},"when a change to any object within the boundary is commited, all invariants of the whole Aggregate must be satisfied")))))),(0,l.kt)("h3",{id:"factories"},"Factories"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"create and reconstitute complex objects")),(0,l.kt)("h2",{id:"referencies"},"Referencies"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://www.oreilly.com/library/view/clean-architecture-a/9780134494272/"},"Clean Architecture: A Craftsman\u2019s Guide to Software Structure and Design")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://www.oreilly.com/library/view/domain-driven-design-tackling/0321125215/"},"Domain-Driven Design: Tackling Complexity in the Heart of Software")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://www.oreilly.com/library/view/fundamentals-of-software/9781492043447/"},"Fundamentals of Software Architecture")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://www.amazon.co.jp/-/en/John-K-Ousterhout-ebook/dp/B09B8LFKQL"},"A Philosophy of Software Design"))))}m.isMDXComponent=!0}}]);