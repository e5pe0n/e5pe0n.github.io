"use strict";(self.webpackChunke_5_pe_0_n_github_io=self.webpackChunke_5_pe_0_n_github_io||[]).push([[3035],{9613:(e,n,a)=>{a.d(n,{Zo:()=>m,kt:()=>k});var t=a(9496);function s(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){s(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function p(e,n){if(null==e)return{};var a,t,s=function(e,n){if(null==e)return{};var a,t,s={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(s[a]=e[a]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var i=t.createContext({}),o=function(e){var n=t.useContext(i),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},m=function(e){var n=o(e.components);return t.createElement(i.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef((function(e,n){var a=e.components,s=e.mdxType,r=e.originalType,i=e.parentName,m=p(e,["components","mdxType","originalType","parentName"]),u=o(a),c=s,k=u["".concat(i,".").concat(c)]||u[c]||d[c]||r;return a?t.createElement(k,l(l({ref:n},m),{},{components:a})):t.createElement(k,l({ref:n},m))}));function k(e,n){var a=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=a.length,l=new Array(r);l[0]=c;var p={};for(var i in n)hasOwnProperty.call(n,i)&&(p[i]=n[i]);p.originalType=e,p[u]="string"==typeof e?e:s,l[1]=p;for(var o=2;o<r;o++)l[o]=a[o];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}c.displayName="MDXCreateElement"},6022:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>p,toc:()=>o});var t=a(8957),s=(a(9496),a(9613));const r={},l="Fundamentals",p={unversionedId:"coding/haskell/fundamentals",id:"coding/haskell/fundamentals",title:"Fundamentals",description:"Naming Requirements of Functions",source:"@site/docs/coding/haskell/fundamentals.md",sourceDirName:"coding/haskell",slug:"/coding/haskell/fundamentals",permalink:"/docs/coding/haskell/fundamentals",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"techNoteSidebar",previous:{title:"Haskell",permalink:"/docs/category/haskell"},next:{title:"JavaScript",permalink:"/docs/category/javascript"}},i={},o=[{value:"Naming Requirements of Functions",id:"naming-requirements-of-functions",level:2},{value:"Standard Prelude",id:"standard-prelude",level:2},{value:"Types",id:"types",level:2},{value:"Notation 1",id:"notation-1",level:3},{value:"Notation 2",id:"notation-2",level:3},{value:"Type Interface and Type Safe",id:"type-interface-and-type-safe",level:3},{value:"Basic Types",id:"basic-types",level:3},{value:"List Types",id:"list-types",level:3},{value:"Tuple Types",id:"tuple-types",level:3},{value:"Function Types",id:"function-types",level:3},{value:"Curried Functions",id:"curried-functions",level:4},{value:"Polymorphic Types",id:"polymorphic-types",level:3},{value:"Type Variable",id:"type-variable",level:4},{value:"Overloaded Types",id:"overloaded-types",level:3},{value:"Class Constraint",id:"class-constraint",level:4},{value:"Classes",id:"classes",level:2},{value:"Eq - equality types",id:"eq---equality-types",level:3},{value:"Ord - ordered types",id:"ord---ordered-types",level:3},{value:"Show - showable types",id:"show---showable-types",level:3},{value:"Read - readable types",id:"read---readable-types",level:3},{value:"Num - numeric types",id:"num---numeric-types",level:3},{value:"Integral - integral types",id:"integral---integral-types",level:3},{value:"Fractional - fractional types",id:"fractional---fractional-types",level:3},{value:"Definning Functions",id:"definning-functions",level:2},{value:"Conditional Expressions",id:"conditional-expressions",level:3},{value:"Guarded Equations",id:"guarded-equations",level:3},{value:"Pattern matching",id:"pattern-matching",level:3},{value:"Tuple Patterns",id:"tuple-patterns",level:4},{value:"List Patterns",id:"list-patterns",level:4},{value:"Lambda Expressions",id:"lambda-expressions",level:3},{value:"Operator Sections",id:"operator-sections",level:3},{value:"List Comprehensions",id:"list-comprehensions",level:2},{value:"Guard",id:"guard",level:3},{value:"zip function",id:"zip-function",level:3},{value:"String comprehensions",id:"string-comprehensions",level:3},{value:"Recursive Functions",id:"recursive-functions",level:2},{value:"Recursion on Lists",id:"recursion-on-lists",level:3},{value:"Multiple Arguments",id:"multiple-arguments",level:3},{value:"Multiple Recursion",id:"multiple-recursion",level:3},{value:"Mutual Recursion",id:"mutual-recursion",level:3},{value:"Generalizing and Simplifying",id:"generalizing-and-simplifying",level:3},{value:"Higher-Order Functions",id:"higher-order-functions",level:2},{value:"Processing Lists",id:"processing-lists",level:3},{value:"foldr()",id:"foldr",level:3},{value:"foldl()",id:"foldl",level:3},{value:"Composition Operator",id:"composition-operator",level:3},{value:"Type Declarations",id:"type-declarations",level:2},{value:"Data Declarations",id:"data-declarations",level:2},{value:"Cosntructor Functions",id:"cosntructor-functions",level:3},{value:"vs. normal functions",id:"vs-normal-functions",level:4},{value:"Newtype Declarations",id:"newtype-declarations",level:3},{value:"vs. type",id:"vs-type",level:4},{value:"vs. data",id:"vs-data",level:4},{value:"Recursive Types",id:"recursive-types",level:3},{value:"Class and Instance Declarations",id:"class-and-instance-declarations",level:2},{value:"Derived Instances",id:"derived-instances",level:2},{value:"Interactive Programming",id:"interactive-programming",level:2},{value:"Basic Actions",id:"basic-actions",level:3},{value:"Sequencing",id:"sequencing",level:3},{value:"Derived primitives",id:"derived-primitives",level:3},{value:"Functors",id:"functors",level:2},{value:"Functor Laws",id:"functor-laws",level:3},{value:"Applicatives",id:"applicatives",level:2},{value:"applicative functors; applicative",id:"applicative-functors-applicative",level:3},{value:"Applicative Laws",id:"applicative-laws",level:3},{value:"Infix ver.",id:"infix-ver",level:3},{value:"Monads",id:"monads",level:2},{value:"<code>&gt;&gt;=</code> operator",id:"-operator",level:3},{value:"Monad Laws",id:"monad-laws",level:3},{value:"Usecases",id:"usecases",level:3},{value:"The State Monad",id:"the-state-monad",level:3},{value:"<em>state tronsformer</em>; <em>ST</em>",id:"state-tronsformer-st",level:4},{value:"Generic Functions",id:"generic-functions",level:3},{value:"mapM()",id:"mapm",level:4},{value:"filterM()",id:"filterm",level:4},{value:"join()",id:"join",level:4},{value:"Alternative",id:"alternative",level:2},{value:"Alternative Laws",id:"alternative-laws",level:3},{value:"Alternative Instances",id:"alternative-instances",level:3},{value:"Monoids",id:"monoids",level:2},{value:"Monoid Laws",id:"monoid-laws",level:3},{value:"Data.Monoid",id:"datamonoid",level:3},{value:"Lists",id:"lists",level:4},{value:"Maybe",id:"maybe",level:4},{value:"Sum",id:"sum",level:4},{value:"Product",id:"product",level:4},{value:"All",id:"all",level:4},{value:"Any",id:"any",level:4},{value:"Foldables",id:"foldables",level:2},{value:"List",id:"list",level:3},{value:"Tree",id:"tree",level:3},{value:"Generic Functions",id:"generic-functions-1",level:3},{value:"and()",id:"and",level:4},{value:"or()",id:"or",level:4},{value:"all()",id:"all-1",level:4},{value:"any()",id:"any-1",level:4},{value:"concat()",id:"concat",level:4},{value:"Traversable",id:"traversable",level:2},{value:"List",id:"list-1",level:3},{value:"Tree",id:"tree-1",level:3},{value:"Lazy Evaluation",id:"lazy-evaluation",level:2},{value:"call-by-value evaluation",id:"call-by-value-evaluation",level:3},{value:"call-by-name evaluation",id:"call-by-name-evaluation",level:3},{value:"Modular Programming",id:"modular-programming",level:3},{value:"Strict Application",id:"strict-application",level:3},{value:"foldl&#39;",id:"foldl-1",level:3},{value:"Reasoning",id:"reasoning",level:2},{value:"Induction",id:"induction",level:3},{value:"Improve Computing Time",id:"improve-computing-time",level:3},{value:"reverse()",id:"reverse",level:4},{value:"flatten()",id:"flatten",level:4}],m={toc:o},u="wrapper";function d(e){let{components:n,...r}=e;return(0,s.kt)(u,(0,t.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"fundamentals"},"Fundamentals"),(0,s.kt)("h2",{id:"naming-requirements-of-functions"},"Naming Requirements of Functions"),(0,s.kt)("p",null,"These are ",(0,s.kt)("em",{parentName:"p"},"keywords"),"; reversed words.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"case  class  data  default  deriving\ndo  else  foreign  if  import  in\ninfix  infixl  infixr  instance  let\nmodule  newtype  of  then  type  where\n")),(0,s.kt)("h2",{id:"standard-prelude"},"Standard Prelude"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"main = do\n  let x = [1, 2, 3, 4, 5]\n  print (head x) -- 1\n  print (tail x) -- [2, 3, 4, 5]\n  print (init x) -- [1, 2, 3, 4]\n  print (last x) -- 5\n  print (x !! 2) -- 3\n  print (take 3 x) -- [1, 2, 3]\n  print (drop 3 x) -- [4, 5]\n  print (length x) -- 5\n  print (sum x) -- 15\n  print (product x) -- 120\n  print ([1, 2, 3] ++ [4, 5]) -- [1 , 2, 3, 4, 5]\n  print (reverse x) -- [5, 4, 3, 2, 1]\n")),(0,s.kt)("h2",{id:"types"},"Types"),(0,s.kt)("p",null,"A ",(0,s.kt)("em",{parentName:"p"},"type")," is a collection of related values.  "),(0,s.kt)("h3",{id:"notation-1"},"Notation 1"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"v :: T")," means ",(0,s.kt)("inlineCode",{parentName:"p"},"e")," is a value in the type ",(0,s.kt)("inlineCode",{parentName:"p"},"T"),".  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"False :: Bool\nTrue :: Bool\nnot :: Bool -> Bool\n")),(0,s.kt)("h3",{id:"notation-2"},"Notation 2"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"e :: T")," means evaluation of the expression ",(0,s.kt)("inlineCode",{parentName:"p"},"e")," will produce a value of type ",(0,s.kt)("inlineCode",{parentName:"p"},"T"),".  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"not False :: Bool\nnot True :: Bool\nnot (not False) :: Bool\n")),(0,s.kt)("p",null,"Typing rule"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"f :: A -> B  e :: A\n-------------------\n      f e -> B\n")),(0,s.kt)("h3",{id:"type-interface-and-type-safe"},"Type Interface and Type Safe"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"type interface")," that evaluates types under typing rule.",(0,s.kt)("br",{parentName:"p"}),"\n","type interface precedes evaluation of values so Haskell programs are ",(0,s.kt)("strong",{parentName:"p"},"type safe"),"."),(0,s.kt)("h3",{id:"basic-types"},"Basic Types"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"center"},"types"),(0,s.kt)("th",{parentName:"tr",align:"center"},"description"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"center"},"Bool"),(0,s.kt)("td",{parentName:"tr",align:"center"})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"center"},"Char"),(0,s.kt)("td",{parentName:"tr",align:"center"})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"center"},"String"),(0,s.kt)("td",{parentName:"tr",align:"center"})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"center"},"Int"),(0,s.kt)("td",{parentName:"tr",align:"center"},"fixed-precision intergers. the range is ",(0,s.kt)("span",{parentName:"td",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"["),(0,s.kt)("mo",{parentName:"mrow"},"\u2212"),(0,s.kt)("msup",{parentName:"mrow"},(0,s.kt)("mn",{parentName:"msup"},"2"),(0,s.kt)("mn",{parentName:"msup"},"63")),(0,s.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,s.kt)("msup",{parentName:"mrow"},(0,s.kt)("mn",{parentName:"msup"},"2"),(0,s.kt)("mn",{parentName:"msup"},"63")),(0,s.kt)("mo",{parentName:"mrow"},"\u2212"),(0,s.kt)("mn",{parentName:"mrow"},"1"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"]")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"[-2^{63}, 2^{63} - 1]")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mopen"},"["),(0,s.kt)("span",{parentName:"span",className:"mord"},"\u2212"),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord"},"2"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"63"))))))))),(0,s.kt)("span",{parentName:"span",className:"mpunct"},","),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord"},"2"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"63"))))))))),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"]"))))))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"center"},"Integer"),(0,s.kt)("td",{parentName:"tr",align:"center"},"arbitarary-precision integers")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"center"},"Float"),(0,s.kt)("td",{parentName:"tr",align:"center"},"single-precision floating-point numbers")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"center"},"Double"),(0,s.kt)("td",{parentName:"tr",align:"center"},"double-precision floating-point numbers")))),(0,s.kt)("h3",{id:"list-types"},"List Types"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"[['a', 'b'], ['c', 'd', 'e']] :: [[Char]]\n")),(0,s.kt)("h3",{id:"tuple-types"},"Tuple Types"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"arity"),": the number of components in a tuple"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"arity zero: ",(0,s.kt)("inlineCode",{parentName:"li"},"()"),"; the empty tuple"),(0,s.kt)("li",{parentName:"ul"},"arity one: ",(0,s.kt)("strong",{parentName:"li"},"Not Permitted")),(0,s.kt)("li",{parentName:"ul"},"arity two: ",(0,s.kt)("em",{parentName:"li"},"pairs")),(0,s.kt)("li",{parentName:"ul"},"arity three: ",(0,s.kt)("em",{parentName:"li"},"triples"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},'tp1 = ("Yes", True, \'a\') :: (String, Bool, Char)\ntp2 = (3, "Blue") :: (Int, String)\n\nmain = do\n  print (fst tpl) -- 3\n  print (snd tpl) -- "Blue"\n')),(0,s.kt)("h3",{id:"function-types"},"Function Types"),(0,s.kt)("p",null,"A ",(0,s.kt)("inlineCode",{parentName:"p"},"function")," is mapping from arguments of one type to results of another type."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"add :: (Int, Int) -> Int\nadd (x, y) = x + y\n\nadd (1, 2)  -- 3\n\n\nzeroto :: Int -> [Int]\nzeroto n = [0..n]\n")),(0,s.kt)("h4",{id:"curried-functions"},"Curried Functions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"add' :: Int -> (Int -> Int)\nadd' x y = x + y\n\nadd' 1 2  -- 3\n\n\nmult :: Int -> (Int -> (Int -> Int))\nmult x y z = x * y * z\n")),(0,s.kt)("p",null,"Don't confuse currying and partial application"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Currying: divide a function into functions with only one argument and nest them."),(0,s.kt)("li",{parentName:"ul"},"Partial Application: create a new function by fixing partial arguments of a original function")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- currying\nadd' :: Int -> (Int - > Int)\nadd' x y = x + y\n\nadd' 1 2\n\n-- partial application 1\nadd'' = add' 1\nadd'' 2 -- 3\n\n-- partial application 2\nadd'' y = add (1, y)\nadd'' 2 -- 3\n")),(0,s.kt)("h3",{id:"polymorphic-types"},"Polymorphic Types"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"fst :: (a, b) -> a\nhead :: [a] -> a\ntake :: Int -> [a] -> [a]\nzip :: [a] -> [b] -> [(a, b)]\nid :: a -> a\n")),(0,s.kt)("h4",{id:"type-variable"},"Type Variable"),(0,s.kt)("p",null,"must begin with a lower-case letter"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"length :: [a] -> Int\n")),(0,s.kt)("h3",{id:"overloaded-types"},"Overloaded Types"),(0,s.kt)("p",null,"contains one or more class constraints"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"(+) :: Num a => a -> a -> a\nnegate :: Num a => a -> a\nabs :: Num a => a -> a\n")),(0,s.kt)("h4",{id:"class-constraint"},"Class Constraint"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"-- C: class name\n-- a: type variable (an assined type to `a` is called `instance` of class `C`)\nC a\n")),(0,s.kt)("h2",{id:"classes"},"Classes"),(0,s.kt)("p",null,"A ",(0,s.kt)("em",{parentName:"p"},"class")," is a collection of types that support certain overloaded operatoins; ",(0,s.kt)("em",{parentName:"p"},"methods")," (e.g. ",(0,s.kt)("inlineCode",{parentName:"p"},"(==), (/=)")," in Eq)"),(0,s.kt)("h3",{id:"eq---equality-types"},"Eq - equality types"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"(==) :: a -> a -> Bool\n(/=) :: a -> a -> Bool\n")),(0,s.kt)("p",null,"All the basic types Bool, Char, String, Int, Integer, Float and Double are instances of the Eq class.",(0,s.kt)("br",{parentName:"p"}),"\n","As are list and tuple types, provided that element and component types of the basic types are instances."),(0,s.kt)("h3",{id:"ord---ordered-types"},"Ord - ordered types"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"(<) :: a -> a -> Bool\n(<=) :: a -> a -> Bool\n(>) :: a -> a -> Bool\n(>=) :: a -> a -> Bool\nmin :: a -> a -> a\nmax :: a -> a -> a\n")),(0,s.kt)("h3",{id:"show---showable-types"},"Show - showable types"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"show :: a -> String\n")),(0,s.kt)("h3",{id:"read---readable-types"},"Read - readable types"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"read :: String -> a\n")),(0,s.kt)("h3",{id:"num---numeric-types"},"Num - numeric types"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"(+) :: a -> a -> a\n(-) :: a -> a -> a\n(*) :: a -> a -> a\nnegate :: a -> a\nabs :: a -> a signum :: a -> a\n")),(0,s.kt)("h3",{id:"integral---integral-types"},"Integral - integral types"),(0,s.kt)("p",null,"Types to support the methods of integer division and integer remainder.\n",(0,s.kt)("em",{parentName:"p"},"Int")," and ",(0,s.kt)("em",{parentName:"p"},"Integer")," are ",(0,s.kt)("em",{parentName:"p"},"instances")," of ",(0,s.kt)("em",{parentName:"p"},"Integral"),".  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"div :: a -> a -> a\nmod :: a -> a -> a\n")),(0,s.kt)("h3",{id:"fractional---fractional-types"},"Fractional - fractional types"),(0,s.kt)("p",null,"support the methods of fractional division and fractinal reciprocation"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"(/) :: a -> a -> a\nrecip :: a -> a\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"> 7.0 / 2.0\n3.5\n\n> recip 2.0\n0.5\n")),(0,s.kt)("h2",{id:"definning-functions"},"Definning Functions"),(0,s.kt)("h3",{id:"conditional-expressions"},"Conditional Expressions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"abs :: Int -> Int\nabs n = if n >= 0 then n else -n\n\nsignum :: Int -> Int\nsignum n = if n < 0 then -1 else\n  if n == 0 then 0 else 1\n")),(0,s.kt)("h3",{id:"guarded-equations"},"Guarded Equations"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"abs n\n  | n >= 0 = n\n  | otherwise = - n\n\nsignum n\n  | n < 0 = -1\n  | n == 0 = 0\n  | otherwise = 1\n")),(0,s.kt)("p",null,"The symbol ",(0,s.kt)("inlineCode",{parentName:"p"},"|")," is read as ",(0,s.kt)("em",{parentName:"p"},"such that"),"."),(0,s.kt)("h3",{id:"pattern-matching"},"Pattern matching"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"not :: Bool -> Bool\nnot False = True\nnot True = False\n\n(&&) :: Bool -> Bool -> Bool\nTrue && True = True\n_ && _ = False\n")),(0,s.kt)("h4",{id:"tuple-patterns"},"Tuple Patterns"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"fst :: (a, b) -> a\nfst (x, _) = x\n\nsnd :: (a, b) -> b\nsnd (_, y) = y\n")),(0,s.kt)("h4",{id:"list-patterns"},"List Patterns"),(0,s.kt)("p",null,"matches any list of the same length whose elements all match the corresponding patterns in order.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"test :: [Char] -> Bool\ntest ['a', _, _] = True\ntest _ = False\n")),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"cons")," operator ",(0,s.kt)("inlineCode",{parentName:"p"},":")," prepends a new element to an existing list.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"[1, 2, 3]\n= 1:[2, 3]\n= 1:(2:[3])\n= 1:(2:(3:[]))\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"test :: [Char] -> Bool\ntest ('a':_) = True\ntest _ = False\n\nhead :: [a] -> a\nhead (x:_) = x\n\ntail :: [a] -> [a]\ntail (_:xs) = xs\n")),(0,s.kt)("h3",{id:"lambda-expressions"},"Lambda Expressions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"\\x -> x + x\n\n> (\\x -> x + x) 2\n4\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"add :: Int -> Int -> Int\nadd x y = x + y\nadd = \\x -> (\\y -> x + y)\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"const :: a -> b -> a\nconst x _ = x\nconst x = \\_ -> x\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"odds :: Int -> [Int]\nodds n = map f [0..n-1]\n  where f x = x * 2 + 1\nodds n = map (\\x -> x * 2 + 1) [0..n-1]\n")),(0,s.kt)("h3",{id:"operator-sections"},"Operator Sections"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"operators: functions with two arguments"),(0,s.kt)("li",{parentName:"ul"},"sections: operators formed as ",(0,s.kt)("inlineCode",{parentName:"li"},"(#)"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"(x #)"),", or so")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"(#) = \\x -> (\\y -> x # y)\n(x #) = \\y -> x # y\n(# y) = \\x -> x # y\n")),(0,s.kt)("h2",{id:"list-comprehensions"},"List Comprehensions"),(0,s.kt)("p",null,(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"{"),(0,s.kt)("msup",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msup"},"x"),(0,s.kt)("mn",{parentName:"msup"},"2")),(0,s.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"x"),(0,s.kt)("mo",{parentName:"mrow"},"\u2208"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"{"),(0,s.kt)("mn",{parentName:"mrow"},"1..5"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"}"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"}")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\{x^2 | x \\in \\{ 1 .. 5 \\} \\}")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mopen"},"{"),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,s.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2208"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mopen"},"{"),(0,s.kt)("span",{parentName:"span",className:"mord"},"1..5"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"}}")))))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"xs = [x^2 | x <- [1..5]]  -- [1, 4, 9, 16, 25]\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"|"),": ",(0,s.kt)("em",{parentName:"li"},"such that")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"<-"),": ",(0,s.kt)("em",{parentName:"li"},"drawn from")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"x <- [1..5]"),": ",(0,s.kt)("strong",{parentName:"li"},"generator"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"xs2 = [(x, y) | x <- [1, 2, 3,], y <- [4, 5]]\n-- [(1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]\n\nxs3 = [(x, y) | y <- [4, 5], x <- [1, 2, 3]]\n-- [(1, 4), (2, 4), (3, 4), (1, 5), (2, 5), (3, 5)]\n\nxs4 = [(x, y) | x <- [1..3], y <- [x..3]]\n-- [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"concat :: [[a]] -> [a]\nconcat xss = [x | xs <- xss, x <- xs]\n\nfirsts :: [(a, b)] -> [a]\nfirsts ps = [x | (x, _) <- ps]\n\nlength :: [a] -> Int\nlength xs = sum [1 | _ <- xs]\n\n\nmain = do\n  print (concat [[1, 2, 3], [4, 5, 6]]) -- [1,2,3,4,5,6]\n  print ([1, 2, 3] ++ [4, 5, 6]) -- [1,2,3,4,5,6]\n  print (firsts [(1, 2), (3, 4), (5, 6)]) -- [1, 3, 5]\n  print (length [1, 2, 3]) -- 3\n")),(0,s.kt)("h3",{id:"guard"},"Guard"),(0,s.kt)("p",null,"expressions to filter generated values"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"evens :: Integral a => a -> [a]\nevens n = [x | x <- [0 .. n], even x]\n\nfactors :: Integral a => a -> [a]\nfactors n = [x | x <- [1 .. n], n `mod` x == 0]\n\nprime :: Integral a => a -> Bool\nprime n = factors n == [1, n]\n{- Note:\n  Deciding that a number is prime does not require \n  the `prime` to produce all of its factors, \n  because under lazy evaluation the result `False` is returned \n  as soon as any factor other than one or the number itself is produced.\n  e.g. `prime 15` returns `False` when 3 in its factors `[1, 3, 5, 15]` is produced in `factors`.\n-}\n\nprimes :: Integral a => a -> [a]\nprimes n = [x | x <- [2 .. n], prime x]\n\nfind :: Eq a1 => a1 -> [(a1, a2)] -> [a2]\nfind k t = [v | (k', v) <- t, k == k']\n\nmain = do\n  print (evens 10) -- [0,2,4,6,8,10]\n  print (factors 12) -- [1,2,3,4,6,12]\n  print (prime 15) -- False\n  print (prime 7) -- True\n  print (primes 40) -- [2,3,5,7,11,13,17,19,23,29,31,37]\n  print (find 'b' [('a', 1), ('b', 2), ('c', 3), ('b', 4)]) -- [2, 4]\n")),(0,s.kt)("h3",{id:"zip-function"},"zip function"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"pairs :: [b] -> [(b, b)]\npairs xs = zip xs (tail xs)\n\nsorted :: Ord a => [a] -> Bool\nsorted xs = and [x <= y | (x, y) <- pairs xs]\n\npositions :: (Num a1, Enum a1, Eq a2) => a2 -> [a2] -> [a1]\npositions x xs = [i | (x', i) <- zip xs [0 ..], x == x']\n\nmain = do\n  print (zip ['a', 'b', 'c'] [1, 2, 3, 4]) -- [('a',1),('b',2),('c',3)]\n  print (pairs [1, 2, 3, 4]) -- [(1,2),(2,3),(3,4)]\n  print (sorted [1, 2, 3, 4]) -- True\n  print (sorted [1, 3, 2, 4]) -- False\n  print (positions False [True, False, True, False]) -- [1, 3]\n")),(0,s.kt)("h3",{id:"string-comprehensions"},"String comprehensions"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"String")," is a list of ",(0,s.kt)("em",{parentName:"p"},"Char")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"lowers :: [Char] -> Int\nlowers xs = length [x | x <- xs, x >= 'a' && x <= 'z']\n\ncount :: Eq a => a -> [a] -> Int\ncount x xs = length [x' | x' <- xs, x == x']\n\nmain = do\n  print (\"abcde\" !! 2) -- 'c'\n  print (take 3 \"abcde\") -- \"abc\"\n  print (length \"abcde\") -- 5\n  print (zip \"abc\" [1, 2, 3, 4]) -- [('a',1),('b',2),('c',3)]\n\n  print (lowers \"Haskell\") -- 6\n  print (count 's' \"Mississippi\") -- 4\n")),(0,s.kt)("h2",{id:"recursive-functions"},"Recursive Functions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"fac :: Int -> Int\nfac 0 = 1\nfac n = n * fac (n - 1)\n\n(*) :: Int -> Int -> Int\nm * 0 = 0\nm * n = m + (m * (n - 1))\n")),(0,s.kt)("h3",{id:"recursion-on-lists"},"Recursion on Lists"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"product :: Num a => [a] -> a\nproduct [] = 1\nproduct (n:ns) = n * product ns\n\nlength :: [a] -> Int\nlength [] = 1\nlength (_:xs) = 1 + length xs\n\nreverse :: [a] -> a\nreverse [] = []\nreverse (x:xs) = reverse xs ++ [x]\n\n(++) :: [a] -> [a] -> [a]\n[] ++ ys = ys\n(x:xs) ++ ys = x:(xs ++ ys)\n\ninsert :: Ord a => a -> [a] -> [a]\ninsert x [] = [x]\ninsert x (y:ys)\n  | x <= y = x:y:ys\n  | otherwise = y:insert x ys\n\n-- insertion sort\nisort :: Ord a => [a] -> [a]\nisort [] = []\nisort (x:xs) = insert x (isort xs)\n")),(0,s.kt)("h3",{id:"multiple-arguments"},"Multiple Arguments"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"zip :: [a] -> [a] -> [(a, b)]\nzip [] _ = []\nzip _ [] = []\nzip (x:xs) (y:ys) = (x, y):zip xs ys\n\ndrop :: Int -> [a] -> [a]\ndrop 0 xs = xs\ndrop _ [] = []\ndrop n (x:xs) = drop (n - 1) xs\n")),(0,s.kt)("h3",{id:"multiple-recursion"},"Multiple Recursion"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"fib :: Int -> Int\nfib 0 = 0\nfib 1= 1\nfib n = fib (n - 2) + fib (n - 1)\n\nqsort :: Ord a => [a] -> [a]\nqsort [] = []\nqsort (x:xs) = qsort smaller ++ [x] ++ qsort larger\n  where \n    smaller = [a | a <- xs, a <= x]\n    larger = [b | b <- xs, b > x]\n")),(0,s.kt)("h3",{id:"mutual-recursion"},"Mutual Recursion"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"even :: Int -> Bool\neven 0 = True\neven n = odd (n - 1)\n\nodd :: Int -> Bool\nodd 0 = False\nodd n = even (n - 1)\n\n\nevens :: [a] -> [a]\nevens [] = []\nevens (x:xs) = x:odds xs\n\nodds :: [a] -> [a]\nodds [] = []\nodds (_:xs) = evens xs\n")),(0,s.kt)("h3",{id:"generalizing-and-simplifying"},"Generalizing and Simplifying"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- before\nproduct :: Num a => [a] -> a\nproduct [] = 1\nproduct (n:ns) = n * product ns\n\n-- after\nproduct :: Num a => [a] -> a\nproduct = foldr (*) 1\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- before\ninit :: [a] -> [a]\ninit (x:xs)\n  | null xs = []\n  | otherwise = x:init xs\n\n-- after\ninit :: [a] -> [a]\ninit [_] = []\ninit (x:xs) = x:init xs\n")),(0,s.kt)("h2",{id:"higher-order-functions"},"Higher-Order Functions"),(0,s.kt)("p",null,"Functions that take a function as an argument or return a function as a result"),(0,s.kt)("h3",{id:"processing-lists"},"Processing Lists"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- list conprehension ver.\nmap :: (a -> b) -> [a] -> [b]\nmap f xs = [f x | x <- xs]\n\n-- recursive ver.\nmap :: (a -> b) -> [a] -> [b]\nmap f [] = []\nmap f (x : xs) = f x : map f xs\n\n\n-- list conprehension ver.\nfilter :: (a -> Bool) -> [a] -> [a]\nfilter p xs = [x | x <- xs, p x]\n\n-- recursive ver.\nfilter :: (a -> Bool) -> [a] -> [a]\nfilter p [] = []\nfilter p (x : xs)\n  | p x = x : filter p xs\n  | otherwise = filter p xs\n\n\nmain = do\n  print (all even [2, 4, 6, 8]) -- True\n  print (any odd [2, 4, 6, 8]) -- False\n  print (takeWhile even [2, 4, 6, 7, 8]) -- [2, 4, 6]\n  print (dropWhile odd [1, 3, 5, 6, 7]) -- [6, 7]\n")),(0,s.kt)("h3",{id:"foldr"},"foldr()"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"foldr (#) v [x0, x1, ..., xn] = x0 # (x1 # (... (xn # v)))\n\nf v\n\n-- recursive ver.\nfoldr :: (a -> b -> b) -> b -> [a] -> b\nfoldr f v [] = v\nfoldr f v (x : xs) = f x (foldr f v xs)\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"sum :: Num a => [a] -> a\n-- sum [] = 0\n-- sum (x : xs) = x + sum(xs)\nsum = foldr (+) 0\n\nproduct :: Num a => [a] -> a\nproduct = foldr (*) 1\n\nor :: [Bool] -> Bool\nor = foldr (||) False\n\nand :: [Bool] -> Bool\nand = foldr (&&) True\n\nlength :: [a] -> Int\n-- length [] = 0\n-- length (_:xs) = 1 + length xs\nlength = foldr (\\_ n -> 1 + n) 0\n\n\n-- snoc is `cons` backwards\nsnoc :: a -> [a] -> [a]\nsnoc x xs = xs ++ [x]\n\nreverse :: [a] -> [a]\n-- reverse [] = []\n-- reverse (x : xs) = reverse xs ++ [x]\nreverse :: [a] -> [a]\nreverse = foldr snoc []\n")),(0,s.kt)("h3",{id:"foldl"},"foldl()"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"v")," is ",(0,s.kt)("em",{parentName:"p"},"accumlator"),".  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"foldl (#) v [x0, x1, ..., xn] = (((v # x0) # x1)...) # xn\n\n-- recursive ver.\nfoldl :: (a -> b -> a) -> a -> [b] -> a\nfoldl f v [] = v\nfold f v (x : xs) = foldl f (v + x) xs\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"sum' :: Num a => [a] -> a\nsum' = sum'' 0\n  where\n    sum'' v [] = v\n    sum'' v (x : xs) = sum'' (v + x) xs\n\nsum :: Num a => [a] -> a\nsum = foldl (+) 0\n\nproduct :: Num a => [a] -> a\nproduct = foldl (*) 1\n\nor :: [Bool] -> Bool\nor = foldl (||) False\n\nand :: [Bool] -> Bool\nand = foldr (&&) True\n\nlength :: [a] -> Int\nlength = foldl (\\n _ -> n + 1) 0\n\nreverse :: [a] -> [a]\nreverse = foldl (\\xs x -> x : xs) []\n")),(0,s.kt)("h3",{id:"composition-operator"},"Composition Operator"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"f . g")," is read as ",(0,s.kt)("em",{parentName:"p"},"f composed with g")," .  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"(.) :: (b -> c) -> (a -> b) -> (a -> c)\nf . g = \\x -> f (g x)\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- odd n = not (even n)\nodd = not . even\n\n-- twice f x = f (f x)\ntwice = f . f\n\n-- sumsqreven ns = sum (map (^2) (filter even ns))\nsumsqreven = sum . map (^2) . filter even\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- identity function; id.f = f, f.id = f\nid :: a -> a\nid = \\x -> x\n\ncompose :: [a -> a] -> (a -> a)\ncompose = foldr (.) id  -- make the composition of a list of functions\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- produces an infinite list\niterate f x = [x, f x, f(f x), f(f(f x)), ...]\n\niterate (*2) 1  -- [1, 2, 4, 8, ...]\n\n\n-- repeat :: a -> [a]: procudes an infinite list of copies of a value\nrepeat 0  -- [0, 0, 0, 0, ...]\ntake 8 (repeat 0) -- [0, 0, 0, 0, 0, 0, 0, 0] -- lazy evaluation\n")),(0,s.kt)("h2",{id:"type-declarations"},"Type Declarations"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"type String = [Char]\n\ntype Pos = (Int, Int)\ntype Trans = Pos -> Pos\n\ntype Pair a = (a, a)\ntype Assoc k v = [(k, v)]\n\nfind :: Eq k => k -> Assoc k v -> v\nfind k t = head [v | (k', v) <- t, k == k']\n")),(0,s.kt)("h2",{id:"data-declarations"},"Data Declarations"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"|")," is read as ",(0,s.kt)("em",{parentName:"li"},"or"),".  "),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"constructors")," new values of the type (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"False")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"True")," are constructors of ",(0,s.kt)("em",{parentName:"li"},"Bool"),")")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"data Bool = False | True\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"data Move = North | South | East | West\n\nmove :: Move -> Pos -> Pos\nmove North (x, y) = (x, y + 1)\nmove South (x, y) = (x, y - 1)\nmove East (x, y) = (x + 1, y)\nmove West (x, y) = (x - 1, y)\n\nmoves :: [Move] -> Pos -> Pos\nmoves [] p = p\nmoves (m : ms) p = moves ms (move m p)\n")),(0,s.kt)("h3",{id:"cosntructor-functions"},"Cosntructor Functions"),(0,s.kt)("h4",{id:"vs-normal-functions"},"vs. normal functions"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"have no defining equations and exist as data"),(0,s.kt)("li",{parentName:"ul"},"e.g. ",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"negate 1.0")," can be evaluated to -1.0 by definition of negate"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"Circle 1.0")," is already fully evaluated and cannot be further simplified")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- Circle :: Float -> Shape\n-- Rect :: Float -> Float -> Shape\ndata Shape = Circle Float | Rect Float Float\n\nsquare :: Float -> Shape\nsquare n = Rect n n\n\narea :: Shape -> Float\narea (Circle r) = pi * r ^ 2\narea (Rect x y) = x * y\n")),(0,s.kt)("p",null,"type as a argument"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"data Maybe a = Nothing | Just a\n\nsafediv :: Int -> Int -> Maybe Int\nsafediv _ 0 = Nothing\nsafediv m n = Just (m `div` n)\n\nsafehead :: [a] -> Maybe a\nsafehead [] = Nothing\nsafehead xs = Just (head xs)\n")),(0,s.kt)("h3",{id:"newtype-declarations"},"Newtype Declarations"),(0,s.kt)("p",null,"newtype declarations are to improve type safety without affecting perfomance.",(0,s.kt)("br",{parentName:"p"}),"\n","it must have ",(0,s.kt)("em",{parentName:"p"},"Constructor")," such as ",(0,s.kt)("inlineCode",{parentName:"p"},"N")," in below example.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"newtype Nat = N Int\n\ntype Nat = Int\ndata Nat = N Int\n")),(0,s.kt)("h4",{id:"vs-type"},"vs. type"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Using newtype rather than type means that ",(0,s.kt)("inlineCode",{parentName:"li"},"Nat")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"Int")," are different types rather than synonyms"),(0,s.kt)("li",{parentName:"ul"},"The type system of Haskell ensures that they cannot accidentally be mixed up in programs")),(0,s.kt)("h4",{id:"vs-data"},"vs. data"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Using newtype rather than data brings an efficiency benefit"),(0,s.kt)("li",{parentName:"ul"},"newtype constructors such as ",(0,s.kt)("inlineCode",{parentName:"li"},"N")," do not incur any cost when programs are evaluated, as they are automatically removed by the compiler once type checking is completed")),(0,s.kt)("h3",{id:"recursive-types"},"Recursive Types"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"data Nat = Zero | Succ Nat\n\nnat2int :: Nat -> Int\nnat2int Zero = 0\nnat2int (Succ n) = 1 + nat2int n\n\nint2nat :: Int -> Nat\nint2nat 0 = Zero\nint2nat n = Succ (int2nat (n - 1))\n\nadd :: Nat -> Nat -> Nat\nadd m n = int2nat (nat2int m + nat2int n)\n\nadd' :: Nat -> Nat -> Nat\nadd' Zero n = n\nadd' (Succ m) n = Succ (add' m n)\n\n\n{- e.g. 2 + 1\n    add (Succ (Succ Zero)) (Succ Zero)\n  = (Succ add (Succ Zero) (Succ Zero))\n  = Succ (Succ (add Zero (Succ Zero)))\n  = Succ (Succ (Succ Zero))\n-}\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"data Tree a = Leaf a | Node (Tree a) a (Tree a)\n\nt :: Tree Int\nt = Node (Node (Leaf 1) 3 (Leaf 4)) 5 (Node (Leaf 6) 7 (Leaf 9))\n\nflatten :: Tree a -> [a]\nflatten (Leaf x) = [x]\nflatten (Node l x r) = flatten l ++ [x] ++ flatten r\n\noccurs :: Eq a => a -> Tree a -> Bool\noccurs x (Leaf y) = x == y\noccurs x (Node l y r) = x == y || occurs x l || occurs x r\n\noccurs' :: Ord a => a -> Tree a -> Bool\noccurs' x (Leaf y) = x == y\noccurs' x (Node l y r)\n  | x == y = True\n  | x < y = occurs' x l\n  | otherwise = occurs' x r\n")),(0,s.kt)("h2",{id:"class-and-instance-declarations"},"Class and Instance Declarations"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"type ",(0,s.kt)("inlineCode",{parentName:"li"},"a")," is an instance of the class ",(0,s.kt)("inlineCode",{parentName:"li"},"Eq")),(0,s.kt)("li",{parentName:"ul"},"types of instance must support functions; ",(0,s.kt)("inlineCode",{parentName:"li"},"(==)"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"(/=)")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"(/=)")," is defined as ",(0,s.kt)("em",{parentName:"li"},"default definition"),", so declaring an instance only requires a definition of ",(0,s.kt)("inlineCode",{parentName:"li"},"(==)"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"class Eq a where\n  (==), (/=) :: a -> a -> Bool\n  x /= y = not (x == y)\n\ninstance Eq Bool where\n  False == False = True\n  True == True = True\n  _ == _ = False\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"type ",(0,s.kt)("inlineCode",{parentName:"li"},"a")," to be instance of class ",(0,s.kt)("inlineCode",{parentName:"li"},"Ord")," must be an instance of class ",(0,s.kt)("inlineCode",{parentName:"li"},"Eq"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"class Eq a => Ord a where\n  (<), (<=), (>), (>=) :: a -> a -> Bool\n  min, max :: a -> a -> a\n  min x y\n    | x <= y = x\n    | otherwise = y\n  max x y\n    | x <= y = y\n    | otherwise = x\n\ninstance Ord Bool where\n  False < True = True\n  _ < _ = False\n\n  b <= c = (b < c) || (b == c)\n  b > c = c < b\n  b >= c = c <= b\n")),(0,s.kt)("h2",{id:"derived-instances"},"Derived Instances"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"data Bool = False | True  -- this order is reflected on False < True\n  deriving (Eq, Ord, Show, Read)\n")),(0,s.kt)("h2",{id:"interactive-programming"},"Interactive Programming"),(0,s.kt)("p",null,"Interactive programs has side effects such as additional inputs and outputs while the program is running.  "),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"interactive_program",src:a(6458).Z,width:"455",height:"246"})),(0,s.kt)("p",null,"Haskell treats an interactive program as a pure function that takes the current ",(0,s.kt)("em",{parentName:"p"},"state of world")," as its arguments, and produces a modified world as its result  "),(0,s.kt)("p",null,"Expressions of type IO a are called ",(0,s.kt)("em",{parentName:"p"},"actions"),"  "),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"type IO Char: type of actions that return a character"),(0,s.kt)("li",{parentName:"ul"},"type IO (): type of actions that return the empty tuple ",(0,s.kt)("inlineCode",{parentName:"li"},"()")," as a dummy result value")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"type IO = World -> World\n\ntype IO a = World -> (a, World)\n\ntype Char -> IO Int -- means type Char -> World -> (Int, World)\n")),(0,s.kt)("h3",{id:"basic-actions"},"Basic Actions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"getChar :: IO Char\n\nputChar :: Char -> IO ()\n\nreturn :: a -> IO a\n")),(0,s.kt)("h3",{id:"sequencing"},"Sequencing"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"<-")," is called ",(0,s.kt)("em",{parentName:"li"},"generator")," as with list comprehensions",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"if a value generated by ",(0,s.kt)("inlineCode",{parentName:"li"},"ai")," is unnecessary, generator is abbreviated by ",(0,s.kt)("inlineCode",{parentName:"li"},"ai")," which means ",(0,s.kt)("inlineCode",{parentName:"li"},"_ <- ai"))))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"do v1 <- a1\n   v2 <- a2\n   ...\n   vn <- an\n   return (f v1 v2 ... vn)\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"act :: IO (Char, Char)\nact = do x <- getChar\n         getChar\n         y <- getChar\n         return (x, y)\n")),(0,s.kt)("h3",{id:"derived-primitives"},"Derived primitives"),(0,s.kt)("p",null,"action primitives in the standard prelude"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"getLine: read chars until ",(0,s.kt)("inlineCode",{parentName:"li"},"\\n")),(0,s.kt)("li",{parentName:"ul"},"putStr: without ",(0,s.kt)("inlineCode",{parentName:"li"},"\\n")),(0,s.kt)("li",{parentName:"ul"},"putStrLn: with ",(0,s.kt)("inlineCode",{parentName:"li"},"\\n"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"getLine :: IO String\ngetLine = do x <- getChar\n             if x == '\\n' then\n                return []\n             else\n                do xs <- getLine\n                   return (x : xs)\n\n\nputStr :: String -> IO ()\nputStr [] = return ()\nputStr (x : xs) = do putChar x\n                     putCStr xs\n\n\nputStrLn :: String -> IO ()\nputStrLn xs = do putStr xs\n                 putChar '\\n'\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},'strlen :: IO ()\nstrlen = do putStr "Enter a string: "\n            xs <- getLine\n            putStr "The string has "\n            putStr (show (length xs))\n            putStrLn " characters"\n')),(0,s.kt)("h2",{id:"functors"},"Functors"),(0,s.kt)("p",null,"class of types that support a mapping function."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"class Functor f where\n  fmap :: (a -> b) -> f a -> f b\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"fmap")," takes a function of type ",(0,s.kt)("inlineCode",{parentName:"li"},"a -> b")," and a structure of type ",(0,s.kt)("inlineCode",{parentName:"li"},"f a")," whose elements have type ",(0,s.kt)("inlineCode",{parentName:"li"},"a")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"fmap")," applies the function to each element to give a structure of type ",(0,s.kt)("inlineCode",{parentName:"li"},"f b")," whose elements have type ",(0,s.kt)("inlineCode",{parentName:"li"},"b"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"instance Functor [] where\n  -- fmap :: (a -> b) -> [a] -> [b]\n  fmap = map\n\n\ninstance Functor Maybe where\n  -- fmap :: (a -> b) -> Maybe a -> Maybe b\n  fmap _ Nothing = Nothing\n  fmap g (Just x) = Just (g x)\n\nfmap (+1) Nothing     -- Nothing\nfmap (*2) (Just 3)    -- Just 6\nfmap not (Just False) -- Just True\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},'data Tree a = Leaf | Node (Tree a) (Tree a)\n  deriving Show\n\ninstance Functor Tree where\n  -- fmap :: (a -> b) -> Tree a -> Tree b\n  fmap g (Leaf x) = Leaf (g x)\n  fmap g (Node l r) = Node (fmap g l) (fmap g r)\n\nfmap length (Leaf "abc")  -- Leaf 3\nfmap even (Node (Leaf 1) (Leaf 2))  -- Node (Leaf False) (Leaf True)\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},'instance Functor IO where\n  -- fmap :: (a -> b) -> IO a -> IO b\n  fmap g mx = do {x <- mx; return (g x)}\n\nfmap show (return True) -- "True"\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"inc :: [Int] -> [Int]\ninc = map (+ 1)\n\ninc' :: Functor f => f Int -> f Int\ninc' = fmap (+ 1)\n\ninc' (Just 1) -- Just 2\ninc' [1, 2, 3, 4, 5]  -- [2, 3, 4, 5, 6]\ninc' (Node (Leaf 1) (Leaf 2)) -- Node (Leaf 2) (Leaf 3)\n")),(0,s.kt)("h3",{id:"functor-laws"},"Functor Laws"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"fmap id = id\nfmap (g . h) = fmap g . fmap h\n")),(0,s.kt)("h2",{id:"applicatives"},"Applicatives"),(0,s.kt)("h3",{id:"applicative-functors-applicative"},"applicative functors; applicative"),(0,s.kt)("p",null,"the class of functors that support ",(0,s.kt)("inlineCode",{parentName:"p"},"pure")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"<*>")," functions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"class Functor f => Applicative f where\n  pure :: a -> f a\n  (<*>) :: f (a -> b) -> f a -> f b\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"pure :: a -> f a\n(<*>) :: f (a -> b) -> f a -> f b\n\nfmap0 :: a -> f a\nfmap0 = pure\n\nfmap1 :: (a -> b) -> f a -> f b\nfmap1 = pure g <*> x\n\nfmap2 :: (a -> b -> c) -> f a -> f b -> f c\nfmap2 = pure g <*> x <*> y\n\nfmap3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d\nfmap3 = pure g <*> x <*> y <*> z\n\n...\n\n\n-- type check. fmap2\n-- f (a -> b -> c) -> f a -> f (b -> c)\n--     pure g     <*>  x  =      x'\n\n-- f (b -> c) -> f b -> f c\n--      x'   <*> y  =  res\n")),(0,s.kt)("p",null,"The applicative style for ",(0,s.kt)("em",{parentName:"p"},"Maybe")," supports a form of ",(0,s.kt)("em",{parentName:"p"},"exceptional")," programming in which we can apply pure functions to arguments that may fail without the need to manage the propagation of failure ourselves.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"instance Applicative Maybe where\n  -- pure :: a -> Maybe a\n  pure = Just\n\n  -- (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b\n  Nothing <*> _ = Nothing\n  (Just g) <*> mx = fmap g mx\n\npure (+ 1) <*> Just 1           -- Just 2\npure (+) <*> Just 1 <*> Just 2  -- Just 3\npure (+) <*> Nothing <*> Just 2 -- Nothing\n")),(0,s.kt)("p",null,"The applicative sytle for lists supports a form of ",(0,s.kt)("em",{parentName:"p"},"non-deteministic")," programming in which we can apply pure functions to multi-valued arguments without the need to manage the selection of values or the propagation of failure.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"instance Applicative [] where\n  -- pure :: a -> [a]\n  pure x = [x]\n\n  -- (<*>) :: [a -> b] -> [a] -> [b]\n  gs <*> xs = [g x | g <- gs, x <- xs]\n\npure (+ 1) <*> [1, 2, 3]        -- [2, 3, 4]\npure (+) <*> [1] <*> [2]        -- [3]\npure (*) <*> [1, 2] <*> [3, 4]  -- [3, 4, 6, 8]\n\nprods :: [Int] -> [Int] -> [Int]\nprods xs ys = [x * y | x <- xs, y <- ys]\n\nprods' :: [Int] -> [Int] -> [Int]\nprods' xs ys = pure (*) <*> xs <*> ys\n")),(0,s.kt)("p",null,"The applicative style for IO supports a form of ",(0,s.kt)("em",{parentName:"p"},"interactive")," programming in which we can apply pure functions to impure arguments without the need to manage the sequencing of actions or the extranction of result values.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"instance Applicative IO where\n  -- pure :: a -> IO a\n  pure = return\n\n  -- (<*>) :: IO (a -> b) -> IO a -> IO b\n  mb <*> mx = do {g <- mg; x <- mx; return (g x)}\n\ngetChars :: Int -> IO String\ngetChars 0 = return []\ngetChars n = pure (:) <*> getChar <*> getChars (n - 1)\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"sequenceA :: Applicative f => [f a] -> f [a]\nsequenceA [] = pure []\nsequenceA (x : xs) = pure (:) <*> x <*> sequecneA xs\n\ngetChars :: Int -> IO String\ngetChars n = sequenceA (replicate n getChar)\n")),(0,s.kt)("h3",{id:"applicative-laws"},"Applicative Laws"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"pure id <*> x = x -- pure is complemented\npure (g x) = pure g <*> pure x  -- occurences of pure can be combined into one\nx <*> pure y = pure (\\g -> g y) <*> x -- the order in which we evaluate the two components doesn't matter\nx <*> (y <*> z) = (pure (.) <*> x <*> y) <*> z  -- <*> is associative\n")),(0,s.kt)("p",null,"these laws ensure that below expression is evaluated  uniquely.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"pure g <*> x1 <*> x2 <*> ... <*> xn\n")),(0,s.kt)("h3",{id:"infix-ver"},"Infix ver."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"fmap g x = pure g <*> x\ng <$> x = fmap g x\n\ng <$> x1 <*> x2 <*> ... <*> xn\n")),(0,s.kt)("h2",{id:"monads"},"Monads"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"class Applicative m => Monad m where\n  return :: a -> m a\n  (>>=) :: m a -> (a -> m b) -> m b\n\n  return = pure\n")),(0,s.kt)("h3",{id:"-operator"},(0,s.kt)("inlineCode",{parentName:"h3"},">>=")," operator"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"called ",(0,s.kt)("em",{parentName:"li"},"bind"),".  "),(0,s.kt)("li",{parentName:"ul"},"ensures that such an expression only succeeds if every component ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"m"),(0,s.kt)("mi",{parentName:"msub"},"i"))),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"m_i")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"m"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3117em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"i")))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"}))))))))))," in the sequence succeeds")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\nmx >>= f = case mx of\n  Nothing -> Nothing\n  Just x -> f x\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- Notation 1\nm1 >>= \\x1 ->\nm2 >>= \\x2 ->\n...\nmn >>= \\xn ->\nf x1 x2 ... xn\n\n-- Notation 2\ndo x1 <- m1\n   x2 <- m2\n   ...\n   xn <- mn\n   f x1 x2 ... xn\n")),(0,s.kt)("h3",{id:"monad-laws"},"Monad Laws"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"return x >>= f = f x  -- (return x) >>= f = f x\nmx >>= return = mx\n(mx >>= f) >>= g = mx >>= (\\x -> (f x >>= g)) -- assosiatative\n")),(0,s.kt)("h3",{id:"usecases"},"Usecases"),(0,s.kt)("p",null,"applicative style does not fit the pattern of effectful programming such as the function which is the first argument of ",(0,s.kt)("inlineCode",{parentName:"p"},"<*>")," is not pure function.  "),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"safediv")," is not a pure function because it returns ",(0,s.kt)("inlineCode",{parentName:"li"},"Maybe Int"),", not ",(0,s.kt)("inlineCode",{parentName:"li"},"Int"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"data Expr = Val Int | Div Expr Expr\n\neval :: Expr -> Int\neval (Val n) = n\neval (Div x y) = eval x `div` eval y\n\neval (Div (Val 1) (Val 0))  -- *** Exception: divide by zero\n\n\nsafediv :: Int -> Int -> Maybe Int\nsafediv _ 0 = Nothing\nsafediv n m = Just (n `div` m)\n\neval' :: Expr -> Maybe Int\neval' (Val n) = Just n\neval' (Div x y) = case eval x of\n  Nothing -> Nothing\n  Just n -> case eval y of\n    Nothing -> Nothing\n    Just m -> safediv n m\n\neval' (Div (Val 1) (Val 0)) -- Nothing\n\n\neval' :: Expr -> Maybe Int\neval' (Val n) = pure n\neval' (Div x y) = pure safediv <*> eval x <*> eval y  -- type error\n")),(0,s.kt)("p",null,"apply ",(0,s.kt)("em",{parentName:"p"},"monad")," then"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"instance Monad Maybe where\n  -- (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\n  Nothing >>= _ = Nothing\n  (Just x) >>= f = f x\n\ndata Expr = Val Int | Div Expr Expr\n\nsafediv :: Int -> Int -> Maybe Int\nsafediv _ 0 = Nothing\nsafediv n m = Just (n `div` m)\n\n-- Notation 1\neval :: Expr -> Maybe Int\neval (Val n) = Just n\neval (Div x y) =\n  eval x >>= \\n ->\n    eval y >>= \\m ->\n      safediv n m\n\n-- Notation 2\neval' :: Expr -> Maybe Int\neval' (Val n) = Just n\neval' (Div x y) = do\n  n <- eval' x\n  m <- eval' y\n  safediv n m  \n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"instance Monad [] where\n  -- (>>=) :: [a] -> (a -> [b]) -> [b]\n  xs >>= f = [y | x <- xs, y <- f x]\n\npairs :: [a] -> [b] -> [(a, b)]\npairs xs ys =\n  xs >>= \\x ->\n    ys >>= \\y ->\n      return (x, y)\n\npairs :: [a] -> [b] -> [(a, b)]\npairs xs ys = do\n  x <- xs\n  y <- ys\n  return (x, y)\n")),(0,s.kt)("h3",{id:"the-state-monad"},"The State Monad"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"type State = Int  -- state is just an integer value but this can be modified as required\n")),(0,s.kt)("h4",{id:"state-tronsformer-st"},(0,s.kt)("em",{parentName:"h4"},"state tronsformer"),"; ",(0,s.kt)("em",{parentName:"h4"},"ST")),(0,s.kt)("p",null,"takes an input state as its argument and produces an ouptut state as its result"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"type ST = State -> State\ntype ST a = State -> (a, State) -- returns State with an output of type `a`\ntype a -> ST b -- type a -> State -> (b, State)\n-- takes State with an input of type `a` and returns State with an output of type `b`\n")),(0,s.kt)("p",null,"we want to make ",(0,s.kt)("em",{parentName:"p"},"ST")," into a monad but types declared using the type mechanism cannot be made into instances of classes.",(0,s.kt)("br",{parentName:"p"}),"\n","so we need to define it using ",(0,s.kt)("em",{parentName:"p"},"newtype"),".  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"newtype ST a = S (State -> (a, State))\n\n-- removes dummy constructor `S`\napp :: ST a -> State -> (a, State)\napp (S st) x = st x\n\n\ninstance Functor ST where\n  -- fmap :: (a -> b) -> ST a -> ST b\n  fmap g st = S (\\s -> let (x, s') = app st s in (g x, s'))\n\ninstance Applicative ST where\n  -- pure :: a -> ST a\n  pure x = S (\\s -> (x, s))\n\n  -- (<*>) :: ST (a -> b) -> ST a -> ST b\n  stf <*> stx =\n    S\n      ( \\s ->\n          let (f, s') = app stf s\n              (x, s'') = app stx s'\n           in (f x, s'')\n      )\n\ninstance Monad ST where\n  -- (>>=) :: ST a -> (a -> ST b) -> ST b\n  st >>= f = S (\\s -> let (x, s') = app st s in app (f x) s')\n")),(0,s.kt)("h3",{id:"generic-functions"},"Generic Functions"),(0,s.kt)("h4",{id:"mapm"},"mapM()"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- defined in Control.Monad\nmapM :: Monad m => (a -> m b) -> [a] -> m [b]\nmapM f [] = return []\nmapM f (x : xs) = do\n  y <- f x\n  ys <- mapM f xs\n  return (y : ys)\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},'import Data.Char\n\nconv :: Char -> Maybe Int\nconv c\n  | isDigit c = Just (digitToInt c)\n  | otherwise = Nothing\n\nmapM conv "1234"  -- Just [1, 2, 3, 4]\nmapM conv "123a"  -- Nothing\n')),(0,s.kt)("h4",{id:"filterm"},"filterM()"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- defined in Control.Monad\nfilterM :: Monad m => (a -> m Bool) -> [a] -> m [a]\nfilterM p [] = return []\nfilterM p (x : xs) = do\n  b <- p x\n  ys <- filter M p xs\n  return (if b then x : ys else ys)\n\nfilterM (\\x -> [True, False]) [1, 2, 3]\n-- [[1, 2, 3], [1, 2], [1, 3], [1], [2, 3], [2], [3], []]\n")),(0,s.kt)("h4",{id:"join"},"join()"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"join :: Monad m => m (m a) -> m a\njoin mmx = do\n  mx <- mmx\n  x <- mx\n  return x\n\njoin [[1, 2], [3, 4], [5, 6]] -- [1, 2, 3, 4, 5, 6]\njoin (Just (Just 1))  -- Just 1\njoin (Just Nothing) -- Nothing\njoin Nothing  -- Nothing\n")),(0,s.kt)("h2",{id:"alternative"},"Alternative"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"class Applicative f => Alternative f where\n  empty :: f a\n  (<|>) :: f a -> f a -> f a\n")),(0,s.kt)("h3",{id:"alternative-laws"},"Alternative Laws"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"empty <|> x = x\nx <|> empty = x\nx <|> (x <|> y) = (x <|> y) <|> z -- associative\n")),(0,s.kt)("h3",{id:"alternative-instances"},"Alternative Instances"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"instance Alternative Maybe where\n  -- empty :: Maybe a\n  empty = Nothing\n\n  -- (<|>) :: Maybe a -> Maybe a -> Maybe a\n  Nothing <|> my = my\n  (Just x) <|> _ = Just x\n")),(0,s.kt)("h2",{id:"monoids"},"Monoids"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"class Monoids a where\n  mempty :: a\n  mappend :: a -> a -> a\n\n  mconcat :: [a] -> a\n  mconcat = foldr mappend mempty\n")),(0,s.kt)("h3",{id:"monoid-laws"},"Monoid Laws"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"mempty `mappend` x = x\nx `mappend` mempty = x\nx `mappend` (y `mappend` z) = (x `mappend` y) `mappend` z\n\n-- using <> operator\nmempty <> x = x\nx <> mempty = x\nx <> (y <> z) = (x <> y) <> z\n")),(0,s.kt)("h3",{id:"datamonoid"},"Data.Monoid"),(0,s.kt)("h4",{id:"lists"},"Lists"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"instance Monoid [a] where\n  -- mempty :: [a]\n  mempty = []\n\n  -- (<>) :: [a] -> [a] -> [a]\n  mappend = (++)\n")),(0,s.kt)("h4",{id:"maybe"},"Maybe"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"instance Monoid a => Monoid (Maybe a) where\n  -- mempty :: Maybe a\n  mempty = Nothing\n\n  -- (<>) :: Maybe a -> Maybe a -> Maybe a\n  Nothing <> my = my\n  mx <> Nothing = mx\n  Just x <> Just y = Just (x <> y)\n")),(0,s.kt)("h4",{id:"sum"},"Sum"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"newtype Sum a = Sum a\n  deriving (Eq, Ord, Show, Read)\n\ngetSum :: Sum a -> a\ngetSum (Sum x) = x\n\n\ninstance Num a => Monoid (Sum a) where\n  -- mempty :: Sum a\n  mempty = Sum 0\n\n  -- (<>) :: Sum a -> Sum a -> Sum a\n  Sum x <> Sum y = Sum (x + y)\n\n\nmconcat [Sum 2, Sum 3, Sum 4] -- Sum 9\n")),(0,s.kt)("h4",{id:"product"},"Product"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"newtype Product a = Product a\n  deriving (Eq, Ord, Show, Read)\n\ngetProduct :: Product a -> a\ngetProduct (Product x) = x\n\n\ninstance Num a => Monoid (Product a) where\n  -- mempty :: Product a\n  mempty = Product 1\n\n  -- (<>) :: Product a -> Product a -> Product a\n  Product x <> Product y = Product (x * y)\n\n\nmconcat [Product 2, Product 3, Product 4] -- Product 24\n")),(0,s.kt)("h4",{id:"all"},"All"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"mconcat [All True, All True, All True]  -- All True\n")),(0,s.kt)("h4",{id:"any"},"Any"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"mconcat [Any False, Any False, Any False] -- Any False\n")),(0,s.kt)("h2",{id:"foldables"},"Foldables"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Note:"),(0,s.kt)("br",{parentName:"p"}),"\n","minimal complete definition for an instance of the ",(0,s.kt)("em",{parentName:"p"},"Foldable")," class is to define either ",(0,s.kt)("em",{parentName:"p"},"foldMap")," or ",(0,s.kt)("em",{parentName:"p"},"foldr"),"  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"class Foldable t where\n  fold :: Monoid a => t a -> a\n  foldMap :: Monoid b => (a -> b) -> t a -> b\n  foldr :: (a -> b -> b) -> b -> t a -> b\n  foldl :: (a -> b -> a) -> a -> t b -> a\n\n  null :: t a -> Bool\n  length :: t a -> Int\n  elem :: Eq a => a -> t a -> Bool\n  maximum :: Ord a => t a -> a\n  minimum :: Ord a => t a -> a\n  sum :: Num a => t a -> a\n  product :: Num a => t a -> a\n\n  foldr1 :: (a -> a -> a) -> t a -> a\n  foldl1 :: (a -> a -> a) -> t a -> a\n\n  toList :: t a -> [a]\n\n  -- default definitions\n  null = null . toList\n  length = length . toList\n  elem x = elem x . toList\n  maximum = maximum . toList\n  minimum = minimum . toList\n  sum = sum . toList\n  product = product . toList\n\n  foldr f v = foldr f v . toList\n  foldl r v = foldl f v . toList\n  foldr1 f = fold1 f . toList\n  foldl1 f = fold1 f . toList\n\n  fold = foldMap id\n  foldMap f = foldr (mappend . f) mempty\n  toList = foldMap (\\x -> [x])\n")),(0,s.kt)("h3",{id:"list"},"List"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"instance Foldable [] where\n  -- fold :: Monoid a => [a] -> a\n  fold [] = mempty\n  fold (x : xs) = x <> fold xs\n\n  -- foldMap :: Monoid b => (a -> b) -> [a] -> b\n  foldMap _ [] = mempty\n  foldMap f (x : xs) = f x <> foldMap f xs\n\n  -- foldr :: (a -> b -> b) -> b -> [a] -> b\n  foldr _ v [] = v\n  foldr f v (x : xs) = f x (foldr f v xs)\n\n  -- foldl :: (a -> b -> a) -> a -> [b] -> a\n  foldl _ v [] = v\n  foldl f v (x : xs) = foldl f (f v x) xs\n\n\ngetSum (foldMap Sum [1..10])  -- 55\ngetProduct (foldMap Product [1..10])  -- 3628800\n")),(0,s.kt)("h3",{id:"tree"},"Tree"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"data Tree a = Leaf a | Node (Tree a) (Tree a)\n  deriving (Show)\n\ninstance Foldable Tree where\n  -- fold :: Monoid a => Tree a -> a\n  fold (Leaf x) = x\n  fold (Node l r) = fold l <> fold r\n\n  -- foldMap :: Monoid b => (a -> b) -> Tree a -> b\n  foldMap f (Leaf x) = f x\n  foldMap f (Node l r) = foldMap f l <> foldMap f r\n\n  -- foldr :: (a -> b -> b) -> b -> Tree a -> b\n  foldr f v (Leaf x) = f x v\n  foldr f v (Node l r) = foldr f (foldr f v r) l\n\n  -- foldl :: (a -> b -> a) -> a -> Tree b -> a\n  foldl f v (Leaf x) = f v x\n  foldl f v (Node l r) = foldl f (foldl f v l) r\n\n\ntree :: Tree Int\ntree = Node (Node (Leaf 1) (Leaf 2)) (Leaf 3)\n\nfoldr (+) 0 -- 1 + (2 + (3 + 0))\nfoldl (+) 0 -- ((0 + 1) + 2) + 3\nfoldl (+) (Node (Leaf 1) (Leaf 2))  -- 3\ntoList (Node (Leaf 1) (Leaf 2)) -- [1,2]\n")),(0,s.kt)("h3",{id:"generic-functions-1"},"Generic Functions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"import Data.Foldable\n\ndata Tree a = Leaf a | Node (Tree a) (Tree a)\n  deriving (Show)\n\ninstance Foldable Tree where\n  -- foldMap :: Monoid b => (a -> b) -> Tree a -> b\n  foldMap f (Leaf x) = f x\n  foldMap f (Node l r) = foldMap f l <> foldMap f r\n\naverage :: [Int] -> Int\naverage ns = sum ns `div` length ns\n\naverage' :: Foldable t => t Int -> Int\naverage' ns = sum ns `div` length ns\n\nmain = do\n  print (average' [1 .. 10])  -- 5\n  print (average' (Node (Leaf 1) (Leaf 3))) -- 2\n")),(0,s.kt)("h4",{id:"and"},"and()"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"and :: Foldable t => t Bool -> Bool\nand = getAll . foldMap All\n\nmain = do\n  print (and [True, False, True]) -- False\n")),(0,s.kt)("h4",{id:"or"},"or()"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"or :: Foldable t => t Bool -> Bool\nor = getAny . foldMap Any\n\nmain = do\n  print (or (Node (Leaf True) (Leaf False)))  -- True\n")),(0,s.kt)("h4",{id:"all-1"},"all()"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"all :: Foldable t => (a -> Bool) -> t a -> Bool\nall p = getAll . foldMap (All . p)\n\nmain = do\n  print (all even [1, 2, 3])  -- False\n")),(0,s.kt)("h4",{id:"any-1"},"any()"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"any :: Foldable t => (a -> Bool) -> t a -> Bool\nany p = getAny . foldMap (Any . p)\n\nmain = do\n  print (any even (Node (Leaf 1) (Leaf 2))) -- True\n")),(0,s.kt)("h4",{id:"concat"},"concat()"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},'concat :: Foldable t => t [a] -> [a]\nconcat = fold\n\nmain = do\n  print (concat ["ab", "cd", "ef"]) -- "abcdef"\n  print (concat (Node (Leaf [1, 2]) (Leaf [3])))  -- [1,2,3]\n')),(0,s.kt)("h2",{id:"traversable"},"Traversable"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Note:"),(0,s.kt)("br",{parentName:"p"}),"\n","A definition of either ",(0,s.kt)("em",{parentName:"p"},"traverse")," or ",(0,s.kt)("em",{parentName:"p"},"sequenceA")," is needed but ",(0,s.kt)("em",{parentName:"p"},"traverse")," is prefarable rather than ",(0,s.kt)("em",{parentName:"p"},"sequenceA")," because default ",(0,s.kt)("em",{parentName:"p"},"traverse")," definition is unefficient due to passing through the data structure twice, when ",(0,s.kt)("em",{parentName:"p"},"fmap")," and ",(0,s.kt)("em",{parentName:"p"},"sequenceA"),".  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"class (Functor t, Foldable t) => Traversable t where\n  traverse :: Applicative f => (a -> f b) -> t a -> f (t b)\n  traverse g = sequenceA . fmap g\n\n  sequenceA :: Applicative f = t (f a) -> f (t a)\n  sequenceA = traverse id\n\n  mapM :: Monad m => (a -> m b) -> t a -> m (t b)\n  mapM = traverse\n\n  sequence :: Monad m => t (m a) -> m (t a)\n  sequence = sequenceA\n")),(0,s.kt)("h3",{id:"list-1"},"List"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"instance Traversable [] where\n  -- traverse :: Applicative f => (a -> f b) -> [a] -> f [b]\n  traverse g [] = pure []\n  traverse g (x : xs) = pure (:) <*> g x <*> traverse g xs\n\ndec :: Int -> Maybe Int\ndec n = if n > 0 then Just (n - 1) else Nothing\n\nmain = do\n  print (traverse dec [1, 2, 3])  -- Just [0,1,2]\n  print (traverse dec [2, 1, 0])  -- Nothing\n\n  print (sequenceA [Just 1, Just 2, Just 3])  -- Just [1, 2, 3]\n  print (sequenceA [Just 1, Nothing, Just 3]) -- Nothing\n")),(0,s.kt)("h3",{id:"tree-1"},"Tree"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"instance Traversable Tree where\n  -- traverse :: Applicative f => (a -> f b) -> Tree a -> f (Tree b)\n  traverse g (Leaf x) = pure Leaf <*> g x\n  traverse g (Node l r) = pure Node <*> traverse g l <*> traverse g r\n\ndec :: Int -> Maybe Int\ndec n = if n > 0 then Just (n - 1) else Nothing\n\nmain = do\n  print (traverse dec (Node (Leaf 1) (Leaf 2))) -- Just (Node (Leaf 0) (Leaf 1))\n  print (traverse dec (Node (Leaf 0) (Leaf 1))) -- Nothing\n\n  print (sequenceA (Node (Leaf (Just 1)) (Leaf (Just 2))))  -- Just (Node (Leaf 1) (Leaf 2))\n  print (sequenceA (Node (Leaf (Just 1)) (Leaf Nothing))) -- Nothing\n")),(0,s.kt)("h2",{id:"lazy-evaluation"},"Lazy Evaluation"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Lazy evaluation")," is the use of ",(0,s.kt)("em",{parentName:"p"},"call-by-name")," evaluation in conjunction with sharing such as using pointer   "),(0,s.kt)("p",null,"In Haskell, any two different ways of evaluating the same expression will always produce the same final value, provided that they both terminate.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"inc :: Int -> Int\ninc n = n + 1\n\n-- from right\ninc (2 * 3)\n= { applying * }\ninc 6\n= { applying inc }\n6 + 1\n= { applying + }\n7\n\n-- from left\ninc (2 * 3)\n= { applying inc }\n(2 * 3) + 1\n= { applying * }\n6 + 1\n= { applying + }\n7\n")),(0,s.kt)("h3",{id:"call-by-value-evaluation"},"call-by-value evaluation"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"call-by-name")," evaluation is preferable to ",(0,s.kt)("em",{parentName:"p"},"call-by-value")," for ensuring that evaluation terminates as often as possible.  "),(0,s.kt)("p",null,(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow"},"\u2235")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\because")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6922em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel amsrm"},"\u2235")))))," ",(0,s.kt)("em",{parentName:"p"},"call-by-name")," evaluation will terminate if there exists any evaluation sequence that terminates for a given expression, and produce the same final value.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"square :: Int -> Int\nsquare n = n * n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"square (1 + 2)\n= { applying square }\n(1 + 2) * (1 + 2)\n= { applying the first +}\n3 * (1 + 2)\n= { applying + }  -- redundant reduction but can be resolved by using pointer to copy `(1 + 2)`\n3 * 3\n= { applying * }\n9\n")),(0,s.kt)("p",null,"the following expression terminates in ",(0,s.kt)("em",{parentName:"p"},"call-by-name")," evaluation.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"inf :: Int\ninf = 1 + inf\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"fst (0, inf)\n= { applying fst }\n0\n")),(0,s.kt)("h3",{id:"call-by-name-evaluation"},"call-by-name evaluation"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"square (1 + 2)\n= { applying + }\nsquare 3\n= { applying square }\n3 * 3\n= { applying * }\n9\n")),(0,s.kt)("p",null,"the following expression does not terminate in ",(0,s.kt)("em",{parentName:"p"},"call-by-value")," evaluation.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"fst (0, inf)\n= { applying inf }\nfst (0, 1 + inf)\n= { applying inf }\nfst (0, 1 + (1 + inf))\n= { applying inf }\n...\n")),(0,s.kt)("h3",{id:"modular-programming"},"Modular Programming"),(0,s.kt)("p",null,"Lazy evaluation allows us to separate ",(0,s.kt)("em",{parentName:"p"},"control")," from ",(0,s.kt)("em",{parentName:"p"},"data")," in our computations.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- take 3: control\n-- ones: data\ntake 3 ones -- [1,1,1]\n\n-- pattern of without lazy evaluation:\n-- need to make (= control) a certain data.\n-- cannot separate control from data.\nreplicate 3 1 -- [1,1,1]\n")),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"the sieve of Eratosthenes"),"  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"primes :: [Int]\nprimes = sieve [2 ..]\n\nsieve :: [Int] -> [Int]\nsieve (p : xs) = p : sieve [x | x <- xs, x `mod` p /= 0]\n\nmain = do\n  print (take 10 primes) -- [2,3,5,7,11,13,17,19,23,29]\n  print (takeWhile (< 10) primes) -- [2,3,5,7]\n")),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"sieve",src:a(6761).Z,width:"661",height:"431"})),(0,s.kt)("h3",{id:"strict-application"},"Strict Application"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"strict")," functions such as built-in arithmetic operator, ",(0,s.kt)("inlineCode",{parentName:"p"},"*")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"+")," cannot be applied until their two arguments have been evaluated to numbers; values  "),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"f $! x"),"; ",(0,s.kt)("inlineCode",{parentName:"p"},"f")," is immediately applied to ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," (if x is an expression, after evaluation of x)  "),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"$!")," serves as a stopper for outmost evaluation"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"square $! (1 + 2)\n= { applying + }\nsquare $! 3\n= { applying $! }\nsquare 3\n= { applying square }\n3 * 3\n= { applying * }\n9\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"strict application is mainly used to improve the space performance of programs."),"  "),(0,s.kt)("p",null,"pattern with lazy evaluation  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"sumwith :: Int -> [Int] -> Int\nsumwith v [] = v\nsumwith v (x : xs) = sumwith (v + x) xs\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"sumwith 0 [1, 2, 3]\n= { applying sumwith }\nsumwith (0 + 1) [2, 3]\n= { applying sumwith }\nsumwith ((0 + 1) + 2) [3]\n= { applying sumwith }\nsumwith (((0 + 1) + 2) + 3) []\n= { applying sumwith }\n((0 + 1) + 2) + 3 -- the length is the same with the original list so sumwith requires much space for evaluation if given a long list.  \n= { applying the first + }\n(1 + 2) + 3\n= { applying the first + }\n3 + 3\n= { applying + }\n6\n")),(0,s.kt)("p",null,"pattern with strict application  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"sumwith :: Int -> [Int] -> Int\nsumwith v [] = v\nsumwith v (x : xs) = (sumwith $! (v + x)) xs\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"sumwith 0 [1, 2, 3]\n= { applying sumwith }\n(sumwith $! (0 + 1)) [2, 3]\n= { applying + }\n(sumwith $! 1) [2, 3]\n= { applying $! }\nsumwith 1 [2, 3]\n= { applying sumwith }\n(sumwith $! (1 + 2)) [3]\n= { applying + }\n(sumwith $! 3) [3]\n= { applying $! }\nsumwith 3 [3]\n= { applying sumwith }\n(sumwith $! (3 + 3)) []\n= { applying + }\n(sumwith $! 6) []\n= { applying $! }\nsumwith 6 []\n= { applying sumwith }\n6\n")),(0,s.kt)("h3",{id:"foldl-1"},"foldl'"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"-- in Data.Foldable\n\nfoldl' :: (a -> b -> a) -> a -> [b] -> a\nfoldl' f v [] = v\nfoldl' f v (x : xs) = ((foldl' f) $! (f v x)) xs\n")),(0,s.kt)("h2",{id:"reasoning"},"Reasoning"),(0,s.kt)("h3",{id:"induction"},"Induction"),(0,s.kt)("p",null,"can be used to confirm the logic or propeties of a recursive type or a recursive function is correct.  "),(0,s.kt)("p",null,"e.g.1 (about natural number)"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"replicate :: Int -> a -> [a]\nreplicate 0 _ = []\nreplicate n x = x : replicate (n - 1) x\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"-- hypothesis:\n-- replication function produce a list when n elements, that is `length (replicate n x) = n`\n\n-- Base case:\nlength (replicate 0 x)\n= { applying replicate }\nlength []\n= 0\n\n-- Inductive case\nlength (replicate (n + 1) x)\n= { applying replicate }\nlength (x : replicate n x)\n= { applying length }\n1 + length (replicate n x)\n= { induction hypothesis }\n1 + n\n= { commutativity of + }\nn + 1\n")),(0,s.kt)("p",null,"e.g.2 (about list)  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"reverse :: [a] -> [a]\nreverse [] = []\nreverse (x : xs) = reverse xs ++ x\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"-- hypothesis 1:\n-- contravariant; reverse (xs ++ ys) = reverse ys ++ reverse xs\n\n-- Base case:\nreverse ([] ++ ys)\n= { applying ++ }\nreverse ys\n= { identity for ++ }\nreverse ys ++ []\n= { unapplying reverse }\nreverse ys ++ reverse []\n\n-- Inductive case:\nreverse ((x : xs) ++ ys)\n= { applying ++ }\nreverse (x : (xs ++ ys))\n= { applying reverse }\nreverse (xs ++ ys) ++ [x]\n= { induction hypothesis }\n(reverse ys ++ reverse xs) ++ [x]\n= { associativity of ++ }\nreverse ys ++ (reverse xs ++ [x])\n= { unapplying the second reverse }\nreverse ys ++ reverse (x : xs)\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"-- hypothesis 2:\n-- reverse (reverse (x : xs)) = x : xs\n\n-- Base case:\nreverse (reverse [])\n= { applying the inner reverse }\nreverse []\n= { appyling reverse }\n[]\n\n-- Inductive case:\nreverse (reverse (x : xs))\n= { applying the inner reverse }\nreverse (reverse xs ++ [x])\n= { contravariant }\nreverse [x] ++ reverse (reverse xs)\n= { singleton lists }\n[x] ++ reverse (reverse xs)\n= { induction hypothesis }\n[x] ++ xs\n= { applying ++ }\nx : xs\n")),(0,s.kt)("p",null,"e.g.3 (about fmap low on list)"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"fmap id = id\nfmap (g . h) = fmap g . fmap h\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"fmap :: (a -> b) -> [a] -> [b]\nfmap g [] = []\nfmap g (x : xs) = g x : fmap g xs\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"-- hypothesis 1: fmap id = id\n\n-- Base case:\nfmap id []\n= { applying fmap }\n[]\n\n-- Inductive case:\nfmap id (x : xs)\n= { applying fmap }\nid x : fmap id xs\n= { applying id }\nx : fmap id xs\n= { induction hypothesis }\nx : xs\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"-- hypothesis 2: \n-- fmap (g . h) = fmap g . fmap h\n-- i.e. fmap (g . h) xs = fmap g (fmap h xs)\n\n-- Base case:\nfmap (g . h) []\n= { applying fmap }\n[]\n= { unapplying fmap }\nfmap g []\n= { unapplying fmap }\nfmap g (fmap h [])\n\n-- Inductive case:\nfmap (g . h) (x : xs)\n= { applying fmap }\n(g . h) x : fmap (g . h) xs\n= { applying . }\ng (h x) : fmap (g . h) xs\n= { induction hypothesis }\ng (h x) : fmap g (fmap h xs)\n= { unapplying fmap }\nfmap g (h x : fmap h xs)\n= { unapplying fmap }\nfmap g (fmap h (x : xs))\n")),(0,s.kt)("h3",{id:"improve-computing-time"},"Improve Computing Time"),(0,s.kt)("h4",{id:"reverse"},"reverse()"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"reverse")," function run by ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("msup",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msup"},"n"),(0,s.kt)("mn",{parentName:"msup"},"2")),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n^2)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,s.kt)("span",{parentName:"span",className:"mclose"},")")))))," because in general ",(0,s.kt)("inlineCode",{parentName:"p"},"xs ++ ys")," needs ",(0,s.kt)("inlineCode",{parentName:"p"},"(length xs) + 1")," steps to concatinate xs and xs, so ",(0,s.kt)("inlineCode",{parentName:"p"},"reverse xs ++ [x]")," is bottle neck.",(0,s.kt)("br",{parentName:"p"}),"\n","we try to difine another version ",(0,s.kt)("em",{parentName:"p"},"reverse"),"; ",(0,s.kt)("em",{parentName:"p"},"reverse'")," to improve computing time.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"reverse :: [a] -> [a]\nreverse [] = []\nreverse (x : xs) = reverse xs ++ [x]\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"-- hypothesis to construct the definition of reverse':\n-- reverse' xs ys = xs ++ ys\n\n-- Base case:\nreverse' [] ys\n= { specification of reverse' }\nreverse [] ++ ys\n= { applying reverse }\n[] ++ ys\n= { applying ++ }\nys\n\n-- Inductive case:\nreverse' (x : xs) ys\n= { specification of reverse' }\nreveres (x : xs) ++ ys\n= { applying reverse }\n(reverse xs ++ [x]) ++ ys\n= { associativity of ++ }\nreverse xs ++ ([x] ++ ys)\n= { induction hypothesis }\nreverse' xs ([x] ++ ys)\n= { applying ++ }\nreverse' xs (x : ys)\n")),(0,s.kt)("p",null,"we obtain another definition of ",(0,s.kt)("em",{parentName:"p"},"reverse'")," .  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"reverse' :: [a] -> [a] -> [a]\nreverse' [] ys = ys\nreverse' (x : xs) ys = reverse' xs (x : ys)\n\nreverse :: [a] -> [a]\nreverse xs = reverse' xs [] -- = foldl (\\xs x -> x : xs) []\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"reverse [1, 2, 3]\n= { applying reverse }\nreverse' [1, 2, 3] []\n= { applying reverse' }\nreverse' [2, 3] (1 : [])\n= { applying reverse' }\nreverse' [3] (2 : (1 : []))\n= { applying reverse' }\nreverse' [] (3 : (2 : 1 : []))\n= { applying reverse' }\n3 : (2 : 1 : [])\n")),(0,s.kt)("h4",{id:"flatten"},"flatten()"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"data Tree = Leaf Inf | Node Tree Tree\n\nflatten :: Tree -> [Int]\nflatten (Leaf n) = [n]\nflatten (Node l r) = flatten l ++ flatten r\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"-- hypothesis to construct an improved definition of flatten; flatten'\n-- flatten' t ns = flatten t ++ ns\n\n-- Base case:\nflatten' (Leaf n) ns\n= { specification of flatten' }\nflatten (Leaf n) ++ ns\n= { applying flatten }\n[n] ++ ns\n= { applying ++ }\nn : ns\n\n-- Inductive case:\nflatten' (Node l r) ns\n= { specification of flatten' }\nflatten (Node l r) ++ ns\n= { applying flatten }\n(flatten l ++ flatten r) ++ ns\n= { associativity of }\nflatten l ++ (flatten r ++ ns)\n= { induction hypothesis for l }\nflatten' l (flatten r ++ ns)\n= { induction hypothesis for r }\nflatten' l (flatten' r ns)\n")),(0,s.kt)("p",null,"we obtain the following definition.  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-hs"},"flatten' :: Tree -> [Int] -> [Int]\nflatten' (Leaf n) ns = n : ns\nflatten' (Node l r) ns = flatten' l (flatten' r ns)\n\nflatten :: Tree -> [Int]\nflatten t = flatten' t []\n")))}d.isMDXComponent=!0},6458:(e,n,a)=>{a.d(n,{Z:()=>t});const t=a.p+"assets/images/interactive_program-55281981fc1089df658441fa95e95bd4.png"},6761:(e,n,a)=>{a.d(n,{Z:()=>t});const t=a.p+"assets/images/sieve-a54423639dbd9d424cff564ef3407dcc.png"}}]);