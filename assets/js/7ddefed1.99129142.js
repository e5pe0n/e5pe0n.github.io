"use strict";(self.webpackChunke_5_pe_0_n_github_io=self.webpackChunke_5_pe_0_n_github_io||[]).push([[4640],{9613:(n,t,e)=>{e.d(t,{Zo:()=>o,kt:()=>c});var a=e(9496);function s(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function r(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,a)}return e}function i(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?r(Object(e),!0).forEach((function(t){s(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function m(n,t){if(null==n)return{};var e,a,s=function(n,t){if(null==n)return{};var e,a,s={},r=Object.keys(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||(s[e]=n[e]);return s}(n,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(s[e]=n[e])}return s}var p=a.createContext({}),l=function(n){var t=a.useContext(p),e=t;return n&&(e="function"==typeof n?n(t):i(i({},t),n)),e},o=function(n){var t=l(n.components);return a.createElement(p.Provider,{value:t},n.children)},h="mdxType",N={inlineCode:"code",wrapper:function(n){var t=n.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(n,t){var e=n.components,s=n.mdxType,r=n.originalType,p=n.parentName,o=m(n,["components","mdxType","originalType","parentName"]),h=l(e),u=s,c=h["".concat(p,".").concat(u)]||h[u]||N[u]||r;return e?a.createElement(c,i(i({ref:t},o),{},{components:e})):a.createElement(c,i({ref:t},o))}));function c(n,t){var e=arguments,s=t&&t.mdxType;if("string"==typeof n||s){var r=e.length,i=new Array(r);i[0]=u;var m={};for(var p in t)hasOwnProperty.call(t,p)&&(m[p]=t[p]);m.originalType=n,m[h]="string"==typeof n?n:s,i[1]=m;for(var l=2;l<r;l++)i[l]=e[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,e)}u.displayName="MDXCreateElement"},7519:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>N,frontMatter:()=>r,metadata:()=>m,toc:()=>l});var a=e(8957),s=(e(9496),e(9613));const r={},i="Graph Algorithms",m={unversionedId:"algorithms/graph-algorithms",id:"algorithms/graph-algorithms",title:"Graph Algorithms",description:"Single Source Shortest Paths",source:"@site/docs/algorithms/graph-algorithms.md",sourceDirName:"algorithms",slug:"/algorithms/graph-algorithms",permalink:"/docs/algorithms/graph-algorithms",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"techNoteSidebar",previous:{title:"Flow Networks",permalink:"/docs/algorithms/flow-algorithms"},next:{title:"Mathmatical Algorithms",permalink:"/docs/algorithms/mathmatical-algorithms"}},p={},l=[{value:"Single Source Shortest Paths",id:"single-source-shortest-paths",level:2},{value:"Bellman-Ford Algorithm",id:"bellman-ford-algorithm",level:3},{value:"Dijkstra&#39;s Algorithm",id:"dijkstras-algorithm",level:3},{value:"All Pairs Shortest Paths",id:"all-pairs-shortest-paths",level:2},{value:"Warshall-Floyd Algorithm",id:"warshall-floyd-algorithm",level:3},{value:"MST: Minimum Spanning Tree",id:"mst-minimum-spanning-tree",level:2},{value:"Kruscal&#39;s Algorithm",id:"kruscals-algorithm",level:3},{value:"Prim&#39;s Algorithm",id:"prims-algorithm",level:3}],o={toc:l},h="wrapper";function N(n){let{components:t,...r}=n;return(0,s.kt)(h,(0,a.Z)({},o,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"graph-algorithms"},"Graph Algorithms"),(0,s.kt)("h2",{id:"single-source-shortest-paths"},"Single Source Shortest Paths"),(0,s.kt)("h3",{id:"bellman-ford-algorithm"},"Bellman-Ford Algorithm"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"V"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"E"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(\\lvert V \\rvert \\lvert E \\rvert)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"(\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05764em"}},"E"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"\u2223)")))))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"detect negative loop")),(0,s.kt)("li",{parentName:"ul"},"relax edges for ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"V"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mo",{parentName:"mrow"},"\u2212"),(0,s.kt)("mn",{parentName:"mrow"},"1")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\lvert V \\rvert - 1")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mopen"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"))))),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"see all vertexes in each loop"))),(0,s.kt)("li",{parentName:"ul"},"based on ",(0,s.kt)("em",{parentName:"li"},"triangle inequality"))),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"bellman_ford_graph1",src:e(1503).Z,width:"481",height:"241"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-txt",metastring:'title="test1.txt"',title:'"test1.txt"'},"7 10 1 7\n1 2 2\n1 3 5\n2 3 4\n2 4 6\n2 5 10\n3 4 2\n4 6 1\n5 6 3\n5 7 5\n6 7 9\n16\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++"',title:'"C++"'},'#include <fstream>\n#include <stdio.h>\n#include <vector>\n\n#define MAX_N 10\'000\n#define MAX_K 10\'000\n#define INF 1\'000\'000\'000\n\nusing namespace std;\n\nstruct Edge {\n  int u, v, weight;\n};\n\nint N, K, S, G;\nint dist[MAX_N], path[MAX_N];\nEdge E[MAX_K];\n\nvoid init(int s) {\n  for (int i = 0; i < N; ++i) {\n    dist[i] = INF;\n    path[i] = -1;\n  }\n  dist[s] = 0;\n}\n\nvoid relax(int u, int v, int weight) {\n  if (dist[v] > dist[u] + weight) {\n    dist[v] = dist[u] + weight;\n    path[v] = u;\n  }\n}\n\nbool bellman_ford() {\n  for (int i = 0; i < N - 1; ++i) {\n    for (auto e : E) {\n      relax(e.u, e.v, e.weight);\n    }\n  }\n  for (auto e : E) {\n    if (dist[e.v] > dist[e.u] + e.weight) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid print_path(int s, int v) {\n  if (s == v) {\n    printf("%d", s + 1);\n  } else if (v < 0) {\n    printf("\\n No path");\n  } else {\n    print_path(s, path[v]);\n    printf("->%d", v + 1);\n  }\n}\n\nint main() {\n  ifstream ifs("../testset/single_source_shortest_path/test1.txt");\n  ifs >> N >> K >> S >> G;\n  --S;\n  --G;\n  for (int i = 0; i < K * 2; i += 2) {\n    int u, v, weight;\n    ifs >> u >> v >> weight;\n    --u;\n    --v;\n    E[i] = Edge{u, v, weight};\n    E[i + 1] = Edge{v, u, weight};\n  }\n  init(S);\n  if (bellman_ford()) {\n    printf("dist=%d\\n", dist[G]);\n    printf("path=");\n    print_path(S, G);\n    printf("\\n");\n  } else {\n    printf("detect negative loop\\n");\n  }\n}\n\n// dist=16\n// path=1->3->4->6->5->7\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Python"',title:'"Python"'},"INF = float('inf')\n\n\ndef ns(f):\n    return next(f).strip()\n\n\nclass Edge:\n    def __init__(self, u, v, weight):\n        self.u = u\n        self.v = v\n        self.weight = weight\n\n\nwith open(\"../testset/single_source_shortest_path/test1.txt\", 'r') as f:\n    N, K, S, T = map(int, ns(f).split())\n    S -= 1\n    T -= 1\n    E = []\n    for _ in range(K):\n        u, v, weight = map(int, ns(f).split())\n        u -= 1\n        v -= 1\n        E.append(Edge(u, v, weight))\n        E.append(Edge(v, u, weight))\ndist = [INF] * N\ndist[S] = 0\npath = [-1] * N\n\n\ndef relax(u, v, weight):\n    global dist, path\n    if dist[v] > dist[u] + weight:\n        dist[v] = dist[u] + weight\n        path[v] = u\n\n\ndef bellman_ford():\n    # return True if the graph has negative loops.\n    for _ in range(N - 1):\n        for e in E:\n            relax(e.u, e.v, e.weight)\n\n    for e in E:\n        if dist[e.v] < dist[e.u] + e.weight:\n            return False\n    return True\n\n\ndef _print_path(s, v):\n    if s == v:\n        print(s + 1, end='')\n    elif v < 0:\n        print('\\nNo path', end='')\n    else:\n        _print_path(s, path[v])\n        print(f\"->{v + 1}\", end='')\n\n\ndef print_path(s, v):\n    _print_path(s, v)\n    print()\n\n\nbellman_ford()\nprint(f\"shortest distance={dist[T]}\")\nprint(\"shortest path=\", end='')\nprint_path(S, T)\n\n# shortest distance=16\n# shortest path=1->3->4->6->5->7\n")),(0,s.kt)("h3",{id:"dijkstras-algorithm"},"Dijkstra's Algorithm"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("msup",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msup"},"V"),(0,s.kt)("mn",{parentName:"msup"},"2")),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(V^2)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,s.kt)("span",{parentName:"span",className:"mclose"},")")))))," -> ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"E"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"l"),(0,s.kt)("mi",{parentName:"mrow"},"o"),(0,s.kt)("mi",{parentName:"mrow"},"g"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"V"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(\\lvert E \\rvert log \\lvert V \\rvert)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"(\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05764em"}},"E"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"o"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"g"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"\u2223)")))))," (used heap queue)"),(0,s.kt)("li",{parentName:"ul"},"use priority queue",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"see only the most nearest vertex")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++"',title:'"C++"'},'#include <fstream>\n#include <queue>\n#include <stdio.h>\n#include <vector>\n\n#define MAX_N 10\'000\n#define MAX_K 10\'000\n#define INF 1\'000\'000\'000\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct Edge {\n  int u, v, weight;\n  Edge(int u, int v, int weight) : u(u), v(v), weight(weight) {}\n};\n\nint N, K, S, T;\nvector<Edge> G[MAX_N];\nint dist[MAX_N], path[MAX_N];\n\nvoid init(int s) {\n  fill(dist, dist + N, INF);\n  fill(path, path + N, -1);\n  dist[s] = 0;\n}\n\nvoid dijkstra(int s) {\n  init(s);\n  priority_queue<P, vector<P>, greater<P>> q;\n  q.push(P(0, s));\n  while (!q.empty()) {\n    P p = q.top();\n    q.pop();\n    int u = p.second;\n    if (dist[u] < p.first) {\n      continue;\n    }\n    for (auto e : G[u]) {\n      if (dist[e.v] > dist[u] + e.weight) {\n        // relax\n        dist[e.v] = dist[u] + e.weight;\n        path[e.v] = u;\n        q.push(P(dist[e.v], e.v));\n      }\n    }\n  }\n}\n\nvoid _print_path(int s, int v) {\n  if (s == v) {\n    printf("%d", s + 1);\n  } else if (v < 0) {\n    printf("No path\\n");\n  } else {\n    _print_path(s, path[v]);\n    printf("->%d", v + 1);\n  }\n}\n\nvoid print_path(int s, int v) {\n  _print_path(s, v);\n  printf("\\n");\n}\n\nint main() {\n  ifstream ifs("../testset/single_source_shortest_path/test1.txt");\n  ifs >> N >> K >> S >> T;\n  --S;\n  --T;\n  for (int i = 0; i < K; ++i) {\n    int u, v, weight;\n    ifs >> u >> v >> weight;\n    --u;\n    --v;\n    G[u].emplace_back(u, v, weight);\n    G[v].emplace_back(v, u, weight);\n  }\n  dijkstra(S);\n  printf("shortest distance=%d\\n", dist[T]);\n  printf("shortest path=");\n  print_path(S, T);\n}\n\n// shortest distance=16\n// shortest path=1->3->4->6->5->7\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Python"',title:'"Python"'},"from heapq import heapify, heappop, heappush\n\n\nINF = float('inf')\n\n\ndef ns(f):\n    return next(f).strip()\n\n\nclass Edge:\n    def __init__(self, u, v, weight):\n        self.u = u\n        self.v = v\n        self.weight = weight\n\n\nwith open(\"../testset/single_source_shortest_path/test1.txt\", 'r') as f:\n    N, K, S, T = map(int, ns(f).split())\n    S -= 1\n    T -= 1\n    G = [[] for _ in range(N)]\n    for _ in range(K):\n        u, v, weight = map(int, ns(f).split())\n        u -= 1\n        v -= 1\n        G[u].append(Edge(u, v, weight))\n        G[v].append(Edge(v, u, weight))\n\ndist = [INF] * N\ndist[S] = 0\npath = [-1] * N\n\n\ndef dijkstra():\n    global dist, path\n    q = [[0, S]]\n    heapify(q)\n    while len(q) > 0:\n        p = heappop(q)\n        u = p[1]\n        if dist[u] < p[0]:\n            continue\n        for e in G[u]:\n            if dist[e.v] > dist[u] + e.weight:\n                dist[e.v] = dist[u] + e.weight\n                path[e.v] = u\n                heappush(q, [dist[e.v], e.v])\n\n\ndef _print_path(s, v):\n    if s == v:\n        print(s + 1, end='')\n    elif v < 0:\n        print('\\nNo path', end='')\n    else:\n        _print_path(s, path[v])\n        print(f\"->{v + 1}\", end='')\n\n\ndef print_path(s, v):\n    _print_path(s, v)\n    print()\n\n\ndijkstra()\nprint(f\"shortest distance={dist[T]}\")\nprint(\"shortest path=\", end='')\nprint_path(S, T)\n\n# shortest distance=16\n# shortest path=1->3->4->6->5->7\n")),(0,s.kt)("h2",{id:"all-pairs-shortest-paths"},"All Pairs Shortest Paths"),(0,s.kt)("h3",{id:"warshall-floyd-algorithm"},"Warshall-Floyd Algorithm"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"use DP to consider a path from ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"i")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"i")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6595em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"i")))))," to ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"j")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"j")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.854em",verticalAlign:"-0.1944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05724em"}},"j")))))," is through ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"k")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"k")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03148em"}},"k")))))," or not",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"which more shorter is path through ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"k")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"k")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03148em"}},"k")))))," or not")))),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"all_pairs_shortest_paths",src:e(8175).Z,width:"475",height:"253"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-txt",metastring:'title="test1.txt"',title:'"test1.txt"'},"5 9\n1 2 3\n1 3 8\n1 5 -4\n2 4 1\n2 5 7\n3 2 4\n4 1 2\n4 3 -5\n5 4 6\n0 1 -3 2 -4\n3 0 -4 1 -1\n7 4 0 5 3\n2 -1 -5 0 -2\n8 5 1 6 0\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++"',title:'"C++"'},'#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n\n#define MAX_N 1\'000\n#define INF 1\'000\'000\'000\n\nusing namespace std;\n\nint N, K;\nint d[MAX_N][MAX_N];\n\nvoid warshall_floyd() {\n  for (int k = 0; k < N; ++k) {\n    for (int i = 0; i < N; ++i) {\n      for (int j = 0; j < N; ++j) {\n        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  ifstream ifs("../testset/all_pairs_shortest_path/test1.txt");\n  ifs >> N >> K;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      if (i == j) {\n        d[i][j] = 0;\n      } else {\n        d[i][j] = INF;\n      }\n    }\n  }\n  for (int i = 0; i < K; ++i) {\n    int u, v, weight;\n    ifs >> u >> v >> weight;\n    --u;\n    --v;\n    d[u][v] = weight;\n    // if non-direction graph add d[v][u]\n    // d[v][u] = weight;\n  }\n  warshall_floyd();\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      printf("%d ", d[i][j]);\n    }\n    printf("\\n");\n  }\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Python"',title:'"Python"'},"INF = float('inf')\n\n\ndef ns(f):\n    return next(f).strip()\n\n\nwith open(\"../testset/all_pairs_shortest_path/test1.txt\", 'r') as f:\n    N, K = map(int, ns(f).split())\n    d = [[0 if i == j else INF for j in range(N)] for i in range(N)]\n    for _ in range(K):\n        u, v, weight = map(int, ns(f).split())\n        u -= 1\n        v -= 1\n        d[u][v] = weight\n        # if non-direction graph add d[v][u]\n        # d[v][u] = weight\n\n\ndef warshall_floyd():\n    global d\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\n\nwarshall_floyd()\nfor _d in d:\n    print(' '.join(map(str, _d)))\n")),(0,s.kt)("h2",{id:"mst-minimum-spanning-tree"},"MST: Minimum Spanning Tree"),(0,s.kt)("h3",{id:"kruscals-algorithm"},"Kruscal's Algorithm"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"be similar to Bellman-Ford Algorithm"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"E"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"l"),(0,s.kt)("mi",{parentName:"mrow"},"o"),(0,s.kt)("mi",{parentName:"mrow"},"g"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"V"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(\\lvert E \\rvert log \\lvert V \\rvert)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"(\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05764em"}},"E"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"o"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"g"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"\u2223)")))))),(0,s.kt)("li",{parentName:"ul"},"use ",(0,s.kt)("em",{parentName:"li"},"Union-Find Tree")),(0,s.kt)("li",{parentName:"ul"},"add vertexes of the min weight edge into tree repeatedly if the tree doesn't include the vertexes")),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"mst",src:e(4385).Z,width:"281",height:"241"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-txt",metastring:'title="test1.txt"',title:'"test1.txt"'},"7 9\n1 3 1\n2 3 2\n2 5 10\n3 4 3\n3 6 7\n4 6 1\n4 7 5\n5 6 5\n6 7 8\n17\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++"',title:'"C++"'},'#include <algorithm>\n#include <fstream>\n#include <memory.h>\n#include <stdio.h>\n\n#define MAX_N 10\'000\n#define MAX_K 10\'000\n\nusing namespace std;\n\nstruct Edge {\n  int u, v, weight;\n};\n\nint N, K, ans;\nint par[MAX_N], rnk[MAX_N]{};\nEdge E[MAX_K];\n\nvoid init() {\n  for (int i = 0; i < N; ++i) {\n    par[i] = i;\n  }\n}\n\nint find(int u) {\n  if (par[u] == u) {\n    return u;\n  }\n  return par[u] = find(par[u]);\n}\n\nvoid unite(int u, int v) {\n  u = find(u);\n  v = find(v);\n  if (u == v) {\n    return;\n  }\n  if (rnk[u] < rnk[v]) {\n    par[u] = v;\n  } else {\n    par[v] = u;\n    if (rnk[u] == rnk[v]) {\n      ++rnk[u];\n    }\n  }\n}\n\nbool same(int u, int v) { return find(u) == find(v); }\n\nint kruscal() {\n  int res = 0;\n  sort(E, E + K, [](const Edge &e1, const Edge &e2) { return e1.weight < e2.weight; });\n  init();\n  for (auto e : E) {\n    if (!same(e.u, e.v)) {\n      res += e.weight;\n      unite(e.u, e.v);\n    }\n  }\n  return res;\n}\n\nint main() {\n  ifstream ifs("../testset/minimum_spanning_tree/test1.txt");\n  ifs >> N >> K;\n  for (int i = 0; i < K; ++i) {\n    int u, v, weight;\n    ifs >> u >> v >> weight;\n    E[i] = Edge{--u, --v, weight};\n  }\n  ans = kruscal();\n  printf("%d\\n", ans);\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Python"',title:'"Python"'},"def ns(f):\n    return next(f).strip()\n\n\nclass Edge:\n    def __init__(self, u, v, weight):\n        self.u = u\n        self.v = v\n        self.weight = weight\n\n\nwith open(\"../testset/minimum_spanning_tree/test1.txt\", 'r') as f:\n    N, K = map(int, ns(f).split())\n    E = []\n    for _ in range(K):\n        u, v, weight = map(int, ns(f).split())\n        E.append(Edge(u - 1, v - 1, weight))\n\npar = [i for i in range(N)]\nrnk = [0] * N\n\n\ndef find(u):\n    global par\n    if par[u] == u:\n        return u\n    par[u] = find(par[u])\n    return par[u]\n\n\ndef unite(u, v):\n    global par, rnk\n    u = find(u)\n    v = find(v)\n    if u == v:\n        return\n    if rnk[u] < rnk[v]:\n        par[u] = v\n    else:\n        par[v] = u\n        if rnk[u] == rnk[v]:\n            rnk[u] += 1\n\n\ndef same(u, v):\n    return find(u) == find(v)\n\n\ndef kruscal():\n    res = 0\n    E.sort(key=lambda x: x.weight)\n    for e in E:\n        if not same(e.u, e.v):\n            res += e.weight\n            unite(e.u, e.v)\n    return res\n\n\nans = kruscal()\nprint(ans)\n")),(0,s.kt)("h3",{id:"prims-algorithm"},"Prim's Algorithm"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"be similar to Dijkstra's Algorithm"),(0,s.kt)("li",{parentName:"ul"},"use priority queue -> ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"E"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"l"),(0,s.kt)("mi",{parentName:"mrow"},"o"),(0,s.kt)("mi",{parentName:"mrow"},"g"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"V"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(\\lvert E \\rvert log \\lvert V \\rvert)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"(\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05764em"}},"E"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"o"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"g"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"\u2223)")))))),(0,s.kt)("li",{parentName:"ul"},"add vertex having the shortest distance from added vertexes in the tree into tree repeatedly")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++"',title:'"C++"'},'#include <fstream>\n#include <queue>\n#include <stdio.h>\n#include <utility>\n#include <vector>\n\n#define MAX_N 10\'000\n#define MAX_K 10\'000\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct Edge {\n  int u, v, weight;\n  Edge(int u, int v, int weight) : u(u), v(v), weight(weight) {}\n};\n\nint N, K, ans;\nvector<Edge> G[MAX_N];\nbool used[MAX_N]{};\n\nint prim() {\n  int res = 0;\n  used[0] = true;\n  priority_queue<P, vector<P>, greater<P>> q;\n  for (auto e : G[0]) {\n    q.push(P(e.weight, e.v));\n  }\n  while (!q.empty()) {\n    P p = q.top();\n    q.pop();\n    int u = p.second;\n    if (used[u]) {\n      continue;\n    }\n    used[u] = true;\n    res += p.first;\n    for (auto e : G[u]) {\n      if (!used[e.v]) {\n        q.push(P(e.weight, e.v));\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  ifstream ifs("../testset/minimum_spanning_tree/test1.txt");\n  ifs >> N >> K;\n  for (int i = 0; i < K; ++i) {\n    int u, v, weight;\n    ifs >> u >> v >> weight;\n    --u;\n    --v;\n    G[u].emplace_back(u, v, weight);\n    G[v].emplace_back(v, u, weight);\n  }\n  ans = prim();\n  printf("%d\\n", ans);\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Python"',title:'"Python"'},"from heapq import heapify, heappop, heappush\n\n\ndef ns(f):\n    return next(f).strip()\n\n\nclass Edge:\n    def __init__(self, u, v, weight):\n        self.u = u\n        self.v = v\n        self.weight = weight\n\n\nwith open(\"../testset/minimum_spanning_tree/test1.txt\", 'r') as f:\n    N, K = map(int, ns(f).split())\n    G = [[] for _ in range(N)]\n    for _ in range(K):\n        u, v, weight = map(int, ns(f).split())\n        u -= 1\n        v -= 1\n        G[u].append(Edge(u, v, weight))\n        G[v].append(Edge(v, u, weight))\n\nused = [False] * N\n\n\ndef prim():\n    global used\n    res = 0\n    used[0] = True\n    q = [[e.weight, e.v] for e in G[0]]\n    heapify(q)\n    while len(q) > 0:\n        p = heappop(q)\n        u = p[1]\n        if used[u]:\n            continue\n        used[u] = True\n        res += p[0]\n        for e in G[u]:\n            if not used[e.v]:\n                heappush(q, [e.weight, e.v])\n    return res\n\n\nans = prim()\nprint(ans)\n")))}N.isMDXComponent=!0},8175:(n,t,e)=>{e.d(t,{Z:()=>a});const a=e.p+"assets/images/all_pairs_shortest_paths-746124188f20dc6c4a4c1297ad5f5375.png"},1503:(n,t,e)=>{e.d(t,{Z:()=>a});const a=e.p+"assets/images/bellman_ford_graph1-fa6942def07fcdd3359ed70bb2822c9d.png"},4385:(n,t,e)=>{e.d(t,{Z:()=>a});const a=e.p+"assets/images/mst-843f584a880401b34562d97c4d7d6e1c.png"}}]);