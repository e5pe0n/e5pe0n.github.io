"use strict";(self.webpackChunke_5_pe_0_n_github_io=self.webpackChunke_5_pe_0_n_github_io||[]).push([[961],{9613:(t,n,e)=>{e.d(n,{Zo:()=>c,kt:()=>f});var r=e(9496);function i(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function a(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,r)}return e}function s(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?a(Object(e),!0).forEach((function(n){i(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):a(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function o(t,n){if(null==t)return{};var e,r,i=function(t,n){if(null==t)return{};var e,r,i={},a=Object.keys(t);for(r=0;r<a.length;r++)e=a[r],n.indexOf(e)>=0||(i[e]=t[e]);return i}(t,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(r=0;r<a.length;r++)e=a[r],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(i[e]=t[e])}return i}var l=r.createContext({}),p=function(t){var n=r.useContext(l),e=n;return t&&(e="function"==typeof t?t(n):s(s({},n),t)),e},c=function(t){var n=p(t.components);return r.createElement(l.Provider,{value:n},t.children)},m="mdxType",u={inlineCode:"code",wrapper:function(t){var n=t.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(t,n){var e=t.components,i=t.mdxType,a=t.originalType,l=t.parentName,c=o(t,["components","mdxType","originalType","parentName"]),m=p(e),g=i,f=m["".concat(l,".").concat(g)]||m[g]||u[g]||a;return e?r.createElement(f,s(s({ref:n},c),{},{components:e})):r.createElement(f,s({ref:n},c))}));function f(t,n){var e=arguments,i=n&&n.mdxType;if("string"==typeof t||i){var a=e.length,s=new Array(a);s[0]=g;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=t,o[m]="string"==typeof t?t:i,s[1]=o;for(var p=2;p<a;p++)s[p]=e[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,e)}g.displayName="MDXCreateElement"},3543:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var r=e(8957),i=(e(9496),e(9613));const a={},s="Strings Algorithms",o={unversionedId:"algorithms/strings-algorithms",id:"algorithms/strings-algorithms",title:"Strings Algorithms",description:"Rabin-Karp",source:"@site/docs/algorithms/strings-algorithms.md",sourceDirName:"algorithms",slug:"/algorithms/strings-algorithms",permalink:"/docs/algorithms/strings-algorithms",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"techNoteSidebar",previous:{title:"Mathmatical Algorithms",permalink:"/docs/algorithms/mathmatical-algorithms"},next:{title:"Trees",permalink:"/docs/algorithms/trees"}},l={},p=[{value:"Rabin-Karp",id:"rabin-karp",level:2}],c={toc:p},m="wrapper";function u(t){let{components:n,...e}=t;return(0,i.kt)(m,(0,r.Z)({},c,e,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"strings-algorithms"},"Strings Algorithms"),(0,i.kt)("h2",{id:"rabin-karp"},"Rabin-Karp"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++"',title:'"C++"'},'const ll D = 256; // the number of distinct characters\nconst ll Q = 1\'000\'000\'007; // a prime number being larger than D\n\nll mod_pow(ll x, ll n, ll m) {\n  ll res = 1;\n  while (n > 0) {\n    if (n & 1) res = res * x % m;\n    x = x * x % m;\n    n >>= 1;\n  }\n  return res;\n}\n\nbool rabin_karp(const string &pat,\n                const string &txt,\n                const ll &d,\n                const ll &q) {\n  ll m = pat.size();\n  ll n = txt.size();\n  ll h = mod_pow(d, m - 1, q);  // the value of the highest digit\n  ll p = 0, t = 0;\n  for (ll i = 0; i < m; ++i) {\n    p = (d * p + pat[i]) % q;\n    t = (d * t + txt[i]) % q;\n  }\n  for (ll i = 0; i <= n - m; ++i) {\n    if (p == t && txt.substr(i, m) == pat) return true;\n    if (i < n - m) {\n      t = (d * (t - txt[i] * h) + txt[i + m]) % q;\n      t = (t + q) % q;\n    }\n  }\n  return false;\n}\n\nbool is_substr(const string &pat, const string &str) {\n  return rabin_karp(pat, str, D, Q);\n}\n\nint main() {\n  printf("%s\\n", is_substr("cde", "abcdefg") ? "true" : "false"); // true\n  printf("%s\\n", is_substr("adg", "abcdefg") ? "true" : "false"); // false\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py",metastring:'title="Python"',title:'"Python"'},'D = 256\nQ = 10**9 + 7\n\n\ndef mod_pow(x, n, m):\n    res = 1\n    while n > 0:\n        if n & 1:\n            res = res * x % m\n        x = x * x % m\n        n >>= 1\n    return res\n\n\ndef rabin_karp(pat, txt, d, q):\n    _pat = list(map(ord, pat))\n    _txt = list(map(ord, txt))\n    m = len(pat)\n    n = len(txt)\n    h = mod_pow(d, m - 1, q)\n    p, t = 0, 0\n    for i in range(m):\n        p = (d * p + _pat[i]) % q\n        t = (d * t + _txt[i]) % q\n    for i in range(n - m + 1):\n        if p == t and txt[i:i + m] == pat:\n            return True\n        if i < n - m:\n            t = (d * (t - _txt[i] * h) + _txt[i + m]) % q\n            t = (t + q) % q\n    return False\n\n\ndef is_substr(pat, string):\n    return rabin_karp(pat, string, D, Q)\n\n\nprint(is_substr("cde", "abcdefg"))  # True\nprint(is_substr("adg", "abcdefg"))  # False\n')))}u.isMDXComponent=!0}}]);