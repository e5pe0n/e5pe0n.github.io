"use strict";(self.webpackChunke_5_pe_0_n_github_io=self.webpackChunke_5_pe_0_n_github_io||[]).push([[8695],{9613:(n,e,t)=>{t.d(e,{Zo:()=>u,kt:()=>f});var a=t(9496);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function o(n,e){if(null==n)return{};var t,a,r=function(n,e){if(null==n)return{};var t,a,r={},i=Object.keys(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var l=a.createContext({}),m=function(n){var e=a.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):s(s({},e),n)),t},u=function(n){var e=m(n.components);return a.createElement(l.Provider,{value:e},n.children)},p="mdxType",c={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(n,e){var t=n.components,r=n.mdxType,i=n.originalType,l=n.parentName,u=o(n,["components","mdxType","originalType","parentName"]),p=m(t),d=r,f=p["".concat(l,".").concat(d)]||p[d]||c[d]||i;return t?a.createElement(f,s(s({ref:e},u),{},{components:t})):a.createElement(f,s({ref:e},u))}));function f(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var i=t.length,s=new Array(i);s[0]=d;var o={};for(var l in e)hasOwnProperty.call(e,l)&&(o[l]=e[l]);o.originalType=n,o[p]="string"==typeof n?n:r,s[1]=o;for(var m=2;m<i;m++)s[m]=t[m];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},167:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>m});var a=t(8957),r=(t(9496),t(9613));const i={},s="Flow Networks",o={unversionedId:"algorithms/flow-algorithms",id:"algorithms/flow-algorithms",title:"Flow Networks",description:"Ford-Fulkerson",source:"@site/docs/algorithms/flow-algorithms.md",sourceDirName:"algorithms",slug:"/algorithms/flow-algorithms",permalink:"/docs/algorithms/flow-algorithms",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"techNoteSidebar",previous:{title:"Bit Manipulation",permalink:"/docs/algorithms/bit-manipulation"},next:{title:"Graph Algorithms",permalink:"/docs/algorithms/graph-algorithms"}},l={},m=[{value:"Ford-Fulkerson",id:"ford-fulkerson",level:2},{value:"Bipartite Matching",id:"bipartite-matching",level:2}],u={toc:m},p="wrapper";function c(n){let{components:e,...i}=n;return(0,r.kt)(p,(0,a.Z)({},u,i,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"flow-networks"},"Flow Networks"),(0,r.kt)("h2",{id:"ford-fulkerson"},"Ford-Fulkerson"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"determine maximum flow"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("span",{parentName:"li",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"F"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,r.kt)("mi",{parentName:"mrow"},"E"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"\u2223"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(F \\lvert E \\rvert)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.13889em"}},"F"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"\u2223"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05764em"}},"E"),(0,r.kt)("span",{parentName:"span",className:"mclose"},"\u2223)"))))))),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"flow_network",src:t(3843).Z,width:"376",height:"263"}),"\n",(0,r.kt)("img",{alt:"residual_network",src:t(4048).Z,width:"851",height:"315"})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt",metastring:'title="test1.txt"',title:'"test1.txt"'},"5 7 0 4\n0 1 10\n0 2 2\n1 2 6\n1 3 6\n2 4 5\n3 2 3\n3 4 8\n11\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="O(F|E|) / C++"',title:'"O(F|E|)',"/":!0,'C++"':!0},'#include <fstream>\n#include <memory.h>\n#include <stdio.h>\n#include <vector>\n\n#define MAX_N 100\n#define INF 1\'000\'000\'000\n\nusing namespace std;\n\nstruct Edge {\n  int v, cap, rev;\n};\n\nint n, m, s, t;\nvector<Edge> G[MAX_N];\nbool used[MAX_N];\n\nvoid add_edge(int u, int v, int cap) {\n  G[u].push_back(Edge{v, cap, G[v].size()});\n  G[v].push_back(Edge{u, 0, G[u].size() - 1});\n}\n\nint dfs(int u, int t, int f) {\n  if (u == t) {\n    return f;\n  }\n  used[u] = true;\n  for (int i = 0; i < G[u].size(); ++i) {\n    Edge &e = G[u][i];\n    if (!used[e.v] && e.cap > 0) {\n      int d = dfs(e.v, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.v][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int res = 0;\n  for (;;) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if (f == 0) {\n      return res;\n    }\n    res += f;\n  }\n}\n\nvoid solve() {\n  int res = max_flow(s, t);\n  printf("%d\\n", res);\n}\n\nint main() {\n  ifstream ifs("../testset/maximum_traffic/test1.txt");\n  ifs >> n >> m >> s >> t;\n  for (int i = 0; i < m; ++i) {\n    int u, v, cap;\n    ifs >> u >> v >> cap;\n    add_edge(u, v, cap);\n  }\n  solve();\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="O(F|E|) / Python"',title:'"O(F|E|)',"/":!0,'Python"':!0},"INF = int(1e9)\n\n\ndef ns(f):\n    return next(f).strip()\n\n\nclass Edge:\n    def __init__(self, v, cap, rev):\n        self.v = v\n        self.cap = cap\n        self.rev = rev\n\n\nwith open(\"../testset/maximum_traffic/test1.txt\", 'r') as f:\n    n, m, s, t = map(int, ns(f).split())\n    G = [[] for _ in range(n)]\n\n    def add_edge(u, v, cap):\n        global G\n        G[u].append(Edge(v, cap, len(G[v])))\n        G[v].append(Edge(u, 0, len(G[u]) - 1))\n\n    for _ in range(m):\n        add_edge(*map(int, ns(f).split()))\n\n\ndef dfs(u, t, f, used):\n    if u == t:\n        return f\n    used[u] = True\n    for e in G[u]:\n        if not used[e.v] and e.cap > 0:\n            d = dfs(e.v, t, min(f, e.cap), used)\n            if d > 0:\n                e.cap -= d\n                G[e.v][e.rev].cap += d\n                return d\n    return 0\n\n\ndef max_flow(s, t):\n    res = 0\n    while True:\n        used = [False] * n\n        f = dfs(s, t, INF, used)\n        if f == 0:\n            return res\n        res += f\n\n\nprint(max_flow(s, t))\n")),(0,r.kt)("h2",{id:"bipartite-matching"},"Bipartite Matching"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"bipartite_matching",src:t(4912).Z,width:"320",height:"204"})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt",metastring:'title="text2.txt"',title:'"text2.txt"'},"3 3 4\n1 1\n1 3\n2 2\n3 2\n2\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++"',title:'"C++"'},'#include <fstream>\n#include <stdio.h>\n#include <vector>\n\n#define MAX_N 1000\n#define MAX_M 1000\n#define MAX_V MAX_N + MAX_M\n\nusing namespace std;\n\nint N, M, K;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int u) {\n  used[u] = true;\n  for (auto v : G[u]) {\n    int _u = match[v];\n    if (_u < 0 || (!used[_u] && dfs(_u))) {\n      // u is computers, _u is computer which is already assigned to work v, v is work\n      // increase num of matching only when w < 0 i.e. _u find a new work.\n      match[u] = v;\n      match[v] = u;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching() {\n  int res = 0;\n  fill(match, match + N + M, -1);\n  for (int u = 0; u < N; ++u) { // only left side vertexes\n    if (match[u] < 0) {\n      fill(used, used + N + M, 0);\n      if (dfs(u)) {\n        ++res;\n      }\n    }\n  }\n  return res;\n}\n\nvoid solve() { printf("%d\\n", bipartite_matching()); }\n\nint main() {\n  ifstream ifs("../testset/work_assignment/test2.txt");\n  ifs >> N >> M >> K;\n  for (int i = 0; i < K; ++i) {\n    int u, v;\n    ifs >> u >> v;\n    --u;\n    --v;\n    add_edge(u, N + v);\n    add_edge(N + v, u);\n  }\n  solve();\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Python"',title:'"Python"'},"def ns(f):\n    return next(f).strip()\n\n\nwith open(\"../testset/work_assignment/test1.txt\", 'r') as f:\n    N, M, K = map(int, ns(f).split())\n    V = N + M\n    G = [[] for _ in range(V)]\n    for _ in range(K):\n        u, v = map(int, ns(f).split())\n        u -= 1\n        v -= 1\n        G[u].append(N + v)\n        G[N + v].append(u)\n\n\ndef dfs(u, used, match):\n    used[u] = True\n    for v in G[u]:\n        _u = match[v]\n        if _u < 0 or (not used[_u] and dfs(_u, used, match)):\n            match[u] = v\n            match[v] = u\n            return True\n    return False\n\n\ndef bipartite_matching():\n    res = 0\n    match = [-1] * V\n    for u in range(N):\n        if match[u] < 0:\n            used = [False] * V\n            if dfs(u, used, match):\n                res += 1\n    return res\n\n\nprint(bipartite_matching())\n")))}c.isMDXComponent=!0},4912:(n,e,t)=>{t.d(e,{Z:()=>a});const a=t.p+"assets/images/bipartite_matching-13a19e868c3d0357d0ea4c6205feaa92.png"},3843:(n,e,t)=>{t.d(e,{Z:()=>a});const a=t.p+"assets/images/flow_network-afb51734c6fcadb337a66c8553db9a24.png"},4048:(n,e,t)=>{t.d(e,{Z:()=>a});const a=t.p+"assets/images/residual_network-a0e4c50e12d7288e6411e3d298c69f31.png"}}]);