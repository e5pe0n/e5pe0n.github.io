"use strict";(self.webpackChunke_5_pe_0_n_github_io=self.webpackChunke_5_pe_0_n_github_io||[]).push([[7874],{4490:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"algorithms/strings-algorithms","title":"Strings Algorithms","description":"Rabin-Karp","source":"@site/docs/algorithms/strings-algorithms.md","sourceDirName":"algorithms","slug":"/algorithms/strings-algorithms","permalink":"/docs/algorithms/strings-algorithms","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"techNoteSidebar","previous":{"title":"Mathmatical Algorithms","permalink":"/docs/algorithms/mathmatical-algorithms"},"next":{"title":"Trees","permalink":"/docs/algorithms/trees"}}');var s=e(6070),i=e(5248);const a={},l="Strings Algorithms",o={},c=[{value:"Rabin-Karp",id:"rabin-karp",level:2}];function p(n){const t={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"strings-algorithms",children:"Strings Algorithms"})}),"\n",(0,s.jsx)(t.h2,{id:"rabin-karp",children:"Rabin-Karp"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",metastring:'title="C++"',children:'const ll D = 256; // the number of distinct characters\nconst ll Q = 1\'000\'000\'007; // a prime number being larger than D\n\nll mod_pow(ll x, ll n, ll m) {\n  ll res = 1;\n  while (n > 0) {\n    if (n & 1) res = res * x % m;\n    x = x * x % m;\n    n >>= 1;\n  }\n  return res;\n}\n\nbool rabin_karp(const string &pat,\n                const string &txt,\n                const ll &d,\n                const ll &q) {\n  ll m = pat.size();\n  ll n = txt.size();\n  ll h = mod_pow(d, m - 1, q);  // the value of the highest digit\n  ll p = 0, t = 0;\n  for (ll i = 0; i < m; ++i) {\n    p = (d * p + pat[i]) % q;\n    t = (d * t + txt[i]) % q;\n  }\n  for (ll i = 0; i <= n - m; ++i) {\n    if (p == t && txt.substr(i, m) == pat) return true;\n    if (i < n - m) {\n      t = (d * (t - txt[i] * h) + txt[i + m]) % q;\n      t = (t + q) % q;\n    }\n  }\n  return false;\n}\n\nbool is_substr(const string &pat, const string &str) {\n  return rabin_karp(pat, str, D, Q);\n}\n\nint main() {\n  printf("%s\\n", is_substr("cde", "abcdefg") ? "true" : "false"); // true\n  printf("%s\\n", is_substr("adg", "abcdefg") ? "true" : "false"); // false\n}\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-py",metastring:'title="Python"',children:'D = 256\nQ = 10**9 + 7\n\n\ndef mod_pow(x, n, m):\n    res = 1\n    while n > 0:\n        if n & 1:\n            res = res * x % m\n        x = x * x % m\n        n >>= 1\n    return res\n\n\ndef rabin_karp(pat, txt, d, q):\n    _pat = list(map(ord, pat))\n    _txt = list(map(ord, txt))\n    m = len(pat)\n    n = len(txt)\n    h = mod_pow(d, m - 1, q)\n    p, t = 0, 0\n    for i in range(m):\n        p = (d * p + _pat[i]) % q\n        t = (d * t + _txt[i]) % q\n    for i in range(n - m + 1):\n        if p == t and txt[i:i + m] == pat:\n            return True\n        if i < n - m:\n            t = (d * (t - _txt[i] * h) + _txt[i + m]) % q\n            t = (t + q) % q\n    return False\n\n\ndef is_substr(pat, string):\n    return rabin_karp(pat, string, D, Q)\n\n\nprint(is_substr("cde", "abcdefg"))  # True\nprint(is_substr("adg", "abcdefg"))  # False\n'})})]})}function m(n={}){const{wrapper:t}={...(0,i.R)(),...n.components};return t?(0,s.jsx)(t,{...n,children:(0,s.jsx)(p,{...n})}):p(n)}},5248:(n,t,e)=>{e.d(t,{R:()=>a,x:()=>l});var r=e(758);const s={},i=r.createContext(s);function a(n){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof n?n(t):{...t,...n}}),[t,n])}function l(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),r.createElement(i.Provider,{value:t},n.children)}}}]);