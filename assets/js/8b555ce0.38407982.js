"use strict";(self.webpackChunke_5_pe_0_n_github_io=self.webpackChunke_5_pe_0_n_github_io||[]).push([[5615],{9613:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var r=t(9496);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),l=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):p(p({},n),e)),t},u=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},m="mdxType",f={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=l(t),c=a,h=m["".concat(s,".").concat(c)]||m[c]||f[c]||i;return t?r.createElement(h,p(p({ref:n},u),{},{components:t})):r.createElement(h,p({ref:n},u))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,p=new Array(i);p[0]=c;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[m]="string"==typeof e?e:a,p[1]=o;for(var l=2;l<i;l++)p[l]=t[l];return r.createElement.apply(null,p)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},8725:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>p,default:()=>f,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var r=t(8957),a=(t(9496),t(9613));const i={},p="Tips for Competitive Programming",o={unversionedId:"coding/python/tips-for-competitive-programimng",id:"coding/python/tips-for-competitive-programimng",title:"Tips for Competitive Programming",description:"Increase the limit of recursion",source:"@site/docs/coding/python/tips-for-competitive-programimng.md",sourceDirName:"coding/python",slug:"/coding/python/tips-for-competitive-programimng",permalink:"/docs/coding/python/tips-for-competitive-programimng",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"techNoteSidebar",previous:{title:"Fundamentals",permalink:"/docs/coding/python/fundamentals"},next:{title:"Rust",permalink:"/docs/category/rust"}},s={},l=[{value:"Increase the limit of recursion",id:"increase-the-limit-of-recursion",level:2},{value:"Use <em>Python</em> if you use recursion, instead of <em>PyPy</em>",id:"use-python-if-you-use-recursion-instead-of-pypy",level:2},{value:"Use <em>list</em> to join strings, instead of <em>str</em>",id:"use-list-to-join-strings-instead-of-str",level:2},{value:"Take mod appropriately",id:"take-mod-appropriately",level:2},{value:"Priority Queue",id:"priority-queue",level:2},{value:"Min Heap",id:"min-heap",level:3},{value:"Max Heap",id:"max-heap",level:3}],u={toc:l},m="wrapper";function f(e){let{components:n,...t}=e;return(0,a.kt)(m,(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"tips-for-competitive-programming"},"Tips for Competitive Programming"),(0,a.kt)("h2",{id:"increase-the-limit-of-recursion"},"Increase the limit of recursion"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"default is 1000.  "),(0,a.kt)("li",{parentName:"ul"},"set to like ",(0,a.kt)("em",{parentName:"li"},"10^9")," using ",(0,a.kt)("inlineCode",{parentName:"li"},"setrecursionlimit()"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"not sure that ",(0,a.kt)("em",{parentName:"li"},"10^9")," is appropriate value but had never failed so far at AtCoder")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"from sys import setrecursionlimit\nsetrecursionlimit(10**9)\n")),(0,a.kt)("h2",{id:"use-python-if-you-use-recursion-instead-of-pypy"},"Use ",(0,a.kt)("em",{parentName:"h2"},"Python")," if you use recursion, instead of ",(0,a.kt)("em",{parentName:"h2"},"PyPy")),(0,a.kt)("p",null,"ordinaly ",(0,a.kt)("em",{parentName:"p"},"PyPy")," performs better than ",(0,a.kt)("em",{parentName:"p"},"Python"),", but when using recursion it looks slower than ",(0,a.kt)("em",{parentName:"p"},"Python"),"."),(0,a.kt)("h2",{id:"use-list-to-join-strings-instead-of-str"},"Use ",(0,a.kt)("em",{parentName:"h2"},"list")," to join strings, instead of ",(0,a.kt)("em",{parentName:"h2"},"str")),(0,a.kt)("p",null,"Python's ",(0,a.kt)("em",{parentName:"p"},"str")," instance is immutable object so every join like ",(0,a.kt)("inlineCode",{parentName:"p"},"s += xxx")," create a new ",(0,a.kt)("em",{parentName:"p"},"str")," instance. this couse big overhead."),(0,a.kt)("p",null,"e.g. ",(0,a.kt)("a",{parentName:"p",href:"https://atcoder.jp/contests/abc158/tasks/abc158_d:embed:cite"},"AtCoder ABC158")),(0,a.kt)("p",null,"proglem that string manipulation is needed to like append or prepend string."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Using str (1975 ms)"',title:'"Using',str:!0,"(1975":!0,'ms)"':!0},'S = input()\nQ = int(input())\nf = False\nfront, back = "", ""\nfor _ in range(Q):\n    query = input().split()\n    if len(query) == 1:\n        f = not f\n    else:\n        F, C = query[1:]\n        if F == "1":\n            if f:\n                back += C\n            else:\n                front += C\n        else:\n            if f:\n                front += C\n            else:\n                back += C\nif f:\n    res = back[::-1] + S[::-1] + front\nelse:\n    res = front[::-1] + S + back\nprint(res)\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Using list (295 ms)"',title:'"Using',list:!0,"(295":!0,'ms)"':!0},'S = input()\nQ = int(input())\nf = False\nfront, back = [], []\nfor _ in range(Q):\n    query = input().split()\n    if len(query) == 1:\n        f = not f\n    else:\n        F, C = query[1:]\n        if F == "1":\n            if f:\n                back.append(C)\n            else:\n                front.append(C)\n        else:\n            if f:\n                front.append(C)\n            else:\n                back.append(C)\nif f:\n    res = "".join(back[::-1]) + S[::-1] + "".join(front)\nelse:\n    res = "".join(front[::-1]) + S + "".join(back)\nprint(res)\n')),(0,a.kt)("h2",{id:"take-mod-appropriately"},"Take mod appropriately"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Python's ",(0,a.kt)("em",{parentName:"li"},"int")," can have infinite value, but calculations involving big integers take a long time.  "),(0,a.kt)("li",{parentName:"ul"},"take mode appropriately to keep the integer small")),(0,a.kt)("h2",{id:"priority-queue"},"Priority Queue"),(0,a.kt)("h3",{id:"min-heap"},"Min Heap"),(0,a.kt)("p",null,"Python has only min heap.  "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"from heapq import heapify, heappop, heappush\n\nq = []\nheapify(q)\nheappush(q, 1)\nheappush(q, 5)\nheappush(q, 3)\nwhile len(q):\n    p = heappop(q)\n    print(p)    # 1 3 5\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"from heapq import heapify, heappop, heappush\n\n\nclass Edge:\n    def __init__(self, u, v, w):\n        self.u = u\n        self.v = v\n        self.w = w\n\n    def __lt__(self, other):\n        return self.w < other.w\n\n    def __gt__(self, other):\n        return self.w > other.w\n\n\nq = []\nheapify(q)\nheappush(q, Edge(1, 2, 1))\nheappush(q, Edge(0, 1, 5))\nheappush(q, Edge(0, 2, 3))\nwhile len(q):\n    e = heappop(q)\n    print(e.w)    # 1 3 5\n")),(0,a.kt)("h3",{id:"max-heap"},"Max Heap"),(0,a.kt)("p",null,"Python does not have max heap.",(0,a.kt)("br",{parentName:"p"}),"\n","We can get the same effect by negating values both when pushing and popping them.   "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"from heapq import heapify, heappop, heappush\n\nq = []\nheapify(q)\nheappush(q, -1)\nheappush(q, -5)\nheappush(q, -3)\nwhile len(q):\n    p = -heappop(q)\n    print(p)    # 5 3 1\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"from heapq import heapify, heappop, heappush\n\n\nclass Edge:\n    def __init__(self, u, v, w):\n        self.u = u\n        self.v = v\n        self.w = w\n\n    def __lt__(self, other):\n        return self.w > other.w\n\n    def __gt__(self, other):\n        return self.w < other.w\n\n\nq = []\nheapify(q)\nheappush(q, Edge(1, 2, 1))\nheappush(q, Edge(0, 1, 5))\nheappush(q, Edge(0, 2, 3))\nwhile len(q):\n    e = heappop(q)\n    print(e.w)    # 5 3 1\n")))}f.isMDXComponent=!0}}]);