"use strict";(self.webpackChunke_5_pe_0_n_github_io=self.webpackChunke_5_pe_0_n_github_io||[]).push([[6604],{1900:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"coding/haskell/fundamentals","title":"Fundamentals","description":"Naming Requirements of Functions","source":"@site/docs/coding/haskell/fundamentals.md","sourceDirName":"coding/haskell","slug":"/coding/haskell/fundamentals","permalink":"/docs/coding/haskell/fundamentals","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"techNoteSidebar","previous":{"title":"Haskell","permalink":"/docs/category/haskell"},"next":{"title":"JavaScript","permalink":"/docs/category/javascript"}}');var i=s(6070),l=s(5248);const r={},t="Fundamentals",c={},d=[{value:"Naming Requirements of Functions",id:"naming-requirements-of-functions",level:2},{value:"Standard Prelude",id:"standard-prelude",level:2},{value:"Types",id:"types",level:2},{value:"Notation 1",id:"notation-1",level:3},{value:"Notation 2",id:"notation-2",level:3},{value:"Type Interface and Type Safe",id:"type-interface-and-type-safe",level:3},{value:"Basic Types",id:"basic-types",level:3},{value:"List Types",id:"list-types",level:3},{value:"Tuple Types",id:"tuple-types",level:3},{value:"Function Types",id:"function-types",level:3},{value:"Curried Functions",id:"curried-functions",level:4},{value:"Polymorphic Types",id:"polymorphic-types",level:3},{value:"Type Variable",id:"type-variable",level:4},{value:"Overloaded Types",id:"overloaded-types",level:3},{value:"Class Constraint",id:"class-constraint",level:4},{value:"Classes",id:"classes",level:2},{value:"Eq - equality types",id:"eq---equality-types",level:3},{value:"Ord - ordered types",id:"ord---ordered-types",level:3},{value:"Show - showable types",id:"show---showable-types",level:3},{value:"Read - readable types",id:"read---readable-types",level:3},{value:"Num - numeric types",id:"num---numeric-types",level:3},{value:"Integral - integral types",id:"integral---integral-types",level:3},{value:"Fractional - fractional types",id:"fractional---fractional-types",level:3},{value:"Definning Functions",id:"definning-functions",level:2},{value:"Conditional Expressions",id:"conditional-expressions",level:3},{value:"Guarded Equations",id:"guarded-equations",level:3},{value:"Pattern matching",id:"pattern-matching",level:3},{value:"Tuple Patterns",id:"tuple-patterns",level:4},{value:"List Patterns",id:"list-patterns",level:4},{value:"Lambda Expressions",id:"lambda-expressions",level:3},{value:"Operator Sections",id:"operator-sections",level:3},{value:"List Comprehensions",id:"list-comprehensions",level:2},{value:"Guard",id:"guard",level:3},{value:"zip function",id:"zip-function",level:3},{value:"String comprehensions",id:"string-comprehensions",level:3},{value:"Recursive Functions",id:"recursive-functions",level:2},{value:"Recursion on Lists",id:"recursion-on-lists",level:3},{value:"Multiple Arguments",id:"multiple-arguments",level:3},{value:"Multiple Recursion",id:"multiple-recursion",level:3},{value:"Mutual Recursion",id:"mutual-recursion",level:3},{value:"Generalizing and Simplifying",id:"generalizing-and-simplifying",level:3},{value:"Higher-Order Functions",id:"higher-order-functions",level:2},{value:"Processing Lists",id:"processing-lists",level:3},{value:"foldr()",id:"foldr",level:3},{value:"foldl()",id:"foldl",level:3},{value:"Composition Operator",id:"composition-operator",level:3},{value:"Type Declarations",id:"type-declarations",level:2},{value:"Data Declarations",id:"data-declarations",level:2},{value:"Cosntructor Functions",id:"cosntructor-functions",level:3},{value:"vs. normal functions",id:"vs-normal-functions",level:4},{value:"Newtype Declarations",id:"newtype-declarations",level:3},{value:"vs. type",id:"vs-type",level:4},{value:"vs. data",id:"vs-data",level:4},{value:"Recursive Types",id:"recursive-types",level:3},{value:"Class and Instance Declarations",id:"class-and-instance-declarations",level:2},{value:"Derived Instances",id:"derived-instances",level:2},{value:"Interactive Programming",id:"interactive-programming",level:2},{value:"Basic Actions",id:"basic-actions",level:3},{value:"Sequencing",id:"sequencing",level:3},{value:"Derived primitives",id:"derived-primitives",level:3},{value:"Functors",id:"functors",level:2},{value:"Functor Laws",id:"functor-laws",level:3},{value:"Applicatives",id:"applicatives",level:2},{value:"applicative functors; applicative",id:"applicative-functors-applicative",level:3},{value:"Applicative Laws",id:"applicative-laws",level:3},{value:"Infix ver.",id:"infix-ver",level:3},{value:"Monads",id:"monads",level:2},{value:"<code>&gt;&gt;=</code> operator",id:"-operator",level:3},{value:"Monad Laws",id:"monad-laws",level:3},{value:"Usecases",id:"usecases",level:3},{value:"The State Monad",id:"the-state-monad",level:3},{value:"<em>state tronsformer</em>; <em>ST</em>",id:"state-tronsformer-st",level:4},{value:"Generic Functions",id:"generic-functions",level:3},{value:"mapM()",id:"mapm",level:4},{value:"filterM()",id:"filterm",level:4},{value:"join()",id:"join",level:4},{value:"Alternative",id:"alternative",level:2},{value:"Alternative Laws",id:"alternative-laws",level:3},{value:"Alternative Instances",id:"alternative-instances",level:3},{value:"Monoids",id:"monoids",level:2},{value:"Monoid Laws",id:"monoid-laws",level:3},{value:"Data.Monoid",id:"datamonoid",level:3},{value:"Lists",id:"lists",level:4},{value:"Maybe",id:"maybe",level:4},{value:"Sum",id:"sum",level:4},{value:"Product",id:"product",level:4},{value:"All",id:"all",level:4},{value:"Any",id:"any",level:4},{value:"Foldables",id:"foldables",level:2},{value:"List",id:"list",level:3},{value:"Tree",id:"tree",level:3},{value:"Generic Functions",id:"generic-functions-1",level:3},{value:"and()",id:"and",level:4},{value:"or()",id:"or",level:4},{value:"all()",id:"all-1",level:4},{value:"any()",id:"any-1",level:4},{value:"concat()",id:"concat",level:4},{value:"Traversable",id:"traversable",level:2},{value:"List",id:"list-1",level:3},{value:"Tree",id:"tree-1",level:3},{value:"Lazy Evaluation",id:"lazy-evaluation",level:2},{value:"call-by-value evaluation",id:"call-by-value-evaluation",level:3},{value:"call-by-name evaluation",id:"call-by-name-evaluation",level:3},{value:"Modular Programming",id:"modular-programming",level:3},{value:"Strict Application",id:"strict-application",level:3},{value:"foldl&#39;",id:"foldl-1",level:3},{value:"Reasoning",id:"reasoning",level:2},{value:"Induction",id:"induction",level:3},{value:"Improve Computing Time",id:"improve-computing-time",level:3},{value:"reverse()",id:"reverse",level:4},{value:"flatten()",id:"flatten",level:4}];function o(e){const n={annotation:"annotation",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"fundamentals",children:"Fundamentals"})}),"\n",(0,i.jsx)(n.h2,{id:"naming-requirements-of-functions",children:"Naming Requirements of Functions"}),"\n",(0,i.jsxs)(n.p,{children:["These are ",(0,i.jsx)(n.em,{children:"keywords"}),"; reversed words."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"case  class  data  default  deriving\ndo  else  foreign  if  import  in\ninfix  infixl  infixr  instance  let\nmodule  newtype  of  then  type  where\n"})}),"\n",(0,i.jsx)(n.h2,{id:"standard-prelude",children:"Standard Prelude"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"main = do\n  let x = [1, 2, 3, 4, 5]\n  print (head x) -- 1\n  print (tail x) -- [2, 3, 4, 5]\n  print (init x) -- [1, 2, 3, 4]\n  print (last x) -- 5\n  print (x !! 2) -- 3\n  print (take 3 x) -- [1, 2, 3]\n  print (drop 3 x) -- [4, 5]\n  print (length x) -- 5\n  print (sum x) -- 15\n  print (product x) -- 120\n  print ([1, 2, 3] ++ [4, 5]) -- [1 , 2, 3, 4, 5]\n  print (reverse x) -- [5, 4, 3, 2, 1]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"types",children:"Types"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"type"})," is a collection of related values."]}),"\n",(0,i.jsx)(n.h3,{id:"notation-1",children:"Notation 1"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"v :: T"})," means ",(0,i.jsx)(n.code,{children:"e"})," is a value in the type ",(0,i.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"False :: Bool\nTrue :: Bool\nnot :: Bool -> Bool\n"})}),"\n",(0,i.jsx)(n.h3,{id:"notation-2",children:"Notation 2"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"e :: T"})," means evaluation of the expression ",(0,i.jsx)(n.code,{children:"e"})," will produce a value of type ",(0,i.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"not False :: Bool\nnot True :: Bool\nnot (not False) :: Bool\n"})}),"\n",(0,i.jsx)(n.p,{children:"Typing rule"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"f :: A -> B  e :: A\n-------------------\n      f e -> B\n"})}),"\n",(0,i.jsx)(n.h3,{id:"type-interface-and-type-safe",children:"Type Interface and Type Safe"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"type interface"})," that evaluates types under typing rule.",(0,i.jsx)(n.br,{}),"\n","type interface precedes evaluation of values so Haskell programs are ",(0,i.jsx)(n.strong,{children:"type safe"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"basic-types",children:"Basic Types"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"center"},children:"types"}),(0,i.jsx)(n.th,{style:{textAlign:"center"},children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"Bool"}),(0,i.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"Char"}),(0,i.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"String"}),(0,i.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"Int"}),(0,i.jsxs)(n.td,{style:{textAlign:"center"},children:["fixed-precision intergers. the range is ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mo,{stretchy:"false",children:"["}),(0,i.jsx)(n.mo,{children:"\u2212"}),(0,i.jsxs)(n.msup,{children:[(0,i.jsx)(n.mn,{children:"2"}),(0,i.jsx)(n.mn,{children:"63"})]}),(0,i.jsx)(n.mo,{separator:"true",children:","}),(0,i.jsxs)(n.msup,{children:[(0,i.jsx)(n.mn,{children:"2"}),(0,i.jsx)(n.mn,{children:"63"})]}),(0,i.jsx)(n.mo,{children:"\u2212"}),(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"]"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"[-2^{63}, 2^{63} - 1]"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mopen",children:"["}),(0,i.jsx)(n.span,{className:"mord",children:"\u2212"}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord",children:"2"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsx)(n.span,{className:"vlist-t",children:(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,i.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mtight",children:(0,i.jsx)(n.span,{className:"mord mtight",children:"63"})})})]})})})})})]}),(0,i.jsx)(n.span,{className:"mpunct",children:","}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord",children:"2"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsx)(n.span,{className:"vlist-t",children:(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,i.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mtight",children:(0,i.jsx)(n.span,{className:"mord mtight",children:"63"})})})]})})})})})]}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"\u2212"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsx)(n.span,{className:"mclose",children:"]"})]})]})]})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"Integer"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"arbitarary-precision integers"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"Float"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"single-precision floating-point numbers"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"Double"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"double-precision floating-point numbers"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"list-types",children:"List Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"[['a', 'b'], ['c', 'd', 'e']] :: [[Char]]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"tuple-types",children:"Tuple Types"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"arity"}),": the number of components in a tuple"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["arity zero: ",(0,i.jsx)(n.code,{children:"()"}),"; the empty tuple"]}),"\n",(0,i.jsxs)(n.li,{children:["arity one: ",(0,i.jsx)(n.strong,{children:"Not Permitted"})]}),"\n",(0,i.jsxs)(n.li,{children:["arity two: ",(0,i.jsx)(n.em,{children:"pairs"})]}),"\n",(0,i.jsxs)(n.li,{children:["arity three: ",(0,i.jsx)(n.em,{children:"triples"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:'tp1 = ("Yes", True, \'a\') :: (String, Bool, Char)\ntp2 = (3, "Blue") :: (Int, String)\n\nmain = do\n  print (fst tpl) -- 3\n  print (snd tpl) -- "Blue"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"function-types",children:"Function Types"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"function"})," is mapping from arguments of one type to results of another type."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"add :: (Int, Int) -> Int\nadd (x, y) = x + y\n\nadd (1, 2)  -- 3\n\n\nzeroto :: Int -> [Int]\nzeroto n = [0..n]\n"})}),"\n",(0,i.jsx)(n.h4,{id:"curried-functions",children:"Curried Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"add' :: Int -> (Int -> Int)\nadd' x y = x + y\n\nadd' 1 2  -- 3\n\n\nmult :: Int -> (Int -> (Int -> Int))\nmult x y z = x * y * z\n"})}),"\n",(0,i.jsx)(n.p,{children:"Don't confuse currying and partial application"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Currying: divide a function into functions with only one argument and nest them."}),"\n",(0,i.jsx)(n.li,{children:"Partial Application: create a new function by fixing partial arguments of a original function"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- currying\nadd' :: Int -> (Int - > Int)\nadd' x y = x + y\n\nadd' 1 2\n\n-- partial application 1\nadd'' = add' 1\nadd'' 2 -- 3\n\n-- partial application 2\nadd'' y = add (1, y)\nadd'' 2 -- 3\n"})}),"\n",(0,i.jsx)(n.h3,{id:"polymorphic-types",children:"Polymorphic Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"fst :: (a, b) -> a\nhead :: [a] -> a\ntake :: Int -> [a] -> [a]\nzip :: [a] -> [b] -> [(a, b)]\nid :: a -> a\n"})}),"\n",(0,i.jsx)(n.h4,{id:"type-variable",children:"Type Variable"}),"\n",(0,i.jsx)(n.p,{children:"must begin with a lower-case letter"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"length :: [a] -> Int\n"})}),"\n",(0,i.jsx)(n.h3,{id:"overloaded-types",children:"Overloaded Types"}),"\n",(0,i.jsx)(n.p,{children:"contains one or more class constraints"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"(+) :: Num a => a -> a -> a\nnegate :: Num a => a -> a\nabs :: Num a => a -> a\n"})}),"\n",(0,i.jsx)(n.h4,{id:"class-constraint",children:"Class Constraint"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"-- C: class name\n-- a: type variable (an assined type to `a` is called `instance` of class `C`)\nC a\n"})}),"\n",(0,i.jsx)(n.h2,{id:"classes",children:"Classes"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"class"})," is a collection of types that support certain overloaded operatoins; ",(0,i.jsx)(n.em,{children:"methods"})," (e.g. ",(0,i.jsx)(n.code,{children:"(==), (/=)"})," in Eq)"]}),"\n",(0,i.jsx)(n.h3,{id:"eq---equality-types",children:"Eq - equality types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"(==) :: a -> a -> Bool\n(/=) :: a -> a -> Bool\n"})}),"\n",(0,i.jsxs)(n.p,{children:["All the basic types Bool, Char, String, Int, Integer, Float and Double are instances of the Eq class.",(0,i.jsx)(n.br,{}),"\n","As are list and tuple types, provided that element and component types of the basic types are instances."]}),"\n",(0,i.jsx)(n.h3,{id:"ord---ordered-types",children:"Ord - ordered types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"(<) :: a -> a -> Bool\n(<=) :: a -> a -> Bool\n(>) :: a -> a -> Bool\n(>=) :: a -> a -> Bool\nmin :: a -> a -> a\nmax :: a -> a -> a\n"})}),"\n",(0,i.jsx)(n.h3,{id:"show---showable-types",children:"Show - showable types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"show :: a -> String\n"})}),"\n",(0,i.jsx)(n.h3,{id:"read---readable-types",children:"Read - readable types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"read :: String -> a\n"})}),"\n",(0,i.jsx)(n.h3,{id:"num---numeric-types",children:"Num - numeric types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"(+) :: a -> a -> a\n(-) :: a -> a -> a\n(*) :: a -> a -> a\nnegate :: a -> a\nabs :: a -> a signum :: a -> a\n"})}),"\n",(0,i.jsx)(n.h3,{id:"integral---integral-types",children:"Integral - integral types"}),"\n",(0,i.jsxs)(n.p,{children:["Types to support the methods of integer division and integer remainder.\n",(0,i.jsx)(n.em,{children:"Int"})," and ",(0,i.jsx)(n.em,{children:"Integer"})," are ",(0,i.jsx)(n.em,{children:"instances"})," of ",(0,i.jsx)(n.em,{children:"Integral"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"div :: a -> a -> a\nmod :: a -> a -> a\n"})}),"\n",(0,i.jsx)(n.h3,{id:"fractional---fractional-types",children:"Fractional - fractional types"}),"\n",(0,i.jsx)(n.p,{children:"support the methods of fractional division and fractinal reciprocation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"(/) :: a -> a -> a\nrecip :: a -> a\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"> 7.0 / 2.0\n3.5\n\n> recip 2.0\n0.5\n"})}),"\n",(0,i.jsx)(n.h2,{id:"definning-functions",children:"Definning Functions"}),"\n",(0,i.jsx)(n.h3,{id:"conditional-expressions",children:"Conditional Expressions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"abs :: Int -> Int\nabs n = if n >= 0 then n else -n\n\nsignum :: Int -> Int\nsignum n = if n < 0 then -1 else\n  if n == 0 then 0 else 1\n"})}),"\n",(0,i.jsx)(n.h3,{id:"guarded-equations",children:"Guarded Equations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"abs n\n  | n >= 0 = n\n  | otherwise = - n\n\nsignum n\n  | n < 0 = -1\n  | n == 0 = 0\n  | otherwise = 1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The symbol ",(0,i.jsx)(n.code,{children:"|"})," is read as ",(0,i.jsx)(n.em,{children:"such that"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"pattern-matching",children:"Pattern matching"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"not :: Bool -> Bool\nnot False = True\nnot True = False\n\n(&&) :: Bool -> Bool -> Bool\nTrue && True = True\n_ && _ = False\n"})}),"\n",(0,i.jsx)(n.h4,{id:"tuple-patterns",children:"Tuple Patterns"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"fst :: (a, b) -> a\nfst (x, _) = x\n\nsnd :: (a, b) -> b\nsnd (_, y) = y\n"})}),"\n",(0,i.jsx)(n.h4,{id:"list-patterns",children:"List Patterns"}),"\n",(0,i.jsx)(n.p,{children:"matches any list of the same length whose elements all match the corresponding patterns in order."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"test :: [Char] -> Bool\ntest ['a', _, _] = True\ntest _ = False\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"cons"})," operator ",(0,i.jsx)(n.code,{children:":"})," prepends a new element to an existing list."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"[1, 2, 3]\n= 1:[2, 3]\n= 1:(2:[3])\n= 1:(2:(3:[]))\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"test :: [Char] -> Bool\ntest ('a':_) = True\ntest _ = False\n\nhead :: [a] -> a\nhead (x:_) = x\n\ntail :: [a] -> [a]\ntail (_:xs) = xs\n"})}),"\n",(0,i.jsx)(n.h3,{id:"lambda-expressions",children:"Lambda Expressions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"\\x -> x + x\n\n> (\\x -> x + x) 2\n4\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"add :: Int -> Int -> Int\nadd x y = x + y\nadd = \\x -> (\\y -> x + y)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"const :: a -> b -> a\nconst x _ = x\nconst x = \\_ -> x\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"odds :: Int -> [Int]\nodds n = map f [0..n-1]\n  where f x = x * 2 + 1\nodds n = map (\\x -> x * 2 + 1) [0..n-1]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"operator-sections",children:"Operator Sections"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"operators: functions with two arguments"}),"\n",(0,i.jsxs)(n.li,{children:["sections: operators formed as ",(0,i.jsx)(n.code,{children:"(#)"}),", ",(0,i.jsx)(n.code,{children:"(x #)"}),", or so"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"(#) = \\x -> (\\y -> x # y)\n(x #) = \\y -> x # y\n(# y) = \\x -> x # y\n"})}),"\n",(0,i.jsx)(n.h2,{id:"list-comprehensions",children:"List Comprehensions"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mo,{stretchy:"false",children:"{"}),(0,i.jsxs)(n.msup,{children:[(0,i.jsx)(n.mi,{children:"x"}),(0,i.jsx)(n.mn,{children:"2"})]}),(0,i.jsx)(n.mi,{mathvariant:"normal",children:"\u2223"}),(0,i.jsx)(n.mi,{children:"x"}),(0,i.jsx)(n.mo,{children:"\u2208"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"{"}),(0,i.jsx)(n.mn,{children:"1..5"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"}"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"}"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\{x^2 | x \\in \\{ 1 .. 5 \\} \\}"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mopen",children:"{"}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord mathnormal",children:"x"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsx)(n.span,{className:"vlist-t",children:(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,i.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mtight",children:"2"})})]})})})})})]}),(0,i.jsx)(n.span,{className:"mord",children:"\u2223"}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"x"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"\u2208"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mopen",children:"{"}),(0,i.jsx)(n.span,{className:"mord",children:"1..5"}),(0,i.jsx)(n.span,{className:"mclose",children:"}}"})]})]})]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"xs = [x^2 | x <- [1..5]]  -- [1, 4, 9, 16, 25]\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"|"}),": ",(0,i.jsx)(n.em,{children:"such that"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<-"}),": ",(0,i.jsx)(n.em,{children:"drawn from"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"x <- [1..5]"}),": ",(0,i.jsx)(n.strong,{children:"generator"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"xs2 = [(x, y) | x <- [1, 2, 3,], y <- [4, 5]]\n-- [(1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]\n\nxs3 = [(x, y) | y <- [4, 5], x <- [1, 2, 3]]\n-- [(1, 4), (2, 4), (3, 4), (1, 5), (2, 5), (3, 5)]\n\nxs4 = [(x, y) | x <- [1..3], y <- [x..3]]\n-- [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"concat :: [[a]] -> [a]\nconcat xss = [x | xs <- xss, x <- xs]\n\nfirsts :: [(a, b)] -> [a]\nfirsts ps = [x | (x, _) <- ps]\n\nlength :: [a] -> Int\nlength xs = sum [1 | _ <- xs]\n\n\nmain = do\n  print (concat [[1, 2, 3], [4, 5, 6]]) -- [1,2,3,4,5,6]\n  print ([1, 2, 3] ++ [4, 5, 6]) -- [1,2,3,4,5,6]\n  print (firsts [(1, 2), (3, 4), (5, 6)]) -- [1, 3, 5]\n  print (length [1, 2, 3]) -- 3\n"})}),"\n",(0,i.jsx)(n.h3,{id:"guard",children:"Guard"}),"\n",(0,i.jsx)(n.p,{children:"expressions to filter generated values"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"evens :: Integral a => a -> [a]\nevens n = [x | x <- [0 .. n], even x]\n\nfactors :: Integral a => a -> [a]\nfactors n = [x | x <- [1 .. n], n `mod` x == 0]\n\nprime :: Integral a => a -> Bool\nprime n = factors n == [1, n]\n{- Note:\n  Deciding that a number is prime does not require \n  the `prime` to produce all of its factors, \n  because under lazy evaluation the result `False` is returned \n  as soon as any factor other than one or the number itself is produced.\n  e.g. `prime 15` returns `False` when 3 in its factors `[1, 3, 5, 15]` is produced in `factors`.\n-}\n\nprimes :: Integral a => a -> [a]\nprimes n = [x | x <- [2 .. n], prime x]\n\nfind :: Eq a1 => a1 -> [(a1, a2)] -> [a2]\nfind k t = [v | (k', v) <- t, k == k']\n\nmain = do\n  print (evens 10) -- [0,2,4,6,8,10]\n  print (factors 12) -- [1,2,3,4,6,12]\n  print (prime 15) -- False\n  print (prime 7) -- True\n  print (primes 40) -- [2,3,5,7,11,13,17,19,23,29,31,37]\n  print (find 'b' [('a', 1), ('b', 2), ('c', 3), ('b', 4)]) -- [2, 4]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"zip-function",children:"zip function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"pairs :: [b] -> [(b, b)]\npairs xs = zip xs (tail xs)\n\nsorted :: Ord a => [a] -> Bool\nsorted xs = and [x <= y | (x, y) <- pairs xs]\n\npositions :: (Num a1, Enum a1, Eq a2) => a2 -> [a2] -> [a1]\npositions x xs = [i | (x', i) <- zip xs [0 ..], x == x']\n\nmain = do\n  print (zip ['a', 'b', 'c'] [1, 2, 3, 4]) -- [('a',1),('b',2),('c',3)]\n  print (pairs [1, 2, 3, 4]) -- [(1,2),(2,3),(3,4)]\n  print (sorted [1, 2, 3, 4]) -- True\n  print (sorted [1, 3, 2, 4]) -- False\n  print (positions False [True, False, True, False]) -- [1, 3]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"string-comprehensions",children:"String comprehensions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"String"})," is a list of ",(0,i.jsx)(n.em,{children:"Char"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"lowers :: [Char] -> Int\nlowers xs = length [x | x <- xs, x >= 'a' && x <= 'z']\n\ncount :: Eq a => a -> [a] -> Int\ncount x xs = length [x' | x' <- xs, x == x']\n\nmain = do\n  print (\"abcde\" !! 2) -- 'c'\n  print (take 3 \"abcde\") -- \"abc\"\n  print (length \"abcde\") -- 5\n  print (zip \"abc\" [1, 2, 3, 4]) -- [('a',1),('b',2),('c',3)]\n\n  print (lowers \"Haskell\") -- 6\n  print (count 's' \"Mississippi\") -- 4\n"})}),"\n",(0,i.jsx)(n.h2,{id:"recursive-functions",children:"Recursive Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"fac :: Int -> Int\nfac 0 = 1\nfac n = n * fac (n - 1)\n\n(*) :: Int -> Int -> Int\nm * 0 = 0\nm * n = m + (m * (n - 1))\n"})}),"\n",(0,i.jsx)(n.h3,{id:"recursion-on-lists",children:"Recursion on Lists"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"product :: Num a => [a] -> a\nproduct [] = 1\nproduct (n:ns) = n * product ns\n\nlength :: [a] -> Int\nlength [] = 1\nlength (_:xs) = 1 + length xs\n\nreverse :: [a] -> a\nreverse [] = []\nreverse (x:xs) = reverse xs ++ [x]\n\n(++) :: [a] -> [a] -> [a]\n[] ++ ys = ys\n(x:xs) ++ ys = x:(xs ++ ys)\n\ninsert :: Ord a => a -> [a] -> [a]\ninsert x [] = [x]\ninsert x (y:ys)\n  | x <= y = x:y:ys\n  | otherwise = y:insert x ys\n\n-- insertion sort\nisort :: Ord a => [a] -> [a]\nisort [] = []\nisort (x:xs) = insert x (isort xs)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"multiple-arguments",children:"Multiple Arguments"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"zip :: [a] -> [a] -> [(a, b)]\nzip [] _ = []\nzip _ [] = []\nzip (x:xs) (y:ys) = (x, y):zip xs ys\n\ndrop :: Int -> [a] -> [a]\ndrop 0 xs = xs\ndrop _ [] = []\ndrop n (x:xs) = drop (n - 1) xs\n"})}),"\n",(0,i.jsx)(n.h3,{id:"multiple-recursion",children:"Multiple Recursion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"fib :: Int -> Int\nfib 0 = 0\nfib 1= 1\nfib n = fib (n - 2) + fib (n - 1)\n\nqsort :: Ord a => [a] -> [a]\nqsort [] = []\nqsort (x:xs) = qsort smaller ++ [x] ++ qsort larger\n  where \n    smaller = [a | a <- xs, a <= x]\n    larger = [b | b <- xs, b > x]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"mutual-recursion",children:"Mutual Recursion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"even :: Int -> Bool\neven 0 = True\neven n = odd (n - 1)\n\nodd :: Int -> Bool\nodd 0 = False\nodd n = even (n - 1)\n\n\nevens :: [a] -> [a]\nevens [] = []\nevens (x:xs) = x:odds xs\n\nodds :: [a] -> [a]\nodds [] = []\nodds (_:xs) = evens xs\n"})}),"\n",(0,i.jsx)(n.h3,{id:"generalizing-and-simplifying",children:"Generalizing and Simplifying"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- before\nproduct :: Num a => [a] -> a\nproduct [] = 1\nproduct (n:ns) = n * product ns\n\n-- after\nproduct :: Num a => [a] -> a\nproduct = foldr (*) 1\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- before\ninit :: [a] -> [a]\ninit (x:xs)\n  | null xs = []\n  | otherwise = x:init xs\n\n-- after\ninit :: [a] -> [a]\ninit [_] = []\ninit (x:xs) = x:init xs\n"})}),"\n",(0,i.jsx)(n.h2,{id:"higher-order-functions",children:"Higher-Order Functions"}),"\n",(0,i.jsx)(n.p,{children:"Functions that take a function as an argument or return a function as a result"}),"\n",(0,i.jsx)(n.h3,{id:"processing-lists",children:"Processing Lists"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- list conprehension ver.\nmap :: (a -> b) -> [a] -> [b]\nmap f xs = [f x | x <- xs]\n\n-- recursive ver.\nmap :: (a -> b) -> [a] -> [b]\nmap f [] = []\nmap f (x : xs) = f x : map f xs\n\n\n-- list conprehension ver.\nfilter :: (a -> Bool) -> [a] -> [a]\nfilter p xs = [x | x <- xs, p x]\n\n-- recursive ver.\nfilter :: (a -> Bool) -> [a] -> [a]\nfilter p [] = []\nfilter p (x : xs)\n  | p x = x : filter p xs\n  | otherwise = filter p xs\n\n\nmain = do\n  print (all even [2, 4, 6, 8]) -- True\n  print (any odd [2, 4, 6, 8]) -- False\n  print (takeWhile even [2, 4, 6, 7, 8]) -- [2, 4, 6]\n  print (dropWhile odd [1, 3, 5, 6, 7]) -- [6, 7]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"foldr",children:"foldr()"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"foldr (#) v [x0, x1, ..., xn] = x0 # (x1 # (... (xn # v)))\n\nf v\n\n-- recursive ver.\nfoldr :: (a -> b -> b) -> b -> [a] -> b\nfoldr f v [] = v\nfoldr f v (x : xs) = f x (foldr f v xs)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"sum :: Num a => [a] -> a\n-- sum [] = 0\n-- sum (x : xs) = x + sum(xs)\nsum = foldr (+) 0\n\nproduct :: Num a => [a] -> a\nproduct = foldr (*) 1\n\nor :: [Bool] -> Bool\nor = foldr (||) False\n\nand :: [Bool] -> Bool\nand = foldr (&&) True\n\nlength :: [a] -> Int\n-- length [] = 0\n-- length (_:xs) = 1 + length xs\nlength = foldr (\\_ n -> 1 + n) 0\n\n\n-- snoc is `cons` backwards\nsnoc :: a -> [a] -> [a]\nsnoc x xs = xs ++ [x]\n\nreverse :: [a] -> [a]\n-- reverse [] = []\n-- reverse (x : xs) = reverse xs ++ [x]\nreverse :: [a] -> [a]\nreverse = foldr snoc []\n"})}),"\n",(0,i.jsx)(n.h3,{id:"foldl",children:"foldl()"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"v"})," is ",(0,i.jsx)(n.em,{children:"accumlator"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"foldl (#) v [x0, x1, ..., xn] = (((v # x0) # x1)...) # xn\n\n-- recursive ver.\nfoldl :: (a -> b -> a) -> a -> [b] -> a\nfoldl f v [] = v\nfold f v (x : xs) = foldl f (v + x) xs\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"sum' :: Num a => [a] -> a\nsum' = sum'' 0\n  where\n    sum'' v [] = v\n    sum'' v (x : xs) = sum'' (v + x) xs\n\nsum :: Num a => [a] -> a\nsum = foldl (+) 0\n\nproduct :: Num a => [a] -> a\nproduct = foldl (*) 1\n\nor :: [Bool] -> Bool\nor = foldl (||) False\n\nand :: [Bool] -> Bool\nand = foldr (&&) True\n\nlength :: [a] -> Int\nlength = foldl (\\n _ -> n + 1) 0\n\nreverse :: [a] -> [a]\nreverse = foldl (\\xs x -> x : xs) []\n"})}),"\n",(0,i.jsx)(n.h3,{id:"composition-operator",children:"Composition Operator"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"f . g"})," is read as ",(0,i.jsx)(n.em,{children:"f composed with g"})," ."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"(.) :: (b -> c) -> (a -> b) -> (a -> c)\nf . g = \\x -> f (g x)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- odd n = not (even n)\nodd = not . even\n\n-- twice f x = f (f x)\ntwice = f . f\n\n-- sumsqreven ns = sum (map (^2) (filter even ns))\nsumsqreven = sum . map (^2) . filter even\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- identity function; id.f = f, f.id = f\nid :: a -> a\nid = \\x -> x\n\ncompose :: [a -> a] -> (a -> a)\ncompose = foldr (.) id  -- make the composition of a list of functions\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- produces an infinite list\niterate f x = [x, f x, f(f x), f(f(f x)), ...]\n\niterate (*2) 1  -- [1, 2, 4, 8, ...]\n\n\n-- repeat :: a -> [a]: procudes an infinite list of copies of a value\nrepeat 0  -- [0, 0, 0, 0, ...]\ntake 8 (repeat 0) -- [0, 0, 0, 0, 0, 0, 0, 0] -- lazy evaluation\n"})}),"\n",(0,i.jsx)(n.h2,{id:"type-declarations",children:"Type Declarations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"type String = [Char]\n\ntype Pos = (Int, Int)\ntype Trans = Pos -> Pos\n\ntype Pair a = (a, a)\ntype Assoc k v = [(k, v)]\n\nfind :: Eq k => k -> Assoc k v -> v\nfind k t = head [v | (k', v) <- t, k == k']\n"})}),"\n",(0,i.jsx)(n.h2,{id:"data-declarations",children:"Data Declarations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"|"})," is read as ",(0,i.jsx)(n.em,{children:"or"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"constructors"})," new values of the type (e.g. ",(0,i.jsx)(n.code,{children:"False"})," and ",(0,i.jsx)(n.code,{children:"True"})," are constructors of ",(0,i.jsx)(n.em,{children:"Bool"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"data Bool = False | True\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"data Move = North | South | East | West\n\nmove :: Move -> Pos -> Pos\nmove North (x, y) = (x, y + 1)\nmove South (x, y) = (x, y - 1)\nmove East (x, y) = (x + 1, y)\nmove West (x, y) = (x - 1, y)\n\nmoves :: [Move] -> Pos -> Pos\nmoves [] p = p\nmoves (m : ms) p = moves ms (move m p)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"cosntructor-functions",children:"Cosntructor Functions"}),"\n",(0,i.jsx)(n.h4,{id:"vs-normal-functions",children:"vs. normal functions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"have no defining equations and exist as data"}),"\n",(0,i.jsxs)(n.li,{children:["e.g.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"negate 1.0"})," can be evaluated to -1.0 by definition of negate"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Circle 1.0"})," is already fully evaluated and cannot be further simplified"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- Circle :: Float -> Shape\n-- Rect :: Float -> Float -> Shape\ndata Shape = Circle Float | Rect Float Float\n\nsquare :: Float -> Shape\nsquare n = Rect n n\n\narea :: Shape -> Float\narea (Circle r) = pi * r ^ 2\narea (Rect x y) = x * y\n"})}),"\n",(0,i.jsx)(n.p,{children:"type as a argument"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"data Maybe a = Nothing | Just a\n\nsafediv :: Int -> Int -> Maybe Int\nsafediv _ 0 = Nothing\nsafediv m n = Just (m `div` n)\n\nsafehead :: [a] -> Maybe a\nsafehead [] = Nothing\nsafehead xs = Just (head xs)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"newtype-declarations",children:"Newtype Declarations"}),"\n",(0,i.jsxs)(n.p,{children:["newtype declarations are to improve type safety without affecting perfomance.",(0,i.jsx)(n.br,{}),"\n","it must have ",(0,i.jsx)(n.em,{children:"Constructor"})," such as ",(0,i.jsx)(n.code,{children:"N"})," in below example."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"newtype Nat = N Int\n\ntype Nat = Int\ndata Nat = N Int\n"})}),"\n",(0,i.jsx)(n.h4,{id:"vs-type",children:"vs. type"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Using newtype rather than type means that ",(0,i.jsx)(n.code,{children:"Nat"})," and ",(0,i.jsx)(n.code,{children:"Int"})," are different types rather than synonyms"]}),"\n",(0,i.jsx)(n.li,{children:"The type system of Haskell ensures that they cannot accidentally be mixed up in programs"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"vs-data",children:"vs. data"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Using newtype rather than data brings an efficiency benefit"}),"\n",(0,i.jsxs)(n.li,{children:["newtype constructors such as ",(0,i.jsx)(n.code,{children:"N"})," do not incur any cost when programs are evaluated, as they are automatically removed by the compiler once type checking is completed"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"recursive-types",children:"Recursive Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"data Nat = Zero | Succ Nat\n\nnat2int :: Nat -> Int\nnat2int Zero = 0\nnat2int (Succ n) = 1 + nat2int n\n\nint2nat :: Int -> Nat\nint2nat 0 = Zero\nint2nat n = Succ (int2nat (n - 1))\n\nadd :: Nat -> Nat -> Nat\nadd m n = int2nat (nat2int m + nat2int n)\n\nadd' :: Nat -> Nat -> Nat\nadd' Zero n = n\nadd' (Succ m) n = Succ (add' m n)\n\n\n{- e.g. 2 + 1\n    add (Succ (Succ Zero)) (Succ Zero)\n  = (Succ add (Succ Zero) (Succ Zero))\n  = Succ (Succ (add Zero (Succ Zero)))\n  = Succ (Succ (Succ Zero))\n-}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"data Tree a = Leaf a | Node (Tree a) a (Tree a)\n\nt :: Tree Int\nt = Node (Node (Leaf 1) 3 (Leaf 4)) 5 (Node (Leaf 6) 7 (Leaf 9))\n\nflatten :: Tree a -> [a]\nflatten (Leaf x) = [x]\nflatten (Node l x r) = flatten l ++ [x] ++ flatten r\n\noccurs :: Eq a => a -> Tree a -> Bool\noccurs x (Leaf y) = x == y\noccurs x (Node l y r) = x == y || occurs x l || occurs x r\n\noccurs' :: Ord a => a -> Tree a -> Bool\noccurs' x (Leaf y) = x == y\noccurs' x (Node l y r)\n  | x == y = True\n  | x < y = occurs' x l\n  | otherwise = occurs' x r\n"})}),"\n",(0,i.jsx)(n.h2,{id:"class-and-instance-declarations",children:"Class and Instance Declarations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["type ",(0,i.jsx)(n.code,{children:"a"})," is an instance of the class ",(0,i.jsx)(n.code,{children:"Eq"})]}),"\n",(0,i.jsxs)(n.li,{children:["types of instance must support functions; ",(0,i.jsx)(n.code,{children:"(==)"}),", ",(0,i.jsx)(n.code,{children:"(/=)"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(/=)"})," is defined as ",(0,i.jsx)(n.em,{children:"default definition"}),", so declaring an instance only requires a definition of ",(0,i.jsx)(n.code,{children:"(==)"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"class Eq a where\n  (==), (/=) :: a -> a -> Bool\n  x /= y = not (x == y)\n\ninstance Eq Bool where\n  False == False = True\n  True == True = True\n  _ == _ = False\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["type ",(0,i.jsx)(n.code,{children:"a"})," to be instance of class ",(0,i.jsx)(n.code,{children:"Ord"})," must be an instance of class ",(0,i.jsx)(n.code,{children:"Eq"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"class Eq a => Ord a where\n  (<), (<=), (>), (>=) :: a -> a -> Bool\n  min, max :: a -> a -> a\n  min x y\n    | x <= y = x\n    | otherwise = y\n  max x y\n    | x <= y = y\n    | otherwise = x\n\ninstance Ord Bool where\n  False < True = True\n  _ < _ = False\n\n  b <= c = (b < c) || (b == c)\n  b > c = c < b\n  b >= c = c <= b\n"})}),"\n",(0,i.jsx)(n.h2,{id:"derived-instances",children:"Derived Instances"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"data Bool = False | True  -- this order is reflected on False < True\n  deriving (Eq, Ord, Show, Read)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"interactive-programming",children:"Interactive Programming"}),"\n",(0,i.jsx)(n.p,{children:"Interactive programs has side effects such as additional inputs and outputs while the program is running."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"interactive_program",src:s(6165).A+"",width:"455",height:"246"})}),"\n",(0,i.jsxs)(n.p,{children:["Haskell treats an interactive program as a pure function that takes the current ",(0,i.jsx)(n.em,{children:"state of world"})," as its arguments, and produces a modified world as its result"]}),"\n",(0,i.jsxs)(n.p,{children:["Expressions of type IO a are called ",(0,i.jsx)(n.em,{children:"actions"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"type IO Char: type of actions that return a character"}),"\n",(0,i.jsxs)(n.li,{children:["type IO (): type of actions that return the empty tuple ",(0,i.jsx)(n.code,{children:"()"})," as a dummy result value"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"type IO = World -> World\n\ntype IO a = World -> (a, World)\n\ntype Char -> IO Int -- means type Char -> World -> (Int, World)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"basic-actions",children:"Basic Actions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"getChar :: IO Char\n\nputChar :: Char -> IO ()\n\nreturn :: a -> IO a\n"})}),"\n",(0,i.jsx)(n.h3,{id:"sequencing",children:"Sequencing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<-"})," is called ",(0,i.jsx)(n.em,{children:"generator"})," as with list comprehensions","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["if a value generated by ",(0,i.jsx)(n.code,{children:"ai"})," is unnecessary, generator is abbreviated by ",(0,i.jsx)(n.code,{children:"ai"})," which means ",(0,i.jsx)(n.code,{children:"_ <- ai"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"do v1 <- a1\n   v2 <- a2\n   ...\n   vn <- an\n   return (f v1 v2 ... vn)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"act :: IO (Char, Char)\nact = do x <- getChar\n         getChar\n         y <- getChar\n         return (x, y)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"derived-primitives",children:"Derived primitives"}),"\n",(0,i.jsx)(n.p,{children:"action primitives in the standard prelude"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["getLine: read chars until ",(0,i.jsx)(n.code,{children:"\\n"})]}),"\n",(0,i.jsxs)(n.li,{children:["putStr: without ",(0,i.jsx)(n.code,{children:"\\n"})]}),"\n",(0,i.jsxs)(n.li,{children:["putStrLn: with ",(0,i.jsx)(n.code,{children:"\\n"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"getLine :: IO String\ngetLine = do x <- getChar\n             if x == '\\n' then\n                return []\n             else\n                do xs <- getLine\n                   return (x : xs)\n\n\nputStr :: String -> IO ()\nputStr [] = return ()\nputStr (x : xs) = do putChar x\n                     putCStr xs\n\n\nputStrLn :: String -> IO ()\nputStrLn xs = do putStr xs\n                 putChar '\\n'\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:'strlen :: IO ()\nstrlen = do putStr "Enter a string: "\n            xs <- getLine\n            putStr "The string has "\n            putStr (show (length xs))\n            putStrLn " characters"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"functors",children:"Functors"}),"\n",(0,i.jsx)(n.p,{children:"class of types that support a mapping function."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"class Functor f where\n  fmap :: (a -> b) -> f a -> f b\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fmap"})," takes a function of type ",(0,i.jsx)(n.code,{children:"a -> b"})," and a structure of type ",(0,i.jsx)(n.code,{children:"f a"})," whose elements have type ",(0,i.jsx)(n.code,{children:"a"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fmap"})," applies the function to each element to give a structure of type ",(0,i.jsx)(n.code,{children:"f b"})," whose elements have type ",(0,i.jsx)(n.code,{children:"b"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"instance Functor [] where\n  -- fmap :: (a -> b) -> [a] -> [b]\n  fmap = map\n\n\ninstance Functor Maybe where\n  -- fmap :: (a -> b) -> Maybe a -> Maybe b\n  fmap _ Nothing = Nothing\n  fmap g (Just x) = Just (g x)\n\nfmap (+1) Nothing     -- Nothing\nfmap (*2) (Just 3)    -- Just 6\nfmap not (Just False) -- Just True\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:'data Tree a = Leaf | Node (Tree a) (Tree a)\n  deriving Show\n\ninstance Functor Tree where\n  -- fmap :: (a -> b) -> Tree a -> Tree b\n  fmap g (Leaf x) = Leaf (g x)\n  fmap g (Node l r) = Node (fmap g l) (fmap g r)\n\nfmap length (Leaf "abc")  -- Leaf 3\nfmap even (Node (Leaf 1) (Leaf 2))  -- Node (Leaf False) (Leaf True)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:'instance Functor IO where\n  -- fmap :: (a -> b) -> IO a -> IO b\n  fmap g mx = do {x <- mx; return (g x)}\n\nfmap show (return True) -- "True"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"inc :: [Int] -> [Int]\ninc = map (+ 1)\n\ninc' :: Functor f => f Int -> f Int\ninc' = fmap (+ 1)\n\ninc' (Just 1) -- Just 2\ninc' [1, 2, 3, 4, 5]  -- [2, 3, 4, 5, 6]\ninc' (Node (Leaf 1) (Leaf 2)) -- Node (Leaf 2) (Leaf 3)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"functor-laws",children:"Functor Laws"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"fmap id = id\nfmap (g . h) = fmap g . fmap h\n"})}),"\n",(0,i.jsx)(n.h2,{id:"applicatives",children:"Applicatives"}),"\n",(0,i.jsx)(n.h3,{id:"applicative-functors-applicative",children:"applicative functors; applicative"}),"\n",(0,i.jsxs)(n.p,{children:["the class of functors that support ",(0,i.jsx)(n.code,{children:"pure"})," and ",(0,i.jsx)(n.code,{children:"<*>"})," functions"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"class Functor f => Applicative f where\n  pure :: a -> f a\n  (<*>) :: f (a -> b) -> f a -> f b\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"pure :: a -> f a\n(<*>) :: f (a -> b) -> f a -> f b\n\nfmap0 :: a -> f a\nfmap0 = pure\n\nfmap1 :: (a -> b) -> f a -> f b\nfmap1 = pure g <*> x\n\nfmap2 :: (a -> b -> c) -> f a -> f b -> f c\nfmap2 = pure g <*> x <*> y\n\nfmap3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d\nfmap3 = pure g <*> x <*> y <*> z\n\n...\n\n\n-- type check. fmap2\n-- f (a -> b -> c) -> f a -> f (b -> c)\n--     pure g     <*>  x  =      x'\n\n-- f (b -> c) -> f b -> f c\n--      x'   <*> y  =  res\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The applicative style for ",(0,i.jsx)(n.em,{children:"Maybe"})," supports a form of ",(0,i.jsx)(n.em,{children:"exceptional"})," programming in which we can apply pure functions to arguments that may fail without the need to manage the propagation of failure ourselves."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"instance Applicative Maybe where\n  -- pure :: a -> Maybe a\n  pure = Just\n\n  -- (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b\n  Nothing <*> _ = Nothing\n  (Just g) <*> mx = fmap g mx\n\npure (+ 1) <*> Just 1           -- Just 2\npure (+) <*> Just 1 <*> Just 2  -- Just 3\npure (+) <*> Nothing <*> Just 2 -- Nothing\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The applicative sytle for lists supports a form of ",(0,i.jsx)(n.em,{children:"non-deteministic"})," programming in which we can apply pure functions to multi-valued arguments without the need to manage the selection of values or the propagation of failure."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"instance Applicative [] where\n  -- pure :: a -> [a]\n  pure x = [x]\n\n  -- (<*>) :: [a -> b] -> [a] -> [b]\n  gs <*> xs = [g x | g <- gs, x <- xs]\n\npure (+ 1) <*> [1, 2, 3]        -- [2, 3, 4]\npure (+) <*> [1] <*> [2]        -- [3]\npure (*) <*> [1, 2] <*> [3, 4]  -- [3, 4, 6, 8]\n\nprods :: [Int] -> [Int] -> [Int]\nprods xs ys = [x * y | x <- xs, y <- ys]\n\nprods' :: [Int] -> [Int] -> [Int]\nprods' xs ys = pure (*) <*> xs <*> ys\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The applicative style for IO supports a form of ",(0,i.jsx)(n.em,{children:"interactive"})," programming in which we can apply pure functions to impure arguments without the need to manage the sequencing of actions or the extranction of result values."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"instance Applicative IO where\n  -- pure :: a -> IO a\n  pure = return\n\n  -- (<*>) :: IO (a -> b) -> IO a -> IO b\n  mb <*> mx = do {g <- mg; x <- mx; return (g x)}\n\ngetChars :: Int -> IO String\ngetChars 0 = return []\ngetChars n = pure (:) <*> getChar <*> getChars (n - 1)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"sequenceA :: Applicative f => [f a] -> f [a]\nsequenceA [] = pure []\nsequenceA (x : xs) = pure (:) <*> x <*> sequecneA xs\n\ngetChars :: Int -> IO String\ngetChars n = sequenceA (replicate n getChar)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"applicative-laws",children:"Applicative Laws"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"pure id <*> x = x -- pure is complemented\npure (g x) = pure g <*> pure x  -- occurences of pure can be combined into one\nx <*> pure y = pure (\\g -> g y) <*> x -- the order in which we evaluate the two components doesn't matter\nx <*> (y <*> z) = (pure (.) <*> x <*> y) <*> z  -- <*> is associative\n"})}),"\n",(0,i.jsx)(n.p,{children:"these laws ensure that below expression is evaluated  uniquely."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"pure g <*> x1 <*> x2 <*> ... <*> xn\n"})}),"\n",(0,i.jsx)(n.h3,{id:"infix-ver",children:"Infix ver."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"fmap g x = pure g <*> x\ng <$> x = fmap g x\n\ng <$> x1 <*> x2 <*> ... <*> xn\n"})}),"\n",(0,i.jsx)(n.h2,{id:"monads",children:"Monads"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"class Applicative m => Monad m where\n  return :: a -> m a\n  (>>=) :: m a -> (a -> m b) -> m b\n\n  return = pure\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"-operator",children:[(0,i.jsx)(n.code,{children:">>="})," operator"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["called ",(0,i.jsx)(n.em,{children:"bind"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["ensures that such an expression only succeeds if every component ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsxs)(n.msub,{children:[(0,i.jsx)(n.mi,{children:"m"}),(0,i.jsx)(n.mi,{children:"i"})]})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"m_i"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord mathnormal",children:"m"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(n.span,{className:"vlist-r",children:[(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.3117em"},children:(0,i.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mathnormal mtight",children:"i"})})]})}),(0,i.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,i.jsx)(n.span,{})})})]})})]})]})})]})," in the sequence succeeds"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\nmx >>= f = case mx of\n  Nothing -> Nothing\n  Just x -> f x\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- Notation 1\nm1 >>= \\x1 ->\nm2 >>= \\x2 ->\n...\nmn >>= \\xn ->\nf x1 x2 ... xn\n\n-- Notation 2\ndo x1 <- m1\n   x2 <- m2\n   ...\n   xn <- mn\n   f x1 x2 ... xn\n"})}),"\n",(0,i.jsx)(n.h3,{id:"monad-laws",children:"Monad Laws"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"return x >>= f = f x  -- (return x) >>= f = f x\nmx >>= return = mx\n(mx >>= f) >>= g = mx >>= (\\x -> (f x >>= g)) -- assosiatative\n"})}),"\n",(0,i.jsx)(n.h3,{id:"usecases",children:"Usecases"}),"\n",(0,i.jsxs)(n.p,{children:["applicative style does not fit the pattern of effectful programming such as the function which is the first argument of ",(0,i.jsx)(n.code,{children:"<*>"})," is not pure function."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["e.g. ",(0,i.jsx)(n.code,{children:"safediv"})," is not a pure function because it returns ",(0,i.jsx)(n.code,{children:"Maybe Int"}),", not ",(0,i.jsx)(n.code,{children:"Int"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"data Expr = Val Int | Div Expr Expr\n\neval :: Expr -> Int\neval (Val n) = n\neval (Div x y) = eval x `div` eval y\n\neval (Div (Val 1) (Val 0))  -- *** Exception: divide by zero\n\n\nsafediv :: Int -> Int -> Maybe Int\nsafediv _ 0 = Nothing\nsafediv n m = Just (n `div` m)\n\neval' :: Expr -> Maybe Int\neval' (Val n) = Just n\neval' (Div x y) = case eval x of\n  Nothing -> Nothing\n  Just n -> case eval y of\n    Nothing -> Nothing\n    Just m -> safediv n m\n\neval' (Div (Val 1) (Val 0)) -- Nothing\n\n\neval' :: Expr -> Maybe Int\neval' (Val n) = pure n\neval' (Div x y) = pure safediv <*> eval x <*> eval y  -- type error\n"})}),"\n",(0,i.jsxs)(n.p,{children:["apply ",(0,i.jsx)(n.em,{children:"monad"})," then"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"instance Monad Maybe where\n  -- (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\n  Nothing >>= _ = Nothing\n  (Just x) >>= f = f x\n\ndata Expr = Val Int | Div Expr Expr\n\nsafediv :: Int -> Int -> Maybe Int\nsafediv _ 0 = Nothing\nsafediv n m = Just (n `div` m)\n\n-- Notation 1\neval :: Expr -> Maybe Int\neval (Val n) = Just n\neval (Div x y) =\n  eval x >>= \\n ->\n    eval y >>= \\m ->\n      safediv n m\n\n-- Notation 2\neval' :: Expr -> Maybe Int\neval' (Val n) = Just n\neval' (Div x y) = do\n  n <- eval' x\n  m <- eval' y\n  safediv n m  \n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"instance Monad [] where\n  -- (>>=) :: [a] -> (a -> [b]) -> [b]\n  xs >>= f = [y | x <- xs, y <- f x]\n\npairs :: [a] -> [b] -> [(a, b)]\npairs xs ys =\n  xs >>= \\x ->\n    ys >>= \\y ->\n      return (x, y)\n\npairs :: [a] -> [b] -> [(a, b)]\npairs xs ys = do\n  x <- xs\n  y <- ys\n  return (x, y)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"the-state-monad",children:"The State Monad"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"type State = Int  -- state is just an integer value but this can be modified as required\n"})}),"\n",(0,i.jsxs)(n.h4,{id:"state-tronsformer-st",children:[(0,i.jsx)(n.em,{children:"state tronsformer"}),"; ",(0,i.jsx)(n.em,{children:"ST"})]}),"\n",(0,i.jsx)(n.p,{children:"takes an input state as its argument and produces an ouptut state as its result"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"type ST = State -> State\ntype ST a = State -> (a, State) -- returns State with an output of type `a`\ntype a -> ST b -- type a -> State -> (b, State)\n-- takes State with an input of type `a` and returns State with an output of type `b`\n"})}),"\n",(0,i.jsxs)(n.p,{children:["we want to make ",(0,i.jsx)(n.em,{children:"ST"})," into a monad but types declared using the type mechanism cannot be made into instances of classes.",(0,i.jsx)(n.br,{}),"\n","so we need to define it using ",(0,i.jsx)(n.em,{children:"newtype"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"newtype ST a = S (State -> (a, State))\n\n-- removes dummy constructor `S`\napp :: ST a -> State -> (a, State)\napp (S st) x = st x\n\n\ninstance Functor ST where\n  -- fmap :: (a -> b) -> ST a -> ST b\n  fmap g st = S (\\s -> let (x, s') = app st s in (g x, s'))\n\ninstance Applicative ST where\n  -- pure :: a -> ST a\n  pure x = S (\\s -> (x, s))\n\n  -- (<*>) :: ST (a -> b) -> ST a -> ST b\n  stf <*> stx =\n    S\n      ( \\s ->\n          let (f, s') = app stf s\n              (x, s'') = app stx s'\n           in (f x, s'')\n      )\n\ninstance Monad ST where\n  -- (>>=) :: ST a -> (a -> ST b) -> ST b\n  st >>= f = S (\\s -> let (x, s') = app st s in app (f x) s')\n"})}),"\n",(0,i.jsx)(n.h3,{id:"generic-functions",children:"Generic Functions"}),"\n",(0,i.jsx)(n.h4,{id:"mapm",children:"mapM()"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- defined in Control.Monad\nmapM :: Monad m => (a -> m b) -> [a] -> m [b]\nmapM f [] = return []\nmapM f (x : xs) = do\n  y <- f x\n  ys <- mapM f xs\n  return (y : ys)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:'import Data.Char\n\nconv :: Char -> Maybe Int\nconv c\n  | isDigit c = Just (digitToInt c)\n  | otherwise = Nothing\n\nmapM conv "1234"  -- Just [1, 2, 3, 4]\nmapM conv "123a"  -- Nothing\n'})}),"\n",(0,i.jsx)(n.h4,{id:"filterm",children:"filterM()"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- defined in Control.Monad\nfilterM :: Monad m => (a -> m Bool) -> [a] -> m [a]\nfilterM p [] = return []\nfilterM p (x : xs) = do\n  b <- p x\n  ys <- filter M p xs\n  return (if b then x : ys else ys)\n\nfilterM (\\x -> [True, False]) [1, 2, 3]\n-- [[1, 2, 3], [1, 2], [1, 3], [1], [2, 3], [2], [3], []]\n"})}),"\n",(0,i.jsx)(n.h4,{id:"join",children:"join()"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"join :: Monad m => m (m a) -> m a\njoin mmx = do\n  mx <- mmx\n  x <- mx\n  return x\n\njoin [[1, 2], [3, 4], [5, 6]] -- [1, 2, 3, 4, 5, 6]\njoin (Just (Just 1))  -- Just 1\njoin (Just Nothing) -- Nothing\njoin Nothing  -- Nothing\n"})}),"\n",(0,i.jsx)(n.h2,{id:"alternative",children:"Alternative"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"class Applicative f => Alternative f where\n  empty :: f a\n  (<|>) :: f a -> f a -> f a\n"})}),"\n",(0,i.jsx)(n.h3,{id:"alternative-laws",children:"Alternative Laws"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"empty <|> x = x\nx <|> empty = x\nx <|> (x <|> y) = (x <|> y) <|> z -- associative\n"})}),"\n",(0,i.jsx)(n.h3,{id:"alternative-instances",children:"Alternative Instances"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"instance Alternative Maybe where\n  -- empty :: Maybe a\n  empty = Nothing\n\n  -- (<|>) :: Maybe a -> Maybe a -> Maybe a\n  Nothing <|> my = my\n  (Just x) <|> _ = Just x\n"})}),"\n",(0,i.jsx)(n.h2,{id:"monoids",children:"Monoids"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"class Monoids a where\n  mempty :: a\n  mappend :: a -> a -> a\n\n  mconcat :: [a] -> a\n  mconcat = foldr mappend mempty\n"})}),"\n",(0,i.jsx)(n.h3,{id:"monoid-laws",children:"Monoid Laws"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"mempty `mappend` x = x\nx `mappend` mempty = x\nx `mappend` (y `mappend` z) = (x `mappend` y) `mappend` z\n\n-- using <> operator\nmempty <> x = x\nx <> mempty = x\nx <> (y <> z) = (x <> y) <> z\n"})}),"\n",(0,i.jsx)(n.h3,{id:"datamonoid",children:"Data.Monoid"}),"\n",(0,i.jsx)(n.h4,{id:"lists",children:"Lists"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"instance Monoid [a] where\n  -- mempty :: [a]\n  mempty = []\n\n  -- (<>) :: [a] -> [a] -> [a]\n  mappend = (++)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"maybe",children:"Maybe"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"instance Monoid a => Monoid (Maybe a) where\n  -- mempty :: Maybe a\n  mempty = Nothing\n\n  -- (<>) :: Maybe a -> Maybe a -> Maybe a\n  Nothing <> my = my\n  mx <> Nothing = mx\n  Just x <> Just y = Just (x <> y)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"sum",children:"Sum"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"newtype Sum a = Sum a\n  deriving (Eq, Ord, Show, Read)\n\ngetSum :: Sum a -> a\ngetSum (Sum x) = x\n\n\ninstance Num a => Monoid (Sum a) where\n  -- mempty :: Sum a\n  mempty = Sum 0\n\n  -- (<>) :: Sum a -> Sum a -> Sum a\n  Sum x <> Sum y = Sum (x + y)\n\n\nmconcat [Sum 2, Sum 3, Sum 4] -- Sum 9\n"})}),"\n",(0,i.jsx)(n.h4,{id:"product",children:"Product"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"newtype Product a = Product a\n  deriving (Eq, Ord, Show, Read)\n\ngetProduct :: Product a -> a\ngetProduct (Product x) = x\n\n\ninstance Num a => Monoid (Product a) where\n  -- mempty :: Product a\n  mempty = Product 1\n\n  -- (<>) :: Product a -> Product a -> Product a\n  Product x <> Product y = Product (x * y)\n\n\nmconcat [Product 2, Product 3, Product 4] -- Product 24\n"})}),"\n",(0,i.jsx)(n.h4,{id:"all",children:"All"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"mconcat [All True, All True, All True]  -- All True\n"})}),"\n",(0,i.jsx)(n.h4,{id:"any",children:"Any"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"mconcat [Any False, Any False, Any False] -- Any False\n"})}),"\n",(0,i.jsx)(n.h2,{id:"foldables",children:"Foldables"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"}),(0,i.jsx)(n.br,{}),"\n","minimal complete definition for an instance of the ",(0,i.jsx)(n.em,{children:"Foldable"})," class is to define either ",(0,i.jsx)(n.em,{children:"foldMap"})," or ",(0,i.jsx)(n.em,{children:"foldr"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"class Foldable t where\n  fold :: Monoid a => t a -> a\n  foldMap :: Monoid b => (a -> b) -> t a -> b\n  foldr :: (a -> b -> b) -> b -> t a -> b\n  foldl :: (a -> b -> a) -> a -> t b -> a\n\n  null :: t a -> Bool\n  length :: t a -> Int\n  elem :: Eq a => a -> t a -> Bool\n  maximum :: Ord a => t a -> a\n  minimum :: Ord a => t a -> a\n  sum :: Num a => t a -> a\n  product :: Num a => t a -> a\n\n  foldr1 :: (a -> a -> a) -> t a -> a\n  foldl1 :: (a -> a -> a) -> t a -> a\n\n  toList :: t a -> [a]\n\n  -- default definitions\n  null = null . toList\n  length = length . toList\n  elem x = elem x . toList\n  maximum = maximum . toList\n  minimum = minimum . toList\n  sum = sum . toList\n  product = product . toList\n\n  foldr f v = foldr f v . toList\n  foldl r v = foldl f v . toList\n  foldr1 f = fold1 f . toList\n  foldl1 f = fold1 f . toList\n\n  fold = foldMap id\n  foldMap f = foldr (mappend . f) mempty\n  toList = foldMap (\\x -> [x])\n"})}),"\n",(0,i.jsx)(n.h3,{id:"list",children:"List"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"instance Foldable [] where\n  -- fold :: Monoid a => [a] -> a\n  fold [] = mempty\n  fold (x : xs) = x <> fold xs\n\n  -- foldMap :: Monoid b => (a -> b) -> [a] -> b\n  foldMap _ [] = mempty\n  foldMap f (x : xs) = f x <> foldMap f xs\n\n  -- foldr :: (a -> b -> b) -> b -> [a] -> b\n  foldr _ v [] = v\n  foldr f v (x : xs) = f x (foldr f v xs)\n\n  -- foldl :: (a -> b -> a) -> a -> [b] -> a\n  foldl _ v [] = v\n  foldl f v (x : xs) = foldl f (f v x) xs\n\n\ngetSum (foldMap Sum [1..10])  -- 55\ngetProduct (foldMap Product [1..10])  -- 3628800\n"})}),"\n",(0,i.jsx)(n.h3,{id:"tree",children:"Tree"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"data Tree a = Leaf a | Node (Tree a) (Tree a)\n  deriving (Show)\n\ninstance Foldable Tree where\n  -- fold :: Monoid a => Tree a -> a\n  fold (Leaf x) = x\n  fold (Node l r) = fold l <> fold r\n\n  -- foldMap :: Monoid b => (a -> b) -> Tree a -> b\n  foldMap f (Leaf x) = f x\n  foldMap f (Node l r) = foldMap f l <> foldMap f r\n\n  -- foldr :: (a -> b -> b) -> b -> Tree a -> b\n  foldr f v (Leaf x) = f x v\n  foldr f v (Node l r) = foldr f (foldr f v r) l\n\n  -- foldl :: (a -> b -> a) -> a -> Tree b -> a\n  foldl f v (Leaf x) = f v x\n  foldl f v (Node l r) = foldl f (foldl f v l) r\n\n\ntree :: Tree Int\ntree = Node (Node (Leaf 1) (Leaf 2)) (Leaf 3)\n\nfoldr (+) 0 -- 1 + (2 + (3 + 0))\nfoldl (+) 0 -- ((0 + 1) + 2) + 3\nfoldl (+) (Node (Leaf 1) (Leaf 2))  -- 3\ntoList (Node (Leaf 1) (Leaf 2)) -- [1,2]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"generic-functions-1",children:"Generic Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"import Data.Foldable\n\ndata Tree a = Leaf a | Node (Tree a) (Tree a)\n  deriving (Show)\n\ninstance Foldable Tree where\n  -- foldMap :: Monoid b => (a -> b) -> Tree a -> b\n  foldMap f (Leaf x) = f x\n  foldMap f (Node l r) = foldMap f l <> foldMap f r\n\naverage :: [Int] -> Int\naverage ns = sum ns `div` length ns\n\naverage' :: Foldable t => t Int -> Int\naverage' ns = sum ns `div` length ns\n\nmain = do\n  print (average' [1 .. 10])  -- 5\n  print (average' (Node (Leaf 1) (Leaf 3))) -- 2\n"})}),"\n",(0,i.jsx)(n.h4,{id:"and",children:"and()"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"and :: Foldable t => t Bool -> Bool\nand = getAll . foldMap All\n\nmain = do\n  print (and [True, False, True]) -- False\n"})}),"\n",(0,i.jsx)(n.h4,{id:"or",children:"or()"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"or :: Foldable t => t Bool -> Bool\nor = getAny . foldMap Any\n\nmain = do\n  print (or (Node (Leaf True) (Leaf False)))  -- True\n"})}),"\n",(0,i.jsx)(n.h4,{id:"all-1",children:"all()"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"all :: Foldable t => (a -> Bool) -> t a -> Bool\nall p = getAll . foldMap (All . p)\n\nmain = do\n  print (all even [1, 2, 3])  -- False\n"})}),"\n",(0,i.jsx)(n.h4,{id:"any-1",children:"any()"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"any :: Foldable t => (a -> Bool) -> t a -> Bool\nany p = getAny . foldMap (Any . p)\n\nmain = do\n  print (any even (Node (Leaf 1) (Leaf 2))) -- True\n"})}),"\n",(0,i.jsx)(n.h4,{id:"concat",children:"concat()"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:'concat :: Foldable t => t [a] -> [a]\nconcat = fold\n\nmain = do\n  print (concat ["ab", "cd", "ef"]) -- "abcdef"\n  print (concat (Node (Leaf [1, 2]) (Leaf [3])))  -- [1,2,3]\n'})}),"\n",(0,i.jsx)(n.h2,{id:"traversable",children:"Traversable"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"}),(0,i.jsx)(n.br,{}),"\n","A definition of either ",(0,i.jsx)(n.em,{children:"traverse"})," or ",(0,i.jsx)(n.em,{children:"sequenceA"})," is needed but ",(0,i.jsx)(n.em,{children:"traverse"})," is prefarable rather than ",(0,i.jsx)(n.em,{children:"sequenceA"})," because default ",(0,i.jsx)(n.em,{children:"traverse"})," definition is unefficient due to passing through the data structure twice, when ",(0,i.jsx)(n.em,{children:"fmap"})," and ",(0,i.jsx)(n.em,{children:"sequenceA"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"class (Functor t, Foldable t) => Traversable t where\n  traverse :: Applicative f => (a -> f b) -> t a -> f (t b)\n  traverse g = sequenceA . fmap g\n\n  sequenceA :: Applicative f = t (f a) -> f (t a)\n  sequenceA = traverse id\n\n  mapM :: Monad m => (a -> m b) -> t a -> m (t b)\n  mapM = traverse\n\n  sequence :: Monad m => t (m a) -> m (t a)\n  sequence = sequenceA\n"})}),"\n",(0,i.jsx)(n.h3,{id:"list-1",children:"List"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"instance Traversable [] where\n  -- traverse :: Applicative f => (a -> f b) -> [a] -> f [b]\n  traverse g [] = pure []\n  traverse g (x : xs) = pure (:) <*> g x <*> traverse g xs\n\ndec :: Int -> Maybe Int\ndec n = if n > 0 then Just (n - 1) else Nothing\n\nmain = do\n  print (traverse dec [1, 2, 3])  -- Just [0,1,2]\n  print (traverse dec [2, 1, 0])  -- Nothing\n\n  print (sequenceA [Just 1, Just 2, Just 3])  -- Just [1, 2, 3]\n  print (sequenceA [Just 1, Nothing, Just 3]) -- Nothing\n"})}),"\n",(0,i.jsx)(n.h3,{id:"tree-1",children:"Tree"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"instance Traversable Tree where\n  -- traverse :: Applicative f => (a -> f b) -> Tree a -> f (Tree b)\n  traverse g (Leaf x) = pure Leaf <*> g x\n  traverse g (Node l r) = pure Node <*> traverse g l <*> traverse g r\n\ndec :: Int -> Maybe Int\ndec n = if n > 0 then Just (n - 1) else Nothing\n\nmain = do\n  print (traverse dec (Node (Leaf 1) (Leaf 2))) -- Just (Node (Leaf 0) (Leaf 1))\n  print (traverse dec (Node (Leaf 0) (Leaf 1))) -- Nothing\n\n  print (sequenceA (Node (Leaf (Just 1)) (Leaf (Just 2))))  -- Just (Node (Leaf 1) (Leaf 2))\n  print (sequenceA (Node (Leaf (Just 1)) (Leaf Nothing))) -- Nothing\n"})}),"\n",(0,i.jsx)(n.h2,{id:"lazy-evaluation",children:"Lazy Evaluation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Lazy evaluation"})," is the use of ",(0,i.jsx)(n.em,{children:"call-by-name"})," evaluation in conjunction with sharing such as using pointer"]}),"\n",(0,i.jsx)(n.p,{children:"In Haskell, any two different ways of evaluating the same expression will always produce the same final value, provided that they both terminate."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"inc :: Int -> Int\ninc n = n + 1\n\n-- from right\ninc (2 * 3)\n= { applying * }\ninc 6\n= { applying inc }\n6 + 1\n= { applying + }\n7\n\n-- from left\ninc (2 * 3)\n= { applying inc }\n(2 * 3) + 1\n= { applying * }\n6 + 1\n= { applying + }\n7\n"})}),"\n",(0,i.jsx)(n.h3,{id:"call-by-value-evaluation",children:"call-by-value evaluation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"call-by-name"})," evaluation is preferable to ",(0,i.jsx)(n.em,{children:"call-by-value"})," for ensuring that evaluation terminates as often as possible."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mo,{children:"\u2235"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\because"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6922em"}}),(0,i.jsx)(n.span,{className:"mrel amsrm",children:"\u2235"})]})})]})," ",(0,i.jsx)(n.em,{children:"call-by-name"})," evaluation will terminate if there exists any evaluation sequence that terminates for a given expression, and produce the same final value."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"square :: Int -> Int\nsquare n = n * n\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"square (1 + 2)\n= { applying square }\n(1 + 2) * (1 + 2)\n= { applying the first +}\n3 * (1 + 2)\n= { applying + }  -- redundant reduction but can be resolved by using pointer to copy `(1 + 2)`\n3 * 3\n= { applying * }\n9\n"})}),"\n",(0,i.jsxs)(n.p,{children:["the following expression terminates in ",(0,i.jsx)(n.em,{children:"call-by-name"})," evaluation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"inf :: Int\ninf = 1 + inf\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"fst (0, inf)\n= { applying fst }\n0\n"})}),"\n",(0,i.jsx)(n.h3,{id:"call-by-name-evaluation",children:"call-by-name evaluation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"square (1 + 2)\n= { applying + }\nsquare 3\n= { applying square }\n3 * 3\n= { applying * }\n9\n"})}),"\n",(0,i.jsxs)(n.p,{children:["the following expression does not terminate in ",(0,i.jsx)(n.em,{children:"call-by-value"})," evaluation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"fst (0, inf)\n= { applying inf }\nfst (0, 1 + inf)\n= { applying inf }\nfst (0, 1 + (1 + inf))\n= { applying inf }\n...\n"})}),"\n",(0,i.jsx)(n.h3,{id:"modular-programming",children:"Modular Programming"}),"\n",(0,i.jsxs)(n.p,{children:["Lazy evaluation allows us to separate ",(0,i.jsx)(n.em,{children:"control"})," from ",(0,i.jsx)(n.em,{children:"data"})," in our computations."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- take 3: control\n-- ones: data\ntake 3 ones -- [1,1,1]\n\n-- pattern of without lazy evaluation:\n-- need to make (= control) a certain data.\n-- cannot separate control from data.\nreplicate 3 1 -- [1,1,1]\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"the sieve of Eratosthenes"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"primes :: [Int]\nprimes = sieve [2 ..]\n\nsieve :: [Int] -> [Int]\nsieve (p : xs) = p : sieve [x | x <- xs, x `mod` p /= 0]\n\nmain = do\n  print (take 10 primes) -- [2,3,5,7,11,13,17,19,23,29]\n  print (takeWhile (< 10) primes) -- [2,3,5,7]\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"sieve",src:s(6358).A+"",width:"661",height:"431"})}),"\n",(0,i.jsx)(n.h3,{id:"strict-application",children:"Strict Application"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"strict"})," functions such as built-in arithmetic operator, ",(0,i.jsx)(n.code,{children:"*"})," and ",(0,i.jsx)(n.code,{children:"+"})," cannot be applied until their two arguments have been evaluated to numbers; values"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"f $! x"}),"; ",(0,i.jsx)(n.code,{children:"f"})," is immediately applied to ",(0,i.jsx)(n.code,{children:"x"})," (if x is an expression, after evaluation of x)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"$!"})," serves as a stopper for outmost evaluation"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"square $! (1 + 2)\n= { applying + }\nsquare $! 3\n= { applying $! }\nsquare 3\n= { applying square }\n3 * 3\n= { applying * }\n9\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"strict application is mainly used to improve the space performance of programs."})}),"\n",(0,i.jsx)(n.p,{children:"pattern with lazy evaluation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"sumwith :: Int -> [Int] -> Int\nsumwith v [] = v\nsumwith v (x : xs) = sumwith (v + x) xs\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"sumwith 0 [1, 2, 3]\n= { applying sumwith }\nsumwith (0 + 1) [2, 3]\n= { applying sumwith }\nsumwith ((0 + 1) + 2) [3]\n= { applying sumwith }\nsumwith (((0 + 1) + 2) + 3) []\n= { applying sumwith }\n((0 + 1) + 2) + 3 -- the length is the same with the original list so sumwith requires much space for evaluation if given a long list.  \n= { applying the first + }\n(1 + 2) + 3\n= { applying the first + }\n3 + 3\n= { applying + }\n6\n"})}),"\n",(0,i.jsx)(n.p,{children:"pattern with strict application"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"sumwith :: Int -> [Int] -> Int\nsumwith v [] = v\nsumwith v (x : xs) = (sumwith $! (v + x)) xs\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"sumwith 0 [1, 2, 3]\n= { applying sumwith }\n(sumwith $! (0 + 1)) [2, 3]\n= { applying + }\n(sumwith $! 1) [2, 3]\n= { applying $! }\nsumwith 1 [2, 3]\n= { applying sumwith }\n(sumwith $! (1 + 2)) [3]\n= { applying + }\n(sumwith $! 3) [3]\n= { applying $! }\nsumwith 3 [3]\n= { applying sumwith }\n(sumwith $! (3 + 3)) []\n= { applying + }\n(sumwith $! 6) []\n= { applying $! }\nsumwith 6 []\n= { applying sumwith }\n6\n"})}),"\n",(0,i.jsx)(n.h3,{id:"foldl-1",children:"foldl'"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"-- in Data.Foldable\n\nfoldl' :: (a -> b -> a) -> a -> [b] -> a\nfoldl' f v [] = v\nfoldl' f v (x : xs) = ((foldl' f) $! (f v x)) xs\n"})}),"\n",(0,i.jsx)(n.h2,{id:"reasoning",children:"Reasoning"}),"\n",(0,i.jsx)(n.h3,{id:"induction",children:"Induction"}),"\n",(0,i.jsx)(n.p,{children:"can be used to confirm the logic or propeties of a recursive type or a recursive function is correct."}),"\n",(0,i.jsx)(n.p,{children:"e.g.1 (about natural number)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"replicate :: Int -> a -> [a]\nreplicate 0 _ = []\nreplicate n x = x : replicate (n - 1) x\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"-- hypothesis:\n-- replication function produce a list when n elements, that is `length (replicate n x) = n`\n\n-- Base case:\nlength (replicate 0 x)\n= { applying replicate }\nlength []\n= 0\n\n-- Inductive case\nlength (replicate (n + 1) x)\n= { applying replicate }\nlength (x : replicate n x)\n= { applying length }\n1 + length (replicate n x)\n= { induction hypothesis }\n1 + n\n= { commutativity of + }\nn + 1\n"})}),"\n",(0,i.jsx)(n.p,{children:"e.g.2 (about list)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"reverse :: [a] -> [a]\nreverse [] = []\nreverse (x : xs) = reverse xs ++ x\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"-- hypothesis 1:\n-- contravariant; reverse (xs ++ ys) = reverse ys ++ reverse xs\n\n-- Base case:\nreverse ([] ++ ys)\n= { applying ++ }\nreverse ys\n= { identity for ++ }\nreverse ys ++ []\n= { unapplying reverse }\nreverse ys ++ reverse []\n\n-- Inductive case:\nreverse ((x : xs) ++ ys)\n= { applying ++ }\nreverse (x : (xs ++ ys))\n= { applying reverse }\nreverse (xs ++ ys) ++ [x]\n= { induction hypothesis }\n(reverse ys ++ reverse xs) ++ [x]\n= { associativity of ++ }\nreverse ys ++ (reverse xs ++ [x])\n= { unapplying the second reverse }\nreverse ys ++ reverse (x : xs)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"-- hypothesis 2:\n-- reverse (reverse (x : xs)) = x : xs\n\n-- Base case:\nreverse (reverse [])\n= { applying the inner reverse }\nreverse []\n= { appyling reverse }\n[]\n\n-- Inductive case:\nreverse (reverse (x : xs))\n= { applying the inner reverse }\nreverse (reverse xs ++ [x])\n= { contravariant }\nreverse [x] ++ reverse (reverse xs)\n= { singleton lists }\n[x] ++ reverse (reverse xs)\n= { induction hypothesis }\n[x] ++ xs\n= { applying ++ }\nx : xs\n"})}),"\n",(0,i.jsx)(n.p,{children:"e.g.3 (about fmap low on list)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"fmap id = id\nfmap (g . h) = fmap g . fmap h\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"fmap :: (a -> b) -> [a] -> [b]\nfmap g [] = []\nfmap g (x : xs) = g x : fmap g xs\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"-- hypothesis 1: fmap id = id\n\n-- Base case:\nfmap id []\n= { applying fmap }\n[]\n\n-- Inductive case:\nfmap id (x : xs)\n= { applying fmap }\nid x : fmap id xs\n= { applying id }\nx : fmap id xs\n= { induction hypothesis }\nx : xs\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"-- hypothesis 2: \n-- fmap (g . h) = fmap g . fmap h\n-- i.e. fmap (g . h) xs = fmap g (fmap h xs)\n\n-- Base case:\nfmap (g . h) []\n= { applying fmap }\n[]\n= { unapplying fmap }\nfmap g []\n= { unapplying fmap }\nfmap g (fmap h [])\n\n-- Inductive case:\nfmap (g . h) (x : xs)\n= { applying fmap }\n(g . h) x : fmap (g . h) xs\n= { applying . }\ng (h x) : fmap (g . h) xs\n= { induction hypothesis }\ng (h x) : fmap g (fmap h xs)\n= { unapplying fmap }\nfmap g (h x : fmap h xs)\n= { unapplying fmap }\nfmap g (fmap h (x : xs))\n"})}),"\n",(0,i.jsx)(n.h3,{id:"improve-computing-time",children:"Improve Computing Time"}),"\n",(0,i.jsx)(n.h4,{id:"reverse",children:"reverse()"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"reverse"})," function run by ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"O"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsxs)(n.msup,{children:[(0,i.jsx)(n.mi,{children:"n"}),(0,i.jsx)(n.mn,{children:"2"})]}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n^2)"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsx)(n.span,{className:"vlist-t",children:(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,i.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mtight",children:"2"})})]})})})})})]}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})})]})," because in general ",(0,i.jsx)(n.code,{children:"xs ++ ys"})," needs ",(0,i.jsx)(n.code,{children:"(length xs) + 1"})," steps to concatinate xs and xs, so ",(0,i.jsx)(n.code,{children:"reverse xs ++ [x]"})," is bottle neck.",(0,i.jsx)(n.br,{}),"\n","we try to difine another version ",(0,i.jsx)(n.em,{children:"reverse"}),"; ",(0,i.jsx)(n.em,{children:"reverse'"})," to improve computing time."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"reverse :: [a] -> [a]\nreverse [] = []\nreverse (x : xs) = reverse xs ++ [x]\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"-- hypothesis to construct the definition of reverse':\n-- reverse' xs ys = xs ++ ys\n\n-- Base case:\nreverse' [] ys\n= { specification of reverse' }\nreverse [] ++ ys\n= { applying reverse }\n[] ++ ys\n= { applying ++ }\nys\n\n-- Inductive case:\nreverse' (x : xs) ys\n= { specification of reverse' }\nreveres (x : xs) ++ ys\n= { applying reverse }\n(reverse xs ++ [x]) ++ ys\n= { associativity of ++ }\nreverse xs ++ ([x] ++ ys)\n= { induction hypothesis }\nreverse' xs ([x] ++ ys)\n= { applying ++ }\nreverse' xs (x : ys)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["we obtain another definition of ",(0,i.jsx)(n.em,{children:"reverse'"})," ."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"reverse' :: [a] -> [a] -> [a]\nreverse' [] ys = ys\nreverse' (x : xs) ys = reverse' xs (x : ys)\n\nreverse :: [a] -> [a]\nreverse xs = reverse' xs [] -- = foldl (\\xs x -> x : xs) []\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"reverse [1, 2, 3]\n= { applying reverse }\nreverse' [1, 2, 3] []\n= { applying reverse' }\nreverse' [2, 3] (1 : [])\n= { applying reverse' }\nreverse' [3] (2 : (1 : []))\n= { applying reverse' }\nreverse' [] (3 : (2 : 1 : []))\n= { applying reverse' }\n3 : (2 : 1 : [])\n"})}),"\n",(0,i.jsx)(n.h4,{id:"flatten",children:"flatten()"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"data Tree = Leaf Inf | Node Tree Tree\n\nflatten :: Tree -> [Int]\nflatten (Leaf n) = [n]\nflatten (Node l r) = flatten l ++ flatten r\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"-- hypothesis to construct an improved definition of flatten; flatten'\n-- flatten' t ns = flatten t ++ ns\n\n-- Base case:\nflatten' (Leaf n) ns\n= { specification of flatten' }\nflatten (Leaf n) ++ ns\n= { applying flatten }\n[n] ++ ns\n= { applying ++ }\nn : ns\n\n-- Inductive case:\nflatten' (Node l r) ns\n= { specification of flatten' }\nflatten (Node l r) ++ ns\n= { applying flatten }\n(flatten l ++ flatten r) ++ ns\n= { associativity of }\nflatten l ++ (flatten r ++ ns)\n= { induction hypothesis for l }\nflatten' l (flatten r ++ ns)\n= { induction hypothesis for r }\nflatten' l (flatten' r ns)\n"})}),"\n",(0,i.jsx)(n.p,{children:"we obtain the following definition."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hs",children:"flatten' :: Tree -> [Int] -> [Int]\nflatten' (Leaf n) ns = n : ns\nflatten' (Node l r) ns = flatten' l (flatten' r ns)\n\nflatten :: Tree -> [Int]\nflatten t = flatten' t []\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},6165:(e,n,s)=>{s.d(n,{A:()=>a});const a=s.p+"assets/images/interactive_program-55281981fc1089df658441fa95e95bd4.png"},6358:(e,n,s)=>{s.d(n,{A:()=>a});const a=s.p+"assets/images/sieve-a54423639dbd9d424cff564ef3407dcc.png"},5248:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>t});var a=s(758);const i={},l=a.createContext(i);function r(e){const n=a.useContext(l);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(l.Provider,{value:n},e.children)}}}]);