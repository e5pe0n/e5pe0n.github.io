"use strict";(self.webpackChunke_5_pe_0_n_github_io=self.webpackChunke_5_pe_0_n_github_io||[]).push([[1132],{3210:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>u,default:()=>l,frontMatter:()=>d,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"coding/rust/traits","title":"Traits","description":"Generics vs. Associated Types","source":"@site/docs/coding/rust/traits.md","sourceDirName":"coding/rust","slug":"/coding/rust/traits","permalink":"/docs/coding/rust/traits","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"techNoteSidebar","previous":{"title":"Strings","permalink":"/docs/coding/rust/strings"},"next":{"title":"Misc","permalink":"/docs/category/misc"}}');var r=n(6070),i=n(5248);const d={},u="Traits",c={},a=[{value:"Generics vs. Associated Types",id:"generics-vs-associated-types",level:2}];function o(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"traits",children:"Traits"})}),"\n",(0,r.jsx)(t.h2,{id:"generics-vs-associated-types",children:"Generics vs. Associated Types"}),"\n",(0,r.jsx)(t.p,{children:"use associated type to bind a type to a trait implementation; get the type uniquely determined by the trait implementation."}),"\n",(0,r.jsx)(t.p,{children:"e.g."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsxs)(t.a,{href:"https://doc.rust-lang.org/nightly/std/ops/trait.Add.html",children:[(0,r.jsx)(t.code,{children:"Add"})," trait"]})," binds ",(0,r.jsx)(t.code,{children:"Output"})," type to a trait implementation so that when a ",(0,r.jsx)(t.code,{children:"RHS"})," type is given then can determine the return type of ",(0,r.jsx)(t.code,{children:"add()"})," uniquely."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"pub trait Add<RHS = Self> {\n    type Output;  // associated type\n    \n    fn add(self, rhs: RHS) -> Self::Output;\n}\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"impl Add<u32> for u32 {\n    type Output = u32;\n    \n    fn add(self, rhs: u32) -> u32 {\n      // [...]\n    }\n}\n\nimpl Add<&u32> for u32 {\n    type Output = u32;\n    \n    fn add(self, rhs: &u32) -> u32 {\n      // [...]\n    }\n}\n// let result: u32 = 1u32 + 1u32\n// let result: u32 = 1u32 + &1u32\n"})}),"\n",(0,r.jsxs)(t.p,{children:["if ",(0,r.jsx)(t.code,{children:"Output"})," is generics instead of associated type like below,"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"pub trait Add<RHS = Self, Output> {\n    fn add(self, rhs: RHS) -> Output;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["we can get implementations for ",(0,r.jsx)(t.code,{children:"RHS"}),", which could result in multiple result types.\nusing associated type disallows to do so."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"impl Add<u32, u32> for u32 {\n    fn add(self, rhs: u32) -> u32 {\n      // [...]\n    }\n}\n\nimpl Add<u32, &u32> for u32 {\n    fn add(self, rhs: u32) -> &u32 {\n        // [...]\n    }\n}\n// let result: u32 = 1u32 + 1u32\n// let result: &u32 = 1u32 + 1u32\n"})})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},5248:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>u});var s=n(758);const r={},i=s.createContext(r);function d(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function u(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);