"use strict";(self.webpackChunke_5_pe_0_n_github_io=self.webpackChunke_5_pe_0_n_github_io||[]).push([[29],{9613:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var a=t(9496);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(t),m=r,g=d["".concat(s,".").concat(m)]||d[m]||u[m]||l;return t?a.createElement(g,i(i({ref:n},p),{},{components:t})):a.createElement(g,i({ref:n},p))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1335:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var a=t(8957),r=(t(9496),t(9613));const l={},i="Fundamentals",o={unversionedId:"coding/c++/fundamentals",id:"coding/c++/fundamentals",title:"Fundamentals",description:"Vector",source:"@site/docs/coding/c++/fundamentals.md",sourceDirName:"coding/c++",slug:"/coding/c++/fundamentals",permalink:"/docs/coding/c++/fundamentals",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"techNoteSidebar",previous:{title:"C++",permalink:"/docs/category/c"},next:{title:"Haskell",permalink:"/docs/category/haskell"}},s={},c=[{value:"Vector",id:"vector",level:2},{value:"Copy and Reference",id:"copy-and-reference",level:3},{value:"Vector of Pointers",id:"vector-of-pointers",level:3},{value:"Sort",id:"sort",level:3},{value:"Asc",id:"asc",level:4},{value:"Dsc",id:"dsc",level:4},{value:"Priority Queue",id:"priority-queue",level:2},{value:"Max Heap",id:"max-heap",level:3},{value:"Min Heap",id:"min-heap",level:3},{value:"Dynamic Cast",id:"dynamic-cast",level:2},{value:"Down Cast",id:"down-cast",level:3},{value:"XOR",id:"xor",level:2},{value:"Random",id:"random",level:2},{value:"Read Lines",id:"read-lines",level:2}],p={toc:c},d="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"fundamentals"},"Fundamentals"),(0,r.kt)("h2",{id:"vector"},"Vector"),(0,r.kt)("h3",{id:"copy-and-reference"},"Copy and Reference"),(0,r.kt)("p",null,"C++'s function returns copied vector with ",(0,r.kt)("strong",{parentName:"p"},"copied objects")," it has.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <string>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n  int id;\n  Node(int _id) : id(_id) {}\n};\n\nstruct Graph {\n  vector<Node> nodes;\n  vector<Node> get_nodes() {\n    return nodes;\n  }\n};\n\nint main() {\n  Graph g;\n  g.nodes.push_back(Node(0));\n  vector<Node> _nodes = g.get_nodes();\n  _nodes[0].id = 100;\n  printf("%d\\n", g.nodes[0].id); // 0\n}\n')),(0,r.kt)("p",null,"Use pointer with ",(0,r.kt)("em",{parentName:"p"},"shared_ptr")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"<memory>"),".  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <memory>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n  int id;\n  Node(int _id) : id(_id) {}\n};\n\nstruct Graph {\n  vector<shared_ptr<Node>> nodes;\n  vector<shared_ptr<Node>> get_nodes() {\n    return nodes;\n  }\n};\n\nint main() {\n  Graph g;\n  g.nodes.push_back(make_shared<Node>(0));\n  vector<shared_ptr<Node>> _nodes = g.get_nodes();\n  _nodes[0].get()->id = 100;\n  printf("%d\\n", g.nodes[0].get()->id); // 100\n}\n')),(0,r.kt)("h3",{id:"vector-of-pointers"},"Vector of Pointers"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"vector")," does not clean pointers when it reaches out of the scope.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <string>\n#include <vector>\nusing namespace std;\n\nstruct A {\n  ~A() {\n    printf("deleted");\n  }\n};\n\nint main() {\n  vector<A *> v;\n  v.emplace_back(new A);\n} // memory leaks (~A is not called)\n')),(0,r.kt)("p",null,"Use ",(0,r.kt)("em",{parentName:"p"},"unique_ptr")," or ",(0,r.kt)("em",{parentName:"p"},"shared_ptr")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"<memory>")," to make memory maintenace easy.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <memory>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstruct A {\n  ~A() {\n    printf("deleted\\n");\n  }\n};\n\nint main() {\n  vector<unique_ptr<A>> v;\n  v.emplace_back(unique_ptr<A>(new A));\n  v.emplace_back(make_unique<A>()); // the same as above\n}\n// deleted (~A is called)\n// deleted (~A is called)\n')),(0,r.kt)("h3",{id:"sort"},"Sort"),(0,r.kt)("h4",{id:"asc"},"Asc"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="Using lambda"',title:'"Using','lambda"':!0},'#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n  vector<ll> V{1, 5, 3};\n  auto cmp_asc = [](const ll &left, const ll &right) { return left < right; };\n  sort(V.begin(), V.end(), cmp_asc);\n  for (auto v : V)\n    printf("%lld\\n", v); // 1 3 5\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="Using the less comparison function"',title:'"Using',the:!0,less:!0,comparison:!0,'function"':!0},'#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n  vector<ll> V{1, 5, 3};\n  sort(V.begin(), V.end(), less<ll>());\n  for (auto v : V)\n    printf("%lld\\n", v); // 1 3 5\n}\n')),(0,r.kt)("h4",{id:"dsc"},"Dsc"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="Using lambda"',title:'"Using','lambda"':!0},'#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n  vector<ll> V{1, 5, 3};\n  auto cmp_dsc = [](const ll &left, const ll &right) { return left > right; };\n  sort(V.begin(), V.end(), cmp_dsc);\n  for (auto v : V)\n    printf("%lld\\n", v); // 5 3 1\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="Using the greater comparison function"',title:'"Using',the:!0,greater:!0,comparison:!0,'function"':!0},'#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n  vector<ll> V{1, 5, 3};\n  sort(V.begin(), V.end(), greater<ll>());\n  for (auto v : V)\n    printf("%lld\\n", v); // 5 3 1\n}\n')),(0,r.kt)("h2",{id:"priority-queue"},"Priority Queue"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"the order of priority_queue is reverse to one of sort!")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},"functions"),(0,r.kt)("th",{parentName:"tr",align:"center"},"priority_queue"),(0,r.kt)("th",{parentName:"tr",align:"center"},"sort"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"greater"),(0,r.kt)("td",{parentName:"tr",align:"center"},"min heap i.e. asc"),(0,r.kt)("td",{parentName:"tr",align:"center"},"dsc")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"less"),(0,r.kt)("td",{parentName:"tr",align:"center"},"max heap i.e. dsc"),(0,r.kt)("td",{parentName:"tr",align:"center"},"asc")))),(0,r.kt)("h3",{id:"max-heap"},"Max Heap"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n  priority_queue<ll> q; // default is MAX heap\n  q.push(1);\n  q.push(5);\n  q.push(3);\n  while (q.size()) {\n    ll p = q.top();\n    q.pop();\n    printf("%lld\\n", p); // 5 3 1\n  }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Edge {\n  ll u, v, w;\n};\n\nint main() {\n  auto cmp = [](const Edge &e1, const Edge &e2) { return e1.w < e2.w; };\n  priority_queue<Edge, vector<Edge>, decltype(cmp)> q(cmp);\n  q.push(Edge{0, 1, 1});\n  q.push(Edge{0, 2, 5});\n  q.push(Edge{1, 2, 3});\n  while (q.size()) {\n    Edge e = q.top();\n    q.pop();\n    printf("%lld\\n", e.w); // 5 3 1\n  }\n}\n')),(0,r.kt)("h3",{id:"min-heap"},"Min Heap"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n  priority_queue<ll, vector<ll>, greater<vector<ll>::value_type>> q;\n  q.push(1);\n  q.push(5);\n  q.push(3);\n  while (q.size()) {\n    ll p = q.top();\n    q.pop();\n    printf("%lld\\n", p); // 1 3 5\n  }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Edge {\n  ll u, v, w;\n};\n\nint main() {\n  auto cmp = [](const Edge &e1, const Edge &e2) { return e1.w > e2.w; };\n  priority_queue<Edge, vector<Edge>, decltype(cmp)> q(cmp);\n  q.push(Edge{0, 1, 1});\n  q.push(Edge{0, 2, 5});\n  q.push(Edge{1, 2, 3});\n  while (q.size()) {\n    Edge e = q.top();\n    q.pop();\n    printf("%lld\\n", e.w); // 1 3 5\n  }\n}\n')),(0,r.kt)("h2",{id:"dynamic-cast"},"Dynamic Cast"),(0,r.kt)("h3",{id:"down-cast"},"Down Cast"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct A {\n  virtual void dummy() = 0;\n};\n\nstruct B : public A {\n  string _name;\n  void dummy() override {}\n  B(string name) : _name(name) {}\n};\n\nstruct C : public A {\n  ll _value;\n  void dummy() override {}\n  C(ll value) : _value(value) {}\n};\n\nint main() {\n  vector<shared_ptr<A>> v;\n  v.push_back(make_shared<B>("B"));\n  v.push_back(make_shared<C>(3));\n  for (auto _v : v) {\n    if (auto b = dynamic_cast<B *>(_v.get())) {\n      cout << b->_name << endl;\n    } else if (auto c = dynamic_cast<C *>(_v.get())) {\n      cout << c->_value << endl;\n    }\n  }\n}\n\n// B\n// 3\n')),(0,r.kt)("h2",{id:"xor"},"XOR"),(0,r.kt)("p",null,"Be careful for the operation precedence.",(0,r.kt)("br",{parentName:"p"}),"\n","Should write it with parentheses if not sure."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"3 ^ 6 == 3    // true because evaluated as 3 ^ (6 == 3)\n(3 ^ 6) == 3  // false\n")),(0,r.kt)("h2",{id:"random"},"Random"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef chrono::high_resolution_clock hrc;\n\nauto seed = hrc::now().time_since_epoch().count();\ndefault_random_engine generator(seed);\nuniform_int_distribution<ll> distribution(1, 6);  // 1, 2, 3, 4, 5, 6\nll x = distribution(generator);\n")),(0,r.kt)("h2",{id:"read-lines"},"Read Lines"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt",metastring:'title="01.txt"',title:'"01.txt"'},"line1-1 line1-2 line1-3\nline2-1 line2-2 line2-3\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <fstream>\n#include <string>\nusing namespace std;\nint main() {\n  ifstream ifs{"01.txt"};\n  string lines{};\n  for (string s; getline(ifs, s);) {\n    lines += s;\n  }\n// line1-1 line1-2 line1-3\n// line2-1 line2-2 line2-3\n}\n')))}u.isMDXComponent=!0}}]);