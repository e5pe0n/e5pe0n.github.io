"use strict";(self.webpackChunke_5_pe_0_n_github_io=self.webpackChunke_5_pe_0_n_github_io||[]).push([[110],{9613:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>k});var n=a(9496);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=u(a),d=i,k=m["".concat(s,".").concat(d)]||m[d]||c[d]||l;return a?n.createElement(k,r(r({ref:t},p),{},{components:a})):n.createElement(k,r({ref:t},p))}));function k(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=a.length,r=new Array(l);r[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:i,r[1]=o;for(var u=2;u<l;u++)r[u]=a[u];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5573:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var n=a(8957),i=(a(9496),a(9613));const l={},r="Software Design",o={unversionedId:"software/software-design",id:"software/software-design",title:"Software Design",description:"Axioms",source:"@site/docs/software/software-design.md",sourceDirName:"software",slug:"/software/software-design",permalink:"/docs/software/software-design",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"techNoteSidebar",previous:{title:"Software",permalink:"/docs/category/software"},next:{title:"System",permalink:"/docs/category/system"}},s={},u=[{value:"Axioms",id:"axioms",level:2},{value:"Software Architecture",id:"software-architecture",level:2},{value:"Symptoms of Complexity",id:"symptoms-of-complexity",level:2},{value:"Causes of Complexity",id:"causes-of-complexity",level:2},{value:"Modular Design",id:"modular-design",level:2},{value:"Interfaces",id:"interfaces",level:3},{value:"Implementations",id:"implementations",level:3},{value:"Performance",id:"performance",level:2},{value:"Domain",id:"domain",level:2},{value:"Model",id:"model",level:2},{value:"SOLID Principles",id:"solid-principles",level:2},{value:"SRP; Single Responsibility Principle",id:"srp-single-responsibility-principle",level:3},{value:"OCP; Open-Closed Principle",id:"ocp-open-closed-principle",level:3},{value:"LSP; Liskov Substitution Principle",id:"lsp-liskov-substitution-principle",level:3},{value:"ISP; Interface Segregation Principle",id:"isp-interface-segregation-principle",level:3},{value:"DIP; Dependency Inversion Principle",id:"dip-dependency-inversion-principle",level:3},{value:"Components",id:"components",level:2},{value:"Component-level Principles",id:"component-level-principles",level:3},{value:"REP; Reuse/Release Equivalence Principle",id:"rep-reuserelease-equivalence-principle",level:4},{value:"CCP; Common Closure Principle",id:"ccp-common-closure-principle",level:4},{value:"CRP; Common Reuse Principle",id:"crp-common-reuse-principle",level:4},{value:"Component Dependencies",id:"component-dependencies",level:3},{value:"ADP; Asynclic Dependencies Principle",id:"adp-asynclic-dependencies-principle",level:4},{value:"SDP; Stable Dependencies Principle",id:"sdp-stable-dependencies-principle",level:4},{value:"SAP; Stable Abstraction Principle",id:"sap-stable-abstraction-principle",level:4},{value:"Business Rules",id:"business-rules",level:2},{value:"Humble Objects",id:"humble-objects",level:2},{value:"Layered Architecture",id:"layered-architecture",level:2},{value:"Model-Driven Design",id:"model-driven-design",level:2},{value:"Components",id:"components-1",level:3},{value:"Entities",id:"entities",level:4},{value:"Value Objects",id:"value-objects",level:4},{value:"Services",id:"services",level:4},{value:"Life Cycle Management of Domain Objects",id:"life-cycle-management-of-domain-objects",level:3},{value:"Aggregates",id:"aggregates",level:4},{value:"Factories",id:"factories",level:4},{value:"Repositories",id:"repositories",level:4},{value:"Supple Design",id:"supple-design",level:2},{value:"Model Integrity Patterns",id:"model-integrity-patterns",level:2},{value:"Referencies",id:"referencies",level:2}],p={toc:u},m="wrapper";function c(e){let{components:t,...a}=e;return(0,i.kt)(m,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"software-design"},"Software Design"),(0,i.kt)("h2",{id:"axioms"},"Axioms"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"software design is not a solid stuff",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"designing software architecture never ends"),(0,i.kt)("li",{parentName:"ul"},"it is changing over development"))),(0,i.kt)("li",{parentName:"ul"},"the primary purpose of architecture is to support the life cycle of the system",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"good architecture makes the system easy to understand, easy to develop, easy to maintain, and easy to deploy"),(0,i.kt)("li",{parentName:"ul"},"the ultimate goal is to minimize the lifetime cost of the system and to maxmize programmer productivity"))),(0,i.kt)("li",{parentName:"ul"},"the architecture of the system should elevate the use cases, the features, and the required behaviours of the system to first-class entities that are visible landmarks for the developers"),(0,i.kt)("li",{parentName:"ul"},"good architecture centered on use cases so that architects can safely describe the structures that support those use cases without commiting to frameworks, tools, and environments")),(0,i.kt)("h2",{id:"software-architecture"},"Software Architecture"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Structure",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"type of architecture style",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"microservice"),(0,i.kt)("li",{parentName:"ul"},"layered"),(0,i.kt)("li",{parentName:"ul"},"microkernel"))))),(0,i.kt)("li",{parentName:"ul"},"Architecture Charactaristics",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"success criteria of a system",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"availability"),(0,i.kt)("li",{parentName:"ul"},"reliability"),(0,i.kt)("li",{parentName:"ul"},"testability"),(0,i.kt)("li",{parentName:"ul"},"scalability"),(0,i.kt)("li",{parentName:"ul"},"security"),(0,i.kt)("li",{parentName:"ul"},"agility"),(0,i.kt)("li",{parentName:"ul"},"fault tolerance"),(0,i.kt)("li",{parentName:"ul"},"elasticity"),(0,i.kt)("li",{parentName:"ul"},"receverability"),(0,i.kt)("li",{parentName:"ul"},"performance"),(0,i.kt)("li",{parentName:"ul"},"deployablility"),(0,i.kt)("li",{parentName:"ul"},"learnability"))))),(0,i.kt)("li",{parentName:"ul"},"Architecture Decision",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"rules for how a system should be constructed"))),(0,i.kt)("li",{parentName:"ul"},"Design Principles",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a guideline")))),(0,i.kt)("h2",{id:"symptoms-of-complexity"},"Symptoms of Complexity"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"change amplification"),(0,i.kt)("li",{parentName:"ul"},"cognitive load"),(0,i.kt)("li",{parentName:"ul"},"unknown unknown")),(0,i.kt)("h2",{id:"causes-of-complexity"},"Causes of Complexity"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"dependendies"),(0,i.kt)("li",{parentName:"ul"},"obscurity")),(0,i.kt)("h2",{id:"modular-design"},"Modular Design"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"goal of modular design is moinimize the dependencies between modules"),(0,i.kt)("li",{parentName:"ul"},"module consists of ",(0,i.kt)("em",{parentName:"li"},"interface")," and ",(0,i.kt)("em",{parentName:"li"},"implementation"))),(0,i.kt)("h3",{id:"interfaces"},"Interfaces"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"any information a developer needs to know in order to use a module"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"e.g.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"signiture",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"name"),(0,i.kt)("li",{parentName:"ul"},"parameters"),(0,i.kt)("li",{parentName:"ul"},"returns"))),(0,i.kt)("li",{parentName:"ul"},"comments, documents"))),(0,i.kt)("li",{parentName:"ul"},"if users need to read the code of a method in order to use it, then there is no abstraction"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"more important for a module to have a simple interface than a simple implementation"))),(0,i.kt)("h3",{id:"implementations"},"Implementations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"reduce the number of places where exceptions have to be handled"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"define errors out of existence"))))),(0,i.kt)("h2",{id:"performance"},"Performance"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"before attempting to improve performance, measure the system's existing behaviour"))),(0,i.kt)("h2",{id:"domain"},"Domain"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"subject area to which users applies the program"),(0,i.kt)("li",{parentName:"ul"},"subject area of the problem we solve using software")),(0,i.kt)("h2",{id:"model"},"Model"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"simplification"),(0,i.kt)("li",{parentName:"ul"},"abstraction",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"filter out extraneous details")))),(0,i.kt)("li",{parentName:"ul"},"effective modeling",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"knowledge crunching"),(0,i.kt)("li",{parentName:"ul"},"cultivating a language based on the model",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Ubiquitous Language",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"changes in the Ubiquitous Language are changes to the model"))))),(0,i.kt)("li",{parentName:"ul"},"iteration",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"software development is all design"))))),(0,i.kt)("li",{parentName:"ul"},"don't just model reality (e.g. actual manual operations that will be automated by software/system) as is",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"model them from the perspective of software/system too")))),(0,i.kt)("h2",{id:"solid-principles"},"SOLID Principles"),(0,i.kt)("p",null,"suggest how to arrange functions and data structures into classes, and how those classes should be interconnected to design the mid-level (module level) software architectures that"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"tolerate change"),(0,i.kt)("li",{parentName:"ul"},"are easy to undarstand"),(0,i.kt)("li",{parentName:"ul"},"are reusable in many software systems")),(0,i.kt)("h3",{id:"srp-single-responsibility-principle"},"SRP; Single Responsibility Principle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a module should be responsible to one, and only one, actor",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"actor: group of user or stakeholder who wants the system changed in the same way"))),(0,i.kt)("li",{parentName:"ul"},"a moule should NOT have multiple reasons to change")),(0,i.kt)("h3",{id:"ocp-open-closed-principle"},"OCP; Open-Closed Principle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a software architect should be open for extension but closed for modification"),(0,i.kt)("li",{parentName:"ul"},"if SRP is obeyed, a feature extension won't affect to modules for other features"),(0,i.kt)("li",{parentName:"ul"},"associated with CCP")),(0,i.kt)("h3",{id:"lsp-liskov-substitution-principle"},"LSP; Liskov Substitution Principle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"polymorphism")),(0,i.kt)("h3",{id:"isp-interface-segregation-principle"},"ISP; Interface Segregation Principle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"avoid depending on things that they don't use"),(0,i.kt)("li",{parentName:"ul"},"have clear abstraction/concept of the module")),(0,i.kt)("h3",{id:"dip-dependency-inversion-principle"},"DIP; Dependency Inversion Principle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"implement interfaces for the high-level module which uses lower-level modules"),(0,i.kt)("li",{parentName:"ul"},"lower-level modules should NOT know the implementation details of higher-level modules"),(0,i.kt)("li",{parentName:"ul"},"have lower-level modules obey the interfaces",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"now we can have inverted dependency from lower-level to higher-level without knowledge about implemetation details of higher-level module")))),(0,i.kt)("h2",{id:"components"},"Components"),(0,i.kt)("h3",{id:"component-level-principles"},"Component-level Principles"),(0,i.kt)("h4",{id:"rep-reuserelease-equivalence-principle"},"REP; Reuse/Release Equivalence Principle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the granule of reuse is the granule of release")),(0,i.kt)("h4",{id:"ccp-common-closure-principle"},"CCP; Common Closure Principle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"component-level ",(0,i.kt)("a",{parentName:"li",href:"#srp-single-responsibility-principle"},"SRP"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a component should NOT have multiple reasons to change")))),(0,i.kt)("h4",{id:"crp-common-reuse-principle"},"CRP; Common Reuse Principle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"component-level ",(0,i.kt)("a",{parentName:"li",href:"#isp-interface-segregation-principle"},"ISP"))),(0,i.kt)("h3",{id:"component-dependencies"},"Component Dependencies"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"component structure cannot be designed from the top down",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"component dependencies graph is created for the first time if it reached the time dependency management was necessary"),(0,i.kt)("li",{parentName:"ul"},"component dependencies graphs is for mapping to buildability and maintainability of the application; not for describing the function of the application")))),(0,i.kt)("h4",{id:"adp-asynclic-dependencies-principle"},"ADP; Asynclic Dependencies Principle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"allow no cycles in the component dependency graph")),(0,i.kt)("h4",{id:"sdp-stable-dependencies-principle"},"SDP; Stable Dependencies Principle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"depend in the direction of stability"),(0,i.kt)("li",{parentName:"ul"},"ensure that modules that are intended to be easy to change are not depended on by modules that are harder to change")),(0,i.kt)("h4",{id:"sap-stable-abstraction-principle"},"SAP; Stable Abstraction Principle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a component should be as abstract as it is stable"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#sdp-stable-dependencies-principle"},"SDP")," + ",(0,i.kt)("a",{parentName:"li",href:"#sap-stable-abstraction-principle"},"SAP")," -> dependencies run in the direction of abstraction")),(0,i.kt)("h2",{id:"business-rules"},"Business Rules"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Critical Business Rules",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"make or save the business money"),(0,i.kt)("li",{parentName:"ul"},"some of them are purelly irrespective of whether they were implemented on a computer"))),(0,i.kt)("li",{parentName:"ul"},"Entity",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Critical Business Data",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"data required by critical business rules"))),(0,i.kt)("li",{parentName:"ul"},"generalized concept; not ",(0,i.kt)("em",{parentName:"li"},"application-specific")))),(0,i.kt)("li",{parentName:"ul"},"Use Cases",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"define ",(0,i.kt)("em",{parentName:"li"},"application-specific")," business rules",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"automated operation to make or save the business money"),(0,i.kt)("li",{parentName:"ul"},"at lower-level than Entities since Use Cases depend on the application/system; not generalized as much as Entities"))),(0,i.kt)("li",{parentName:"ul"},"e.g. apply an estimation (validation) to user info for loan then create Customer entity if acceptable"),(0,i.kt)("li",{parentName:"ul"},"have input and ouput",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"but should not depend on how input and output are delivered",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"e.g. HTTP request and response, HTML, SQL")))))))),(0,i.kt)("mermaid",{value:"classDiagram\n    class Loan{\n        - principle\n        - rate\n        - period\n        + makePayment() // Business Rule\n        + applyInterest() // Business Rule\n        + chargeLateFee() // Business Rule\n    }"}),(0,i.kt)("h2",{id:"humble-objects"},"Humble Objects"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"separate behaviours into tastables and non-testables"),(0,i.kt)("li",{parentName:"ul"},"from the uesr's point of view, an object is simply a set of operations; an object represent behaviours",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"becaues users cannot see private fields")))),(0,i.kt)("h2",{id:"layered-architecture"},"Layered Architecture"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"User Interface (or Presentation Layer)"),(0,i.kt)("li",{parentName:"ul"},"Application Layer",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"services"),(0,i.kt)("li",{parentName:"ul"},"not contain business rules or knowledge"),(0,i.kt)("li",{parentName:"ul"},"not have state reflecting business situation"),(0,i.kt)("li",{parentName:"ul"},"only coordinates tasks and delegates work to collaborations of domain objects in the next layer down"))),(0,i.kt)("li",{parentName:"ul"},"Domain Layer (or Model Layer)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"business situation"),(0,i.kt)("li",{parentName:"ul"},"business rules"),(0,i.kt)("li",{parentName:"ul"},"control and use state reflecting the business situation"))),(0,i.kt)("li",{parentName:"ul"},"Infrastructure Layer",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"ORM")))),(0,i.kt)("h2",{id:"model-driven-design"},"Model-Driven Design"),(0,i.kt)("mermaid",{value:"flowchart LR\n  mdd(Model-Driven Design) --\x3e|express model with|s(services)\n  mdd(Model-Driven Design) --\x3e|express model with|e(Entities)\n  mdd(Model-Driven Design) --\x3e|express model with|vo(Value Object)\n  mdd(Model-Driven Design) --\x3e|isolate domain with|la(Layered Architecture)\n\n  e --\x3e|access with|r(Repositories)\n  e --\x3e|maintain integrity with|a(Aggregates)\n  e --\x3e|act as root of|a\n  e --\x3e|encapsulate with|f(Factories)\n\n  vo --\x3e|encapsulate with|a\n  vo --\x3e|encapsulate with|f\n\n  a --\x3e|encapsulate with|f\n  a --\x3e|access with|r"}),(0,i.kt)("h3",{id:"components-1"},"Components"),(0,i.kt)("h4",{id:"entities"},"Entities"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"distinguished by its identity",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"guaranteed the uniqueness"))),(0,i.kt)("li",{parentName:"ul"},"need to maintain the life cycle"),(0,i.kt)("li",{parentName:"ul"},"e.g. user")),(0,i.kt)("h4",{id:"value-objects"},"Value Objects"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"representing a descriptive aspect of the domain with no conceptual identity",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"representing elements of the design that we care about only for ",(0,i.kt)("em",{parentName:"li"},"what")," they are, not ",(0,i.kt)("em",{parentName:"li"},"who")," or ",(0,i.kt)("em",{parentName:"li"},"which")," they are"))),(0,i.kt)("li",{parentName:"ul"},"immutable"),(0,i.kt)("li",{parentName:"ul"},"disposable"),(0,i.kt)("li",{parentName:"ul"},"e.g.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"attributes of an Entity"),(0,i.kt)("li",{parentName:"ul"},"used as parameters in messages between objects")))),(0,i.kt)("mermaid",{value:'classDiagram\n  note for Customer "Entity"\n  note for Address "Value Object"\n  Customer *-- Address\n  class Customer{\n    customerID\n    name\n    address\n  }\n  class Address{\n    street\n    city\n    state\n  }'}),(0,i.kt)("h4",{id:"services"},"Services"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"overview",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"an operation offered as an interface that stands alone in the model, without encapsulating state, as Entities and Value Objects do",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"operation names should come from the Ubiquitous Language or be introduced into it"),(0,i.kt)("li",{parentName:"ul"},"parameters and results should be domain objects"))))),(0,i.kt)("li",{parentName:"ul"},"characteristics",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the operation relates to a domain concept that is not a natural part of an Entity or Value Object"),(0,i.kt)("li",{parentName:"ul"},"the interface is defined in terms of other elements of the domain model"),(0,i.kt)("li",{parentName:"ul"},"the operation is stateless")))),(0,i.kt)("h3",{id:"life-cycle-management-of-domain-objects"},"Life Cycle Management of Domain Objects"),(0,i.kt)("h4",{id:"aggregates"},"Aggregates"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a cluster of associated objects that we treat as a unit for the purpose of data changes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"transaction against the associated objects"))),(0,i.kt)("li",{parentName:"ul"},"responsibilities",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"invariant enforcement"),(0,i.kt)("li",{parentName:"ul"},"change management"))),(0,i.kt)("li",{parentName:"ul"},"consists of a root and a boundary",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"root",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a single, specific Entity"),(0,i.kt)("li",{parentName:"ul"},"objects outside the Aggregate can reference to only the root"),(0,i.kt)("li",{parentName:"ul"},"can be obtained directly from resource (e.g. database)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"other objects must be found by traversal of associations"))))),(0,i.kt)("li",{parentName:"ul"},"boundary",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a delete operation must remove everything within the boundary at once"),(0,i.kt)("li",{parentName:"ul"},"when a change to any object within the boundary is commited, all invariants of the whole Aggregate must be satisfied")))))),(0,i.kt)("h4",{id:"factories"},"Factories"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"manage the beginning of the object's life cycle"),(0,i.kt)("li",{parentName:"ul"},"create and reconstitute complex objects",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"delegate invariant checking to objects or aggregate"),(0,i.kt)("li",{parentName:"ul"},"ensure that creating objects satisfy client and internal rules")))),(0,i.kt)("h4",{id:"repositories"},"Repositories"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"manage the middle and end of the object's life cycle"),(0,i.kt)("li",{parentName:"ul"},"motivation",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"allowing free access from client to infrastructure such as database leads to complicate the client and obscure model-driven design"))),(0,i.kt)("li",{parentName:"ul"},"emulate access to infrastructure as if it is just like to manipulate a in-memory collection such as lists and maps",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"but leave transaction control to the client"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"don't fight frameworks"),"; look for affinities between the concepts of domain-driven design and the concenpts in the framework"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Repositories as object are not necessary when contructing a workflow to place I/O process to the edge in the workflow"))),(0,i.kt)("mermaid",{value:"flowchart LR\n  jxi(JSON/XML)\n  ds(Desirialize)\n  di(DTO-In; Data Transfer Object)\n  di2dm(DTO-In to Domain Model)\n  dm(Domain Model)\n  dm2do(Domain Model to DTO-Out)\n  do(DTO-Out; Data Transfer Object)\n  so(Serialize)\n  jxo(JSON/XML)\n\n  subgraph From Upstream Context\n  jxi --\x3e ds\n  ds --\x3e di\n  end\n\n  subgraph Bounded Context\n    subgraph I/O-In\n      di --\x3e di2dm\n    end\n\n  di2dm --\x3e dm\n  dm --\x3e dm2do\n\n    subgraph Pure Code\n      dm\n    end\n    subgraph I/O-Out\n      dm2do\n    end\n  end\n\n  subgraph To Donwstream Context\n  dm2do --\x3e do\n  do --\x3e so\n  so --\x3e jxo\n  end"}),(0,i.kt)("h2",{id:"supple-design"},"Supple Design"),(0,i.kt)("mermaid",{value:"flowchart LR\n  ul(Ubiquitous Language)\n  iri(Intention-Revealing Interfaces)\n  mmd(Model-Driven Design)\n  sc(Standalone Classes)\n  cc(Conceptual Contours)\n  coo(Closure of Operations)\n  seff(Side-Effect-Free Functions)\n  a(Assertions)\n\n  iri --\x3e|draw from| ul\n  iri --\x3e|simplify interpretation| coo\n  iri --\x3e|make safe and simple| seff\n  iri --\x3e|make side effects explicit| a\n\n  seff <--\x3e|make composition safe| a\n\n  mmd --\x3e|simplify interpretation| sc\n  mmd --\x3e|express model through| iri\n  mmd --\x3e|reduce cost of change| cc\n\n\n  sc --\x3e|may use| coo\n"}),(0,i.kt)("h2",{id:"model-integrity-patterns"},"Model Integrity Patterns"),(0,i.kt)("mermaid",{value:"flowchart TD\n  bc(Bounded Context)\n  ul(Ubiquitous Language)\n  ci(Continuous Integration)\n  cm(Context Map)\n  sk(Shared Kernel)\n  cst(Customer/Supplier Teams)\n  c(Conformist)\n  ohs(Open Host Service)\n  pl(Published Language)\n  sw(Separate Ways)\n  al(Anticorruption Layer)\n\n  bc --\x3e|names enter| ul\n  bc --\x3e|keep model unified by| ci\n  bc --\x3e|assess/overview relationships with| cm\n  cm --\x3e|oeverlap allied contexts through| sk\n  cm --\x3e|relate allied contexts as| cst\n  cm --\x3e|overlap unilaterally as| c\n  cm --\x3e|support multiple clients through| ohs\n  ohs --\x3e|formalize as| pl\n  cm --\x3e|free teams to go| sw\n  cm --\x3e|traslate and insulate unilaterally with| al\n"}),(0,i.kt)("h2",{id:"referencies"},"Referencies"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.amazon.co.jp/-/en/John-K-Ousterhout-ebook/dp/B09B8LFKQL"},"A Philosophy of Software Design")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.oreilly.com/library/view/clean-architecture-a/9780134494272/"},"Clean Architecture: A Craftsman\u2019s Guide to Software Structure and Design")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.oreilly.com/library/view/fundamentals-of-software/9781492043447/"},"Fundamentals of Software Architecture")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.oreilly.com/library/view/domain-driven-design-tackling/0321125215/"},"Domain-Driven Design: Tackling Complexity in the Heart of Software")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://pragprog.com/titles/swdddf/domain-modeling-made-functional/"},"Domain Modeling Made Functional - Tackle Software Complexity with Domain-Driven Design and F#"))))}c.isMDXComponent=!0}}]);