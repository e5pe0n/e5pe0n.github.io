---
title: "Note: Haskell 2"
categories:
  - Note
tags:
  - Haskell
last-modified-at: 2021-01-23
---

# Interactive Programming

Interactive programs has side effects such as additional inputs and outputs while the program is running.  

![interactive_program]({{site.url}}{{site.baseurl}}/assets/Haskell_images/interactive_program.png)

Haskell treats an interactive program as a pure function that takes the current *state of world* as its arguments, and produces a modified world as its result  

Expressions of type IO a are called *actions*  
- type IO Char: type of actions that return a character
- type IO (): type of actions that return the empty tuple `()` as a dummy result value

```hs
type IO = World -> World

type IO a = World -> (a, World)

type Char -> IO Int -- means type Char -> World -> (Int, World)
```

## Basic Actions

```hs
getChar :: IO Char

putChar :: Char -> IO ()

return :: a -> IO a
```

## Sequencing

- `<-` is called *generator* as with list comprehensions
  - if a value generated by `ai` is unnecessary, generator is abbreviated by `ai` which means `_ <- ai`

```hs
do v1 <- a1
   v2 <- a2
   ...
   vn <- an
   return (f v1 v2 ... vn)
```

```hs
act :: IO (Char, Char)
act = do x <- getChar
         getChar
         y <- getChar
         return (x, y)
```

## Derived primitives

action primitives in the standard prelude
- getLine: read chars until `\n`
- putStr: without `\n`
- putStrLn: with `\n`

```hs
getLine :: IO String
getLine = do x <- getChar
             if x == '\n' then
                return []
             else
                do xs <- getLine
                   return (x : xs)


putStr :: String -> IO ()
putStr [] = return ()
putStr (x : xs) = do putChar x
                     putCStr xs


putStrLn :: String -> IO ()
putStrLn xs = do putStr xs
                 putChar '\n'
```

```hs
strlen :: IO ()
strlen = do putStr "Enter a string: "
            xs <- getLine
            putStr "The string has "
            putStr (show (length xs))
            putStrLn " characters"
```

<br>

# Functors

class of types that support a mapping function.

```hs
class Functor f where
  fmap :: (a -> b) -> f a -> f b
```

- `fmap` takes a function of type `a -> b` and a structure of type `f a` whose elements have type `a`
- `fmap` applies the function to each element to give a structure of type `f b` whose elements have type `b`

```hs
instance Functor [] where
  -- fmap :: (a -> b) -> [a] -> [b]
  fmap = map


instance Functor Maybe where
  -- fmap :: (a -> b) -> Maybe a -> Maybe b
  fmap _ Nothing = Nothing
  fmap g (Just x) = Just (g x)

fmap (+1) Nothing     -- Nothing
fmap (*2) (Just 3)    -- Just 6
fmap not (Just False) -- Just True
```

```hs
data Tree a = Leaf | Node (Tree a) (Tree a)
  deriving Show

instance Functor Tree where
  -- fmap :: (a -> b) -> Tree a -> Tree b
  fmap g (Leaf x) = Leaf (g x)
  fmap g (Node l r) = Node (fmap g l) (fmap g r)

fmap length (Leaf "abc")  -- Leaf 3
fmap even (Node (Leaf 1) (Leaf 2))  -- Node (Leaf False) (Leaf True)
```

```hs
instance Functor IO where
  -- fmap :: (a -> b) -> IO a -> IO b
  fmap g mx = do {x <- mx; return (g x)}

fmap show (return True) -- "True"
```

```hs
inc :: [Int] -> [Int]
inc = map (+ 1)

inc' :: Functor f => f Int -> f Int
inc' = fmap (+ 1)

inc' (Just 1) -- Just 2
inc' [1, 2, 3, 4, 5]  -- [2, 3, 4, 5, 6]
inc' (Node (Leaf 1) (Leaf 2)) -- Node (Leaf 2) (Leaf 3)
```

## Functor Laws

```hs
fmap id = id
fmap (g . h) = fmap g . fmap h
```

<br>

# Applicatives

## applicative functors; applicative**

the class of functors that support `pure` and `<*>` functions

```hs
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
```

```hs
pure :: a -> f a
(<*>) :: f (a -> b) -> f a -> f b

fmap0 :: a -> f a
fmap0 = pure

fmap1 :: (a -> b) -> f a -> f b
fmap1 = pure g <*> x

fmap2 :: (a -> b -> c) -> f a -> f b -> f c
fmap2 = pure g <*> x <*> y

fmap3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d
fmap3 = pure g <*> x <*> y <*> z

...


-- type check. fmap2
-- f (a -> b -> c) -> f a -> f (b -> c)
--     pure g     <*>  x  =      x'

-- f (b -> c) -> f b -> f c
--      x'   <*> y  =  res
```

The applicative style for *Maybe* supports a form of *exceptional* programming in which we can apply pure functions to arguments that may fail without the need to manage the propagation of failure ourselves.  

```hs
instance Applicative Maybe where
  -- pure :: a -> Maybe a
  pure = Just

  -- (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b
  Nothing <*> _ = Nothing
  (Just g) <*> mx = fmap g mx

pure (+ 1) <*> Just 1           -- Just 2
pure (+) <*> Just 1 <*> Just 2  -- Just 3
pure (+) <*> Nothing <*> Just 2 -- Nothing
```

The applicative sytle for lists supports a form of *non-deteministic* programming in which we can apply pure functions to multi-valued arguments without the need to manage the selection of values or the propagation of failure.  

```hs
instance Applicative [] where
  -- pure :: a -> [a]
  pure x = [x]

  -- (<*>) :: [a -> b] -> [a] -> [b]
  gs <*> xs = [g x | g <- gs, x <- xs]

pure (+ 1) <*> [1, 2, 3]        -- [2, 3, 4]
pure (+) <*> [1] <*> [2]        -- [3]
pure (*) <*> [1, 2] <*> [3, 4]  -- [3, 4, 6, 8]

prods :: [Int] -> [Int] -> [Int]
prods xs ys = [x * y | x <- xs, y <- ys]

prods' :: [Int] -> [Int] -> [Int]
prods' xs ys = pure (*) <*> xs <*> ys
```

The applicative style for IO supports a form of *interactive* programming in which we can apply pure functions to impure arguments without the need to manage the sequencing of actions or the extranction of result values.  

```hs
instance Applicative IO where
  -- pure :: a -> IO a
  pure = return

  -- (<*>) :: IO (a -> b) -> IO a -> IO b
  mb <*> mx = do {g <- mg; x <- mx; return (g x)}

getChars :: Int -> IO String
getChars 0 = return []
getChars n = pure (:) <*> getChar <*> getChars (n - 1)
```

```hs
sequenceA :: Applicative f => [f a] -> f [a]
sequenceA [] = pure []
sequenceA (x : xs) = pure (:) <*> x <*> sequecneA xs

getChars :: Int -> IO String
getChars n = sequenceA (replicate n getChar)
```

## Applicative Laws

```hs
pure id <*> x = x -- pure is complemented
pure (g x) = pure g <*> pure x  -- occurences of pure can be combined into one
x <*> pure y = pure (\g -> g y) <*> x -- the order in which we evaluate the two components doesn't matter
x <*> (y <*> z) = (pure (.) <*> x <*> y) <*> z  -- <*> is associative
```

these laws ensure that below expression is evaluated  uniquely.  

```hs
pure g <*> x1 <*> x2 <*> ... <*> xn
```

## Infix ver.

```hs
fmap g x = pure g <*> x
g <$> x = fmap g x

g <$> x1 <*> x2 <*> ... <*> xn
```

<br>

# Monads

```hs
class Applicative m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b

  return = pure
```

## `>>=` operator

- called *bind*.  
- ensures that such an expression only succeeds if every component $m_i$ in the sequence succeeds

```hs
(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
mx >>= f = case mx of
  Nothing -> Nothing
  Just x -> f x
```

```hs
-- Notation 1
m1 >>= \x1 ->
m2 >>= \x2 ->
...
mn >>= \xn ->
f x1 x2 ... xn

-- Notation 2
do x1 <- m1
   x2 <- m2
   ...
   xn <- mn
   f x1 x2 ... xn
```

## Monad Laws

```hs
return x >>= f = f x  -- (return x) >>= f = f x
mx >>= return = mx
(mx >>= f) >>= g = mx >>= (\x -> (f x >>= g)) -- assosiatative
```

## Usecases

applicative style does not fit the pattern of effectful programming such as the function which is the first argument of `<*>` is not pure function.  
- e.g. `safediv` is not a pure function because it returns `Maybe Int`, not `Int`

```hs
data Expr = Val Int | Div Expr Expr

eval :: Expr -> Int
eval (Val n) = n
eval (Div x y) = eval x `div` eval y

eval (Div (Val 1) (Val 0))  -- *** Exception: divide by zero


safediv :: Int -> Int -> Maybe Int
safediv _ 0 = Nothing
safediv n m = Just (n `div` m)

eval' :: Expr -> Maybe Int
eval' (Val n) = Just n
eval' (Div x y) = case eval x of
  Nothing -> Nothing
  Just n -> case eval y of
    Nothing -> Nothing
    Just m -> safediv n m

eval' (Div (Val 1) (Val 0)) -- Nothing


eval' :: Expr -> Maybe Int
eval' (Val n) = pure n
eval' (Div x y) = pure safediv <*> eval x <*> eval y  -- type error
```

apply *monad* then

```hs
instance Monad Maybe where
  -- (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
  Nothing >>= _ = Nothing
  (Just x) >>= f = f x

data Expr = Val Int | Div Expr Expr

safediv :: Int -> Int -> Maybe Int
safediv _ 0 = Nothing
safediv n m = Just (n `div` m)

-- Notation 1
eval :: Expr -> Maybe Int
eval (Val n) = Just n
eval (Div x y) =
  eval x >>= \n ->
    eval y >>= \m ->
      safediv n m

-- Notation 2
eval' :: Expr -> Maybe Int
eval' (Val n) = Just n
eval' (Div x y) = do
  n <- eval' x
  m <- eval' y
  safediv n m  
```

```hs
instance Monad [] where
  -- (>>=) :: [a] -> (a -> [b]) -> [b]
  xs >>= f = [y | x <- xs, y <- f x]

pairs :: [a] -> [b] -> [(a, b)]
pairs xs ys =
  xs >>= \x ->
    ys >>= \y ->
      return (x, y)

pairs :: [a] -> [b] -> [(a, b)]
pairs xs ys = do
  x <- xs
  y <- ys
  return (x, y)
```

## The State Monad

```hs
type State = Int  -- state is just an integer value but this can be modified as required
```

### *state tronsformer*; *ST*

takes an input state as its argument and produces an ouptut state as its result

```hs
type ST = State -> State
type ST a = State -> (a, State) -- returns State with an output of type `a`
type a -> ST b -- type a -> State -> (b, State)
-- takes State with an input of type `a` and returns State with an output of type `b`
```

we want to make *ST* into a monad but types declared using the type mechanism cannot be made into instances of classes.  
so we need to define it using *newtype*.  

```hs
newtype ST a = S (State -> (a, State))

-- removes dummy constructor `S`
app :: ST a -> State -> (a, State)
app (S st) x = st x


instance Functor ST where
  -- fmap :: (a -> b) -> ST a -> ST b
  fmap g st = S (\s -> let (x, s') = app st s in (g x, s'))

instance Applicative ST where
  -- pure :: a -> ST a
  pure x = S (\s -> (x, s))

  -- (<*>) :: ST (a -> b) -> ST a -> ST b
  stf <*> stx =
    S
      ( \s ->
          let (f, s') = app stf s
              (x, s'') = app stx s'
           in (f x, s'')
      )

instance Monad ST where
  -- (>>=) :: ST a -> (a -> ST b) -> ST b
  st >>= f = S (\s -> let (x, s') = app st s in app (f x) s')
```


## Generic Functions

### mapM()

```hs
-- defined in Control.Monad
mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM f [] = return []
mapM f (x : xs) = do
  y <- f x
  ys <- mapM f xs
  return (y : ys)
```

```hs
import Data.Char

conv :: Char -> Maybe Int
conv c
  | isDigit c = Just (digitToInt c)
  | otherwise = Nothing

mapM conv "1234"  -- Just [1, 2, 3, 4]
mapM conv "123a"  -- Nothing
```

### filterM()

```hs
-- defined in Control.Monad
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
filterM p [] = return []
filterM p (x : xs) = do
  b <- p x
  ys <- filter M p xs
  return (if b then x : ys else ys)

filterM (\x -> [True, False]) [1, 2, 3]
-- [[1, 2, 3], [1, 2], [1, 3], [1], [2, 3], [2], [3], []]
```

### join()

```hs
join :: Monad m => m (m a) -> m a
join mmx = do
  mx <- mmx
  x <- mx
  return x

join [[1, 2], [3, 4], [5, 6]] -- [1, 2, 3, 4, 5, 6]
join (Just (Just 1))  -- Just 1
join (Just Nothing) -- Nothing
join Nothing  -- Nothing
```

<br>

<hr>

<br>

# Alternative

```hs
class Applicative f => Alternative f where
  empty :: f a
  (<|>) :: f a -> f a -> f a
```

## Alternative Laws

```hs
empty <|> x = x
x <|> empty = x
x <|> (x <|> y) = (x <|> y) <|> z -- associative
```

## Alternative Instances

```hs
instance Alternative Maybe where
  -- empty :: Maybe a
  empty = Nothing

  -- (<|>) :: Maybe a -> Maybe a -> Maybe a
  Nothing <|> my = my
  (Just x) <|> _ = Just x
```

<br>

<hr>

<br>

# Monoids

```hs
class Monoids a where
  mempty :: a
  mappend :: a -> a -> a

  mconcat :: [a] -> a
  mconcat = foldr mappend mempty
```

## Monoid Laws

```hs
mempty `mappend` x = x
x `mappend` mempty = x
x `mappend` (y `mappend` z) = (x `mappend` y) `mappend` z

-- using <> operator
mempty <> x = x
x <> mempty = x
x <> (y <> z) = (x <> y) <> z
```

## Data.Monoid
### Lists

```hs
instance Monoid [a] where
  -- mempty :: [a]
  mempty = []

  -- (<>) :: [a] -> [a] -> [a]
  mappend = (++)
```

### Maybe

```hs
instance Monoid a => Monoid (Maybe a) where
  -- mempty :: Maybe a
  mempty = Nothing

  -- (<>) :: Maybe a -> Maybe a -> Maybe a
  Nothing <> my = my
  mx <> Nothing = mx
  Just x <> Just y = Just (x <> y)
```

### Sum

```hs
newtype Sum a = Sum a
  deriving (Eq, Ord, Show, Read)

getSum :: Sum a -> a
getSum (Sum x) = x


instance Num a => Monoid (Sum a) where
  -- mempty :: Sum a
  mempty = Sum 0

  -- (<>) :: Sum a -> Sum a -> Sum a
  Sum x <> Sum y = Sum (x + y)


mconcat [Sum 2, Sum 3, Sum 4] -- Sum 9
```

### Product

```hs
newtype Product a = Product a
  deriving (Eq, Ord, Show, Read)

getProduct :: Product a -> a
getProduct (Product x) = x


instance Num a => Monoid (Product a) where
  -- mempty :: Product a
  mempty = Product 1

  -- (<>) :: Product a -> Product a -> Product a
  Product x <> Product y = Product (x * y)


mconcat [Product 2, Product 3, Product 4] -- Product 24
```

### All

```hs
mconcat [All True, All True, All True]  -- All True
```

### Any

```hs
mconcat [Any False, Any False, Any False] -- Any False
```


# Foldables


**Note:**  
minimal complete definition for an instance of the *Foldable* class is to define either *foldMap* or *foldr*  

```hs
class Foldable t where
  fold :: Monoid a => t a -> a
  foldMap :: Monoid b => (a -> b) -> t a -> b
  foldr :: (a -> b -> b) -> b -> t a -> b
  foldl :: (a -> b -> a) -> a -> t b -> a

  null :: t a -> Bool
  length :: t a -> Int
  elem :: Eq a => a -> t a -> Bool
  maximum :: Ord a => t a -> a
  minimum :: Ord a => t a -> a
  sum :: Num a => t a -> a
  product :: Num a => t a -> a

  foldr1 :: (a -> a -> a) -> t a -> a
  foldl1 :: (a -> a -> a) -> t a -> a

  toList :: t a -> [a]

  -- default definitions
  null = null . toList
  length = length . toList
  elem x = elem x . toList
  maximum = maximum . toList
  minimum = minimum . toList
  sum = sum . toList
  product = product . toList

  foldr f v = foldr f v . toList
  foldl r v = foldl f v . toList
  foldr1 f = fold1 f . toList
  foldl1 f = fold1 f . toList

  fold = foldMap id
  foldMap f = foldr (mappend . f) mempty
  toList = foldMap (\x -> [x])
```

## List

```hs
instance Foldable [] where
  -- fold :: Monoid a => [a] -> a
  fold [] = mempty
  fold (x : xs) = x <> fold xs

  -- foldMap :: Monoid b => (a -> b) -> [a] -> b
  foldMap _ [] = mempty
  foldMap f (x : xs) = f x <> foldMap f xs

  -- foldr :: (a -> b -> b) -> b -> [a] -> b
  foldr _ v [] = v
  foldr f v (x : xs) = f x (foldr f v xs)

  -- foldl :: (a -> b -> a) -> a -> [b] -> a
  foldl _ v [] = v
  foldl f v (x : xs) = foldl f (f v x) xs


getSum (foldMap Sum [1..10])  -- 55
getProduct (foldMap Product [1..10])  -- 3628800
```

## Tree

```hs
data Tree a = Leaf a | Node (Tree a) (Tree a)
  deriving (Show)

instance Foldable Tree where
  -- fold :: Monoid a => Tree a -> a
  fold (Leaf x) = x
  fold (Node l r) = fold l <> fold r

  -- foldMap :: Monoid b => (a -> b) -> Tree a -> b
  foldMap f (Leaf x) = f x
  foldMap f (Node l r) = foldMap f l <> foldMap f r

  -- foldr :: (a -> b -> b) -> b -> Tree a -> b
  foldr f v (Leaf x) = f x v
  foldr f v (Node l r) = foldr f (foldr f v r) l

  -- foldl :: (a -> b -> a) -> a -> Tree b -> a
  foldl f v (Leaf x) = f v x
  foldl f v (Node l r) = foldl f (foldl f v l) r


tree :: Tree Int
tree = Node (Node (Leaf 1) (Leaf 2)) (Leaf 3)

foldr (+) 0 -- 1 + (2 + (3 + 0))
foldl (+) 0 -- ((0 + 1) + 2) + 3
foldl (+) (Node (Leaf 1) (Leaf 2))  -- 3
toList (Node (Leaf 1) (Leaf 2)) -- [1,2]
```

## Generic Functions

```hs
import Data.Foldable

data Tree a = Leaf a | Node (Tree a) (Tree a)
  deriving (Show)

instance Foldable Tree where
  -- foldMap :: Monoid b => (a -> b) -> Tree a -> b
  foldMap f (Leaf x) = f x
  foldMap f (Node l r) = foldMap f l <> foldMap f r

average :: [Int] -> Int
average ns = sum ns `div` length ns

average' :: Foldable t => t Int -> Int
average' ns = sum ns `div` length ns

main = do
  print (average' [1 .. 10])  -- 5
  print (average' (Node (Leaf 1) (Leaf 3))) -- 2
```

### and()

```hs
and :: Foldable t => t Bool -> Bool
and = getAll . foldMap All

main = do
  print (and [True, False, True]) -- False
```

### or()

```hs
or :: Foldable t => t Bool -> Bool
or = getAny . foldMap Any

main = do
  print (or (Node (Leaf True) (Leaf False)))  -- True
```

### all()

```hs
all :: Foldable t => (a -> Bool) -> t a -> Bool
all p = getAll . foldMap (All . p)

main = do
  print (all even [1, 2, 3])  -- False
```

### any()

```hs
any :: Foldable t => (a -> Bool) -> t a -> Bool
any p = getAny . foldMap (Any . p)

main = do
  print (any even (Node (Leaf 1) (Leaf 2))) -- True
```

### concat()

```hs
concat :: Foldable t => t [a] -> [a]
concat = fold

main = do
  print (concat ["ab", "cd", "ef"]) -- "abcdef"
  print (concat (Node (Leaf [1, 2]) (Leaf [3])))  -- [1,2,3]
```

<br>

# Traversable

**Note:**  
A definition of either *traverse* or *sequenceA* is needed but *traverse* is prefarable rather than *sequenceA* because default *traverse* definition is unefficient due to passing through the data structure twice, when *fmap* and *sequenceA*.  


```hs
class (Functor t, Foldable t) => Traversable t where
  traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
  traverse g = sequenceA . fmap g

  sequenceA :: Applicative f = t (f a) -> f (t a)
  sequenceA = traverse id

  mapM :: Monad m => (a -> m b) -> t a -> m (t b)
  mapM = traverse

  sequence :: Monad m => t (m a) -> m (t a)
  sequence = sequenceA
```

## List

```hs
instance Traversable [] where
  -- traverse :: Applicative f => (a -> f b) -> [a] -> f [b]
  traverse g [] = pure []
  traverse g (x : xs) = pure (:) <*> g x <*> traverse g xs

dec :: Int -> Maybe Int
dec n = if n > 0 then Just (n - 1) else Nothing

main = do
  print (traverse dec [1, 2, 3])  -- Just [0,1,2]
  print (traverse dec [2, 1, 0])  -- Nothing

  print (sequenceA [Just 1, Just 2, Just 3])  -- Just [1, 2, 3]
  print (sequenceA [Just 1, Nothing, Just 3]) -- Nothing
```

## Tree

```hs
instance Traversable Tree where
  -- traverse :: Applicative f => (a -> f b) -> Tree a -> f (Tree b)
  traverse g (Leaf x) = pure Leaf <*> g x
  traverse g (Node l r) = pure Node <*> traverse g l <*> traverse g r

dec :: Int -> Maybe Int
dec n = if n > 0 then Just (n - 1) else Nothing

main = do
  print (traverse dec (Node (Leaf 1) (Leaf 2))) -- Just (Node (Leaf 0) (Leaf 1))
  print (traverse dec (Node (Leaf 0) (Leaf 1))) -- Nothing

  print (sequenceA (Node (Leaf (Just 1)) (Leaf (Just 2))))  -- Just (Node (Leaf 1) (Leaf 2))
  print (sequenceA (Node (Leaf (Just 1)) (Leaf Nothing))) -- Nothing
```


<br>

<hr>

<br>

# Lazy Evaluation

**Lazy evaluation** is the use of *call-by-name* evaluation in conjunction with sharing such as using pointer   

In Haskell, any two different ways of evaluating the same expression will always produce the same final value, provided that they both terminate.  

```hs
inc :: Int -> Int
inc n = n + 1

-- from right
inc (2 * 3)
= { applying * }
inc 6
= { applying inc }
6 + 1
= { applying + }
7

-- from left
inc (2 * 3)
= { applying inc }
(2 * 3) + 1
= { applying * }
6 + 1
= { applying + }
7
```

## call-by-value evaluation

*call-by-name* evaluation is preferable to *call-by-value* for ensuring that evaluation terminates as often as possible.  

$\because$ *call-by-name* evaluation will terminate if there exists any evaluation sequence that terminates for a given expression, and produce the same final value.  

```hs
square :: Int -> Int
square n = n * n
```

```
square (1 + 2)
= { applying square }
(1 + 2) * (1 + 2)
= { applying the first +}
3 * (1 + 2)
= { applying + }  -- redundant reduction but can be resolved by using pointer to copy `(1 + 2)`
3 * 3
= { applying * }
9
```

the following expression terminates in *call-by-name* evaluation.  

```hs
inf :: Int
inf = 1 + inf
```

```
fst (0, inf)
= { applying fst }
0
```

## call-by-name evaluation

```
square (1 + 2)
= { applying + }
square 3
= { applying square }
3 * 3
= { applying * }
9
```

the following expression does not terminate in *call-by-value* evaluation.  

```
fst (0, inf)
= { applying inf }
fst (0, 1 + inf)
= { applying inf }
fst (0, 1 + (1 + inf))
= { applying inf }
...
```

## Modular Programming

Lazy evaluation allows us to separate *control* from *data* in our computations.  

```hs
-- take 3: control
-- ones: data
take 3 ones -- [1,1,1]

-- pattern of without lazy evaluation:
-- need to make (= control) a certain data.
-- cannot separate control from data.
replicate 3 1 -- [1,1,1]
```

*the sieve of Eratosthenes*  

```hs
primes :: [Int]
primes = sieve [2 ..]

sieve :: [Int] -> [Int]
sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p /= 0]

main = do
  print (take 10 primes) -- [2,3,5,7,11,13,17,19,23,29]
  print (takeWhile (< 10) primes) -- [2,3,5,7]
```

![sieve]({{site.url}}{{site.baseurl}}/assets/Haskell_images/sieve.png)


## Strict Application

*strict* functions such as built-in arithmetic operator, `*` and `+` cannot be applied until their two arguments have been evaluated to numbers; values  

`f $! x`; `f` is immediately applied to `x` (if x is an expression, after evaluation of x)  

`$!` serves as a stopper for outmost evaluation

```
square $! (1 + 2)
= { applying + }
square $! 3
= { applying $! }
square 3
= { applying square }
3 * 3
= { applying * }
9
```

**strict application is mainly used to improve the space performance of programs.**  

pattern with lazy evaluation  

```hs
sumwith :: Int -> [Int] -> Int
sumwith v [] = v
sumwith v (x : xs) = sumwith (v + x) xs
```

```
sumwith 0 [1, 2, 3]
= { applying sumwith }
sumwith (0 + 1) [2, 3]
= { applying sumwith }
sumwith ((0 + 1) + 2) [3]
= { applying sumwith }
sumwith (((0 + 1) + 2) + 3) []
= { applying sumwith }
((0 + 1) + 2) + 3 -- the length is the same with the original list so sumwith requires much space for evaluation if given a long list.  
= { applying the first + }
(1 + 2) + 3
= { applying the first + }
3 + 3
= { applying + }
6
```

pattern with strict application  

```hs
sumwith :: Int -> [Int] -> Int
sumwith v [] = v
sumwith v (x : xs) = (sumwith $! (v + x)) xs
```

```
sumwith 0 [1, 2, 3]
= { applying sumwith }
(sumwith $! (0 + 1)) [2, 3]
= { applying + }
(sumwith $! 1) [2, 3]
= { applying $! }
sumwith 1 [2, 3]
= { applying sumwith }
(sumwith $! (1 + 2)) [3]
= { applying + }
(sumwith $! 3) [3]
= { applying $! }
sumwith 3 [3]
= { applying sumwith }
(sumwith $! (3 + 3)) []
= { applying + }
(sumwith $! 6) []
= { applying $! }
sumwith 6 []
= { applying sumwith }
6
```

## foldl'

```hs
-- in Data.Foldable

foldl' :: (a -> b -> a) -> a -> [b] -> a
foldl' f v [] = v
foldl' f v (x : xs) = ((foldl' f) $! (f v x)) xs
```

# Reasoning

## Induction

can be used to confirm the logic or propeties of a recursive type or a recursive function is correct.  

e.g.1 (about natural number)

```hs
replicate :: Int -> a -> [a]
replicate 0 _ = []
replicate n x = x : replicate (n - 1) x
```

```
-- hypothesis:
-- replication function produce a list when n elements, that is `length (replicate n x) = n`

-- Base case:
length (replicate 0 x)
= { applying replicate }
length []
= 0

-- Inductive case
length (replicate (n + 1) x)
= { applying replicate }
length (x : replicate n x)
= { applying length }
1 + length (replicate n x)
= { induction hypothesis }
1 + n
= { commutativity of + }
n + 1
```

e.g.2 (about list)  

```hs
reverse :: [a] -> [a]
reverse [] = []
reverse (x : xs) = reverse xs ++ x
```

```
-- hypothesis 1:
-- contravariant; reverse (xs ++ ys) = reverse ys ++ reverse xs

-- Base case:
reverse ([] ++ ys)
= { applying ++ }
reverse ys
= { identity for ++ }
reverse ys ++ []
= { unapplying reverse }
reverse ys ++ reverse []

-- Inductive case:
reverse ((x : xs) ++ ys)
= { applying ++ }
reverse (x : (xs ++ ys))
= { applying reverse }
reverse (xs ++ ys) ++ [x]
= { induction hypothesis }
(reverse ys ++ reverse xs) ++ [x]
= { associativity of ++ }
reverse ys ++ (reverse xs ++ [x])
= { unapplying the second reverse }
reverse ys ++ reverse (x : xs)
```

```
-- hypothesis 2:
-- reverse (reverse (x : xs)) = x : xs

-- Base case:
reverse (reverse [])
= { applying the inner reverse }
reverse []
= { appyling reverse }
[]

-- Inductive case:
reverse (reverse (x : xs))
= { applying the inner reverse }
reverse (reverse xs ++ [x])
= { contravariant }
reverse [x] ++ reverse (reverse xs)
= { singleton lists }
[x] ++ reverse (reverse xs)
= { induction hypothesis }
[x] ++ xs
= { applying ++ }
x : xs
```
